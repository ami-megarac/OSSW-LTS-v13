--- uboot_old/arch/arm/mach-aspeed/ast2600/board_common.c	2021-02-03 10:49:53.186738062 +0800
+++ uboot/arch/arm/mach-aspeed/ast2600/board_common.c	2021-02-03 10:50:37.561949371 +0800
@@ -75,6 +75,12 @@
 		if (ret)
 			break;
 	}
+
+#if defined(CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT) || defined(CONFIG_SPX_FEATURE_SECURE_BOOT_SUPPORT) 
+    *(volatile u32 *)(0x1e600000) = 0xaeed1a03;
+    *(volatile u32 *)(0x1e60008C) = 0;
+#endif 
+
 	// Hardware Strap 2, set decode 0x4E 
 	*(volatile u32 *)(0x1e6e2000) = 0x1688A8A8;
 #ifdef CONFIG_SPX_FEATURE_HW_FAILSAFE_BOOT
diff -Naur uboot_old/arch/arm/mach-aspeed/ast2600/spl_boot.c uboot/arch/arm/mach-aspeed/ast2600/spl_boot.c
--- uboot_old/arch/arm/mach-aspeed/ast2600/spl_boot.c	2020-11-20 17:00:27.000000000 +0800
+++ uboot/arch/arm/mach-aspeed/ast2600/spl_boot.c	2021-02-02 16:03:11.511294001 +0800
@@ -42,6 +42,7 @@
 }
 SPL_LOAD_IMAGE_METHOD("RAM with Aspeed Secure Boot", 0, ASPEED_SECBOOT_DEVICE_RAM, aspeed_secboot_spl_ram_load_image);
 
+#ifdef CONFIG_SPL_MMC_SUPPORT
 static int aspeed_spl_mmc_load_image(struct spl_image_info *spl_image,
 				      struct spl_boot_device *bootdev)
 {
@@ -162,7 +163,9 @@
 	return 0;
 }
 SPL_LOAD_IMAGE_METHOD("MMC with Aspeed Secure Boot", 0, ASPEED_SECBOOT_DEVICE_MMC, aspeed_secboot_spl_mmc_load_image);
+#endif
 
+#ifdef CONFIG_SPL_YMODEM_SUPPORT
 static int getcymodem(void)
 {
 	if (tstc())
@@ -170,6 +173,7 @@
 	return -1;
 }
 
+
 static int aspeed_spl_ymodem_load_image(struct spl_image_info *spl_image,
 		struct spl_boot_device *bootdev)
 {
@@ -253,3 +257,4 @@
 	return ret;
 }
 SPL_LOAD_IMAGE_METHOD("UART with Aspeed Secure Boot", 0, ASPEED_SECBOOT_DEVICE_UART, aspeed_secboot_spl_ymodem_load_image);
+#endif
\ No newline at end of file
diff -Naur uboot_old/cmd/aes.c uboot/cmd/aes.c
--- uboot_old/cmd/aes.c	2020-11-20 17:00:27.000000000 +0800
+++ uboot/cmd/aes.c	2021-01-12 18:32:13.449279727 +0800
@@ -2,7 +2,7 @@
 /*
  * Copyright (C) 2014 Marek Vasut <marex@denx.de>
  *
- * Command for en/de-crypting block of memory with AES-128-CBC cipher.
+ * Command for en/de-crypting block of memory with AES-[128/192/256]-CBC  cipher.
  */
 
 #include <common.h>
@@ -13,6 +13,18 @@
 #include <asm/byteorder.h>
 #include <linux/compiler.h>
 
+u32 aes_get_key_len(char *command)
+{
+   u32 key_len = AES128_KEY_LENGTH;
+
+   if (!strcmp(command, "aes.192"))
+           key_len = AES192_KEY_LENGTH;
+   else if (!strcmp(command, "aes.256"))
+           key_len = AES256_KEY_LENGTH;
+
+   return key_len;
+}
+
 /**
  * do_aes() - Handle the "aes" command-line command
  * @cmdtp:	Command data struct pointer
@@ -23,17 +35,19 @@
  * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
  * on error.
  */
-static int do_aes(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+int do_aes(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
 	uint32_t key_addr, iv_addr, src_addr, dst_addr, len;
 	uint8_t *key_ptr, *iv_ptr, *src_ptr, *dst_ptr;
-	uint8_t key_exp[AES_EXPAND_KEY_LENGTH];
-	uint32_t aes_blocks;
+    u8 key_exp[AES256_EXPAND_KEY_LENGTH];
+    u32 aes_blocks, key_len;
 	int enc;
 
 	if (argc != 7)
 		return CMD_RET_USAGE;
 
+	key_len = aes_get_key_len(argv[0]);
+
 	if (!strncmp(argv[1], "enc", 3))
 		enc = 1;
 	else if (!strncmp(argv[1], "dec", 3))
@@ -53,17 +67,17 @@
 	dst_ptr = (uint8_t *)dst_addr;
 
 	/* First we expand the key. */
-	aes_expand_key(key_ptr, key_exp);
+	aes_expand_key(key_ptr, key_len, key_exp);
 
 	/* Calculate the number of AES blocks to encrypt. */
-	aes_blocks = DIV_ROUND_UP(len, AES_KEY_LENGTH);
+	aes_blocks = DIV_ROUND_UP(len, AES_BLOCK_LENGTH);
 
 	if (enc)
-		aes_cbc_encrypt_blocks(key_exp, iv_ptr, src_ptr, dst_ptr,
-				       aes_blocks);
+		aes_cbc_encrypt_blocks(key_len, key_exp, iv_ptr, src_ptr,
+				       dst_ptr, aes_blocks);
 	else
-		aes_cbc_decrypt_blocks(key_exp, iv_ptr, src_ptr, dst_ptr,
-				       aes_blocks);
+		aes_cbc_decrypt_blocks(key_len, key_exp, iv_ptr, src_ptr,
+				       dst_ptr, aes_blocks);
 
 	return 0;
 }
@@ -71,13 +85,13 @@
 /***************************************************/
 #ifdef CONFIG_SYS_LONGHELP
 static char aes_help_text[] =
-	"enc key iv src dst len - Encrypt block of data $len bytes long\n"
+	"[.128,.192,.256] enc key iv src dst len - Encrypt block of data $len bytes long\n"
 	"                             at address $src using a key at address\n"
 	"                             $key with initialization vector at address\n"
 	"                             $iv. Store the result at address $dst.\n"
 	"                             The $len size must be multiple of 16 bytes.\n"
 	"                             The $key and $iv must be 16 bytes long.\n"
-	"aes dec key iv src dst len - Decrypt block of data $len bytes long\n"
+	"[.128,.192,.256] dec key iv src dst len - Decrypt block of data $len bytes long\n"
 	"                             at address $src using a key at address\n"
 	"                             $key with initialization vector at address\n"
 	"                             $iv. Store the result at address $dst.\n"
@@ -87,6 +101,6 @@
 
 U_BOOT_CMD(
 	aes, 7, 1, do_aes,
-	"AES 128 CBC encryption",
+	"AES 128/192/256 CBC encryption",
 	aes_help_text
 );
diff -Naur uboot_old/include/u-boot/rsa.h uboot/include/u-boot/rsa.h
--- uboot_old/include/u-boot/rsa.h	2020-11-20 17:00:27.000000000 +0800
+++ uboot/include/u-boot/rsa.h	2021-01-12 18:32:13.481278441 +0800
@@ -144,4 +144,5 @@
 /* This is the maximum signature length that we support, in bits */
 #define RSA_MAX_SIG_BITS	4096
 
+int rsa_get_pub_key_uboot_verify(const char *key_val, unsigned char *enc_hash, unsigned int enc_hash_len, unsigned char *hash, unsigned int hash_len);
 #endif
diff -Naur uboot_old/include/uboot_aes.h uboot/include/uboot_aes.h
--- uboot_old/include/uboot_aes.h	2020-11-20 17:00:27.000000000 +0800
+++ uboot/include/uboot_aes.h	2021-01-12 18:32:13.513277154 +0800
@@ -18,16 +18,24 @@
  * AES encryption library, with small code size, supporting only 128-bit AES
  *
  * AES is a stream cipher which works a block at a time, with each block
- * in this case being AES_KEY_LENGTH bytes.
+ * in this case being AES_BLOCK_LENGTH bytes.
  */
 
 enum {
 	AES_STATECOLS	= 4,	/* columns in the state & expanded key */
-	AES_KEYCOLS	= 4,	/* columns in a key */
-	AES_ROUNDS	= 10,	/* rounds in encryption */
-
-	AES_KEY_LENGTH	= 128 / 8,
-	AES_EXPAND_KEY_LENGTH	= 4 * AES_STATECOLS * (AES_ROUNDS + 1),
+	AES128_KEYCOLS  = 4,    /* columns in a key for aes128 */
+	AES192_KEYCOLS  = 6,    /* columns in a key for aes128 */
+	AES256_KEYCOLS  = 8,    /* columns in a key for aes128 */
+	AES128_ROUNDS   = 10,   /* rounds in encryption for aes128 */
+	AES192_ROUNDS   = 12,   /* rounds in encryption for aes192 */
+	AES256_ROUNDS   = 14,   /* rounds in encryption for aes256 */
+	AES128_KEY_LENGTH       = 128 / 8,
+	AES192_KEY_LENGTH       = 192 / 8,
+	AES256_KEY_LENGTH       = 256 / 8,
+	AES128_EXPAND_KEY_LENGTH = 4 * AES_STATECOLS * (AES128_ROUNDS + 1),
+	AES192_EXPAND_KEY_LENGTH = 4 * AES_STATECOLS * (AES192_ROUNDS + 1),
+	AES256_EXPAND_KEY_LENGTH = 4 * AES_STATECOLS * (AES256_ROUNDS + 1),
+	AES_BLOCK_LENGTH        = 128 / 8,
 };
 
 /**
@@ -39,30 +47,32 @@
  * @key		Key, of length AES_KEY_LENGTH bytes
  * @expkey	Buffer to place expanded key, AES_EXPAND_KEY_LENGTH
  */
-void aes_expand_key(u8 *key, u8 *expkey);
+void aes_expand_key(u8 *key, u32 key_size, u8 *expkey);
 
 /**
  * aes_encrypt() - Encrypt single block of data with AES 128
  *
+ * @key_size   Size of the aes key (in bits)
  * @in		Input data
  * @expkey	Expanded key to use for encryption (from aes_expand_key())
  * @out		Output data
  */
-void aes_encrypt(u8 *in, u8 *expkey, u8 *out);
+void aes_encrypt(u32 key_size, u8 *in, u8 *expkey, u8 *out);
 
 /**
  * aes_decrypt() - Decrypt single block of data with AES 128
  *
+ * @key_size   Size of the aes key (in bits)
  * @in		Input data
  * @expkey	Expanded key to use for decryption (from aes_expand_key())
  * @out		Output data
  */
-void aes_decrypt(u8 *in, u8 *expkey, u8 *out);
+void aes_decrypt(u32 key_size, u8 *in, u8 *expkey, u8 *out);
 
 /**
  * Apply chain data to the destination using EOR
  *
- * Each array is of length AES_KEY_LENGTH.
+ * Each array is of length AES_BLOCK_LENGTH.
  *
  * @cbc_chain_data	Chain data
  * @src			Source data
@@ -73,25 +83,27 @@
 /**
  * aes_cbc_encrypt_blocks() - Encrypt multiple blocks of data with AES CBC.
  *
+ * @key_size    Size of the aes key (in bits)
  * @key_exp		Expanded key to use
  * @iv			Initialization vector
  * @src			Source data to encrypt
  * @dst			Destination buffer
  * @num_aes_blocks	Number of AES blocks to encrypt
  */
-void aes_cbc_encrypt_blocks(u8 *key_exp, u8 *iv, u8 *src, u8 *dst,
+void aes_cbc_encrypt_blocks(u32 key_size, u8 *key_exp, u8 *iv, u8 *src, u8 *dst,
 			    u32 num_aes_blocks);
 
 /**
  * Decrypt multiple blocks of data with AES CBC.
  *
+ * @key_size    Size of the aes key (in bits)
  * @key_exp		Expanded key to use
  * @iv			Initialization vector
  * @src			Source data to decrypt
  * @dst			Destination buffer
  * @num_aes_blocks	Number of AES blocks to decrypt
  */
-void aes_cbc_decrypt_blocks(u8 *key_exp, u8 *iv, u8 *src, u8 *dst,
+void aes_cbc_decrypt_blocks(u32 key_size, u8 *key_exp, u8 *iv, u8 *src, u8 *dst,
 			    u32 num_aes_blocks);
 
 #endif /* _AES_REF_H_ */
diff -Naur uboot_old/lib/aes.c uboot/lib/aes.c
--- uboot_old/lib/aes.c	2020-11-20 17:00:27.000000000 +0800
+++ uboot/lib/aes.c	2021-01-12 18:32:13.529276511 +0800
@@ -508,50 +508,79 @@
 	0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
 };
 
+static u32 aes_get_rounds(u32 key_len)
+{
+   u32 rounds = AES128_ROUNDS;
+
+   if (key_len == AES192_KEY_LENGTH)
+           rounds = AES192_ROUNDS;
+   else if (key_len == AES256_KEY_LENGTH)
+           rounds = AES256_ROUNDS;
+
+   return rounds;
+}
+
+static u32 aes_get_keycols(u32 key_len)
+{
+   u32 keycols = AES128_KEYCOLS;
+
+   if (key_len == AES192_KEY_LENGTH)
+           keycols = AES192_KEYCOLS;
+   else if (key_len == AES256_KEY_LENGTH)
+           keycols = AES256_KEYCOLS;
+
+   return keycols;
+}
+
 /* produce AES_STATECOLS bytes for each round */
-void aes_expand_key(u8 *key, u8 *expkey)
+void aes_expand_key(u8 *key, u32 key_len, u8 *expkey)
 {
 	u8 tmp0, tmp1, tmp2, tmp3, tmp4;
-	u32 idx;
+	u32 idx, aes_rounds, aes_keycols;
+
+	aes_rounds = aes_get_rounds(key_len);
+	aes_keycols = aes_get_keycols(key_len);
 
-	memcpy(expkey, key, AES_KEYCOLS * 4);
+	memcpy(expkey, key, key_len);
 
-	for (idx = AES_KEYCOLS; idx < AES_STATECOLS * (AES_ROUNDS + 1); idx++) {
+	for (idx = aes_keycols; idx < AES_STATECOLS * (aes_rounds + 1); idx++) {
 		tmp0 = expkey[4*idx - 4];
 		tmp1 = expkey[4*idx - 3];
 		tmp2 = expkey[4*idx - 2];
 		tmp3 = expkey[4*idx - 1];
-		if (!(idx % AES_KEYCOLS)) {
+		if (!(idx % aes_keycols)) {
 			tmp4 = tmp3;
 			tmp3 = sbox[tmp0];
-			tmp0 = sbox[tmp1] ^ rcon[idx / AES_KEYCOLS];
+			tmp0 = sbox[tmp1] ^ rcon[idx / aes_keycols];
 			tmp1 = sbox[tmp2];
 			tmp2 = sbox[tmp4];
-		} else if ((AES_KEYCOLS > 6) && (idx % AES_KEYCOLS == 4)) {
+		} else if ((aes_keycols > 6) && (idx % aes_keycols == 4)) {
 			tmp0 = sbox[tmp0];
 			tmp1 = sbox[tmp1];
 			tmp2 = sbox[tmp2];
 			tmp3 = sbox[tmp3];
 		}
 
-		expkey[4*idx+0] = expkey[4*idx - 4*AES_KEYCOLS + 0] ^ tmp0;
-		expkey[4*idx+1] = expkey[4*idx - 4*AES_KEYCOLS + 1] ^ tmp1;
-		expkey[4*idx+2] = expkey[4*idx - 4*AES_KEYCOLS + 2] ^ tmp2;
-		expkey[4*idx+3] = expkey[4*idx - 4*AES_KEYCOLS + 3] ^ tmp3;
+			expkey[4*idx+0] = expkey[4*idx - 4*aes_keycols + 0] ^ tmp0;
+			expkey[4*idx+1] = expkey[4*idx - 4*aes_keycols + 1] ^ tmp1;
+			expkey[4*idx+2] = expkey[4*idx - 4*aes_keycols + 2] ^ tmp2;
+			expkey[4*idx+3] = expkey[4*idx - 4*aes_keycols + 3] ^ tmp3;
 	}
 }
 
 /* encrypt one 128 bit block */
-void aes_encrypt(u8 *in, u8 *expkey, u8 *out)
+void aes_encrypt(u32 key_len, u8 *in, u8 *expkey, u8 *out)
 {
 	u8 state[AES_STATECOLS * 4];
-	u32 round;
+	u32 round, aes_rounds;
+
+	aes_rounds = aes_get_rounds(key_len);
 
 	memcpy(state, in, AES_STATECOLS * 4);
 	add_round_key((u32 *)state, (u32 *)expkey);
 
-	for (round = 1; round < AES_ROUNDS + 1; round++) {
-		if (round < AES_ROUNDS)
+	for (round = 1; round < aes_rounds + 1; round++) {
+		if (round < aes_rounds)
 			mix_sub_columns(state);
 		else
 			shift_rows(state);
@@ -563,18 +592,20 @@
 	memcpy(out, state, sizeof(state));
 }
 
-void aes_decrypt(u8 *in, u8 *expkey, u8 *out)
+void aes_decrypt(u32 key_len, u8 *in, u8 *expkey, u8 *out)
 {
 	u8 state[AES_STATECOLS * 4];
-	int round;
+	int round, aes_rounds;
 
+	aes_rounds = aes_get_rounds(key_len);
+	
 	memcpy(state, in, sizeof(state));
 
 	add_round_key((u32 *)state,
-		      (u32 *)expkey + AES_ROUNDS * AES_STATECOLS);
+		      (u32 *)expkey + aes_rounds * AES_STATECOLS);
 	inv_shift_rows(state);
 
-	for (round = AES_ROUNDS; round--; ) {
+	for (round = aes_rounds; round--; ) {
 		add_round_key((u32 *)state,
 			      (u32 *)expkey + round * AES_STATECOLS);
 		if (round)
@@ -596,62 +627,62 @@
 {
 	int i;
 
-	for (i = 0; i < AES_KEY_LENGTH; i++)
+	for (i = 0; i < AES_BLOCK_LENGTH; i++)
 		*dst++ = *src++ ^ *cbc_chain_data++;
 }
 
-void aes_cbc_encrypt_blocks(u8 *key_exp, u8 *iv, u8 *src, u8 *dst,
+void aes_cbc_encrypt_blocks(u32 key_len, u8 *key_exp, u8 *iv, u8 *src, u8 *dst,
 			    u32 num_aes_blocks)
 {
-	u8 tmp_data[AES_KEY_LENGTH];
+	u8 tmp_data[AES_BLOCK_LENGTH];
 	u8 *cbc_chain_data = iv;
 	u32 i;
 
 	for (i = 0; i < num_aes_blocks; i++) {
 		debug("encrypt_object: block %d of %d\n", i, num_aes_blocks);
-		debug_print_vector("AES Src", AES_KEY_LENGTH, src);
+		debug_print_vector("AES Src", AES_BLOCK_LENGTH, src);
 
 		/* Apply the chain data */
 		aes_apply_cbc_chain_data(cbc_chain_data, src, tmp_data);
-		debug_print_vector("AES Xor", AES_KEY_LENGTH, tmp_data);
+		debug_print_vector("AES Xor", AES_BLOCK_LENGTH, tmp_data);
 
 		/* Encrypt the AES block */
-		aes_encrypt(tmp_data, key_exp, dst);
-		debug_print_vector("AES Dst", AES_KEY_LENGTH, dst);
+		aes_encrypt(key_len, tmp_data, key_exp, dst);
+		debug_print_vector("AES Dst", AES_BLOCK_LENGTH, dst);
 
 		/* Update pointers for next loop. */
 		cbc_chain_data = dst;
-		src += AES_KEY_LENGTH;
-		dst += AES_KEY_LENGTH;
+		src += AES_BLOCK_LENGTH;
+		dst += AES_BLOCK_LENGTH;
 	}
 }
 
-void aes_cbc_decrypt_blocks(u8 *key_exp, u8 *iv, u8 *src, u8 *dst,
+void aes_cbc_decrypt_blocks(u32 key_len, u8 *key_exp, u8 *iv, u8 *src, u8 *dst,
 			    u32 num_aes_blocks)
 {
-	u8 tmp_data[AES_KEY_LENGTH], tmp_block[AES_KEY_LENGTH];
+	u8 tmp_data[AES_BLOCK_LENGTH], tmp_block[AES_BLOCK_LENGTH];
 	/* Convenient array of 0's for IV */
-	u8 cbc_chain_data[AES_KEY_LENGTH];
+	u8 cbc_chain_data[AES_BLOCK_LENGTH];
 	u32 i;
 
-	memcpy(cbc_chain_data, iv, AES_KEY_LENGTH);
+	memcpy(cbc_chain_data, iv, AES_BLOCK_LENGTH);
 	for (i = 0; i < num_aes_blocks; i++) {
 		debug("encrypt_object: block %d of %d\n", i, num_aes_blocks);
-		debug_print_vector("AES Src", AES_KEY_LENGTH, src);
+		debug_print_vector("AES Src", AES_BLOCK_LENGTH, src);
 
-		memcpy(tmp_block, src, AES_KEY_LENGTH);
+		memcpy(tmp_block, src, AES_BLOCK_LENGTH);
 
 		/* Decrypt the AES block */
-		aes_decrypt(src, key_exp, tmp_data);
-		debug_print_vector("AES Xor", AES_KEY_LENGTH, tmp_data);
+		aes_decrypt(key_len, src, key_exp, tmp_data);
+		debug_print_vector("AES Xor", AES_BLOCK_LENGTH, tmp_data);
 
 		/* Apply the chain data */
 		aes_apply_cbc_chain_data(cbc_chain_data, tmp_data, dst);
-		debug_print_vector("AES Dst", AES_KEY_LENGTH, dst);
+		debug_print_vector("AES Dst", AES_BLOCK_LENGTH, dst);
 
 		/* Update pointers for next loop. */
-		memcpy(cbc_chain_data, tmp_block, AES_KEY_LENGTH);
-		src += AES_KEY_LENGTH;
-		dst += AES_KEY_LENGTH;
+		memcpy(cbc_chain_data, tmp_block, AES_BLOCK_LENGTH);
+		src += AES_BLOCK_LENGTH;
+		dst += AES_BLOCK_LENGTH;
 	}
 }
diff -Naur uboot_old/lib/rsa/rsa-mod-exp.c uboot/lib/rsa/rsa-mod-exp.c
--- uboot_old/lib/rsa/rsa-mod-exp.c	2020-11-20 17:00:27.000000000 +0800
+++ uboot/lib/rsa/rsa-mod-exp.c	2021-01-19 17:48:15.301333786 +0800
@@ -24,9 +24,44 @@
 #define get_unaligned_be32(a) fdt32_to_cpu(*(uint32_t *)a)
 #define put_unaligned_be32(a, b) (*(uint32_t *)(b) = cpu_to_fdt32(a))
 
+#define RSA2048_BYTES	(2048 / 8)
+
 /* Default public exponent for backward compatibility */
 #define RSA_DEFAULT_PUBEXP	65537
 
+
+static const uint8_t padding_sha256_rsa2048[RSA2048_BYTES - SHA256_SUM_LEN] = {
+        0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        0xff, 0xff, 0xff, 0xff, 0x00, 0x30, 0x31, 0x30,
+        0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,
+        0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20
+};
+
+
 /**
  * subtract_modulus() - subtract modulus from the given value
  *
@@ -129,6 +164,7 @@
  * @key:	RSA key
  * @num_bits:	Storage for the number of public exponent bits
  */
+ /*
 static int num_public_exponent_bits(const struct rsa_public_key *key,
 		int *num_bits)
 {
@@ -151,7 +187,7 @@
 		}
 
 	return -EINVAL;
-}
+}*/
 
 /**
  * is_public_exponent_bit_set() - Check if a bit in the public exponent is set
@@ -159,11 +195,12 @@
  * @key:	RSA key
  * @pos:	The bit position to check
  */
+ /*
 static int is_public_exponent_bit_set(const struct rsa_public_key *key,
 		int pos)
 {
 	return key->exponent & (1ULL << pos);
-}
+}*/
 
 /**
  * pow_mod() - in-place public exponentiation
@@ -175,7 +212,6 @@
 {
 	uint32_t *result, *ptr;
 	uint i;
-	int j, k;
 
 	/* Sanity check for stack size - key->len is in 32-bit words */
 	if (key->len > RSA_MAX_KEY_BITS / 32) {
@@ -185,48 +221,18 @@
 	}
 
 	uint32_t val[key->len], acc[key->len], tmp[key->len];
-	uint32_t a_scaled[key->len];
 	result = tmp;  /* Re-use location. */
 
 	/* Convert from big endian byte array to little endian word array. */
 	for (i = 0, ptr = inout + key->len - 1; i < key->len; i++, ptr--)
 		val[i] = get_unaligned_be32(ptr);
 
-	if (0 != num_public_exponent_bits(key, &k))
-		return -EINVAL;
-
-	if (k < 2) {
-		debug("Public exponent is too short (%d bits, minimum 2)\n",
-		      k);
-		return -EINVAL;
-	}
-
-	if (!is_public_exponent_bit_set(key, 0)) {
-		debug("LSB of RSA public exponent must be set.\n");
-		return -EINVAL;
+	montgomery_mul(key, acc, val, key->rr);  /* axx = a * RR / R mod M */
+	for (i = 0; i < 16; i += 2) {
+		montgomery_mul(key, tmp, acc, acc); /* tmp = acc^2 / R mod M */
+		montgomery_mul(key, acc, tmp, tmp); /* acc = tmp^2 / R mod M */
 	}
-
-	/* the bit at e[k-1] is 1 by definition, so start with: C := M */
-	montgomery_mul(key, acc, val, key->rr); /* acc = a * RR / R mod n */
-	/* retain scaled version for intermediate use */
-	memcpy(a_scaled, acc, key->len * sizeof(a_scaled[0]));
-
-	for (j = k - 2; j > 0; --j) {
-		montgomery_mul(key, tmp, acc, acc); /* tmp = acc^2 / R mod n */
-
-		if (is_public_exponent_bit_set(key, j)) {
-			/* acc = tmp * val / R mod n */
-			montgomery_mul(key, acc, tmp, a_scaled);
-		} else {
-			/* e[j] == 0, copy tmp back to acc for next operation */
-			memcpy(acc, tmp, key->len * sizeof(acc[0]));
-		}
-	}
-
-	/* the bit at e[0] is always 1 */
-	montgomery_mul(key, tmp, acc, acc); /* tmp = acc^2 / R mod n */
-	montgomery_mul(key, acc, tmp, val); /* acc = tmp * a / R mod M */
-	memcpy(result, acc, key->len * sizeof(result[0]));
+	montgomery_mul(key, result, acc, val);  /* result = XX * a / R mod M */
 
 	/* Make sure result < mod; result is at most 1x mod too large. */
 	if (greater_equal_modulus(key, result))
@@ -235,6 +241,7 @@
 	/* Convert to bigendian byte array */
 	for (i = key->len - 1, ptr = inout; (int)i >= 0; i--, ptr++)
 		put_unaligned_be32(result[i], ptr);
+
 	return 0;
 }
 
@@ -301,6 +308,114 @@
 	return 0;
 }
 
+static int read_prop(const char *key_val, int offset, int size){
+        int t=0;
+        int val = 0;
+        int tmp =0;
+        int count = size;
+        for(t = size+offset-1; t >= offset; t--){
+                tmp = key_val[t];
+                val = val + (tmp << ((--count)*8));
+        }
+        return val;
+}
+
+static int rsa_verify_key_SHA256(const struct rsa_public_key *key, const uint8_t *sig,
+                                                 const uint32_t sig_len, const uint8_t *hash, const uint32_t hash_len)
+{
+        const uint8_t *padding;
+        int pad_len;
+        int ret;
+        if (!key || !sig || !hash)
+                return -EIO;
+
+        if (sig_len != (key->len * sizeof(uint32_t))) {
+                printf("Signature is of incorrect length %d\n", sig_len);
+                return -EINVAL;
+        }
+
+        /* Sanity check for stack size */
+        if (sig_len > RSA_MAX_SIG_BITS / 8) {
+                printf("Signature length %u exceeds maximum %d\n", sig_len,
+                      RSA_MAX_SIG_BITS / 8);
+                return -EINVAL;
+        }
+
+        uint32_t buf[sig_len / sizeof(uint32_t)];
+
+        memcpy(buf, sig, sig_len);
+
+        ret = pow_mod(key, buf);
+        if (ret){
+                printf("error in pow_mod in rsa_verify_key\n");
+                return ret;
+        }
+        
+        padding = padding_sha256_rsa2048;
+        pad_len = RSA2048_BYTES - SHA256_SUM_LEN;
+
+        /* Check pkcs1.5 padding bytes. */
+        if (memcmp(buf, padding, pad_len)) {
+                printf("In RSAVerify(): Padding check failed!\n");
+              return -EINVAL;
+        }
+
+        /* Check hash. */
+        if (memcmp((uint8_t *)buf + pad_len, hash, sig_len - pad_len)) {
+                printf("In RSAVerify(): Hash check failed!\n");
+                return -EACCES;
+        }
+        return 0;
+}
+
+int rsa_get_pub_key_uboot_verify(const char *key_val, unsigned char *enc_hash,
+                                                  unsigned int enc_hash_len, unsigned char *hash, unsigned int hash_len)
+{
+        struct rsa_public_key key;
+        const void *modulus, *rr;
+        uint32_t hash_copy[16]={0};  
+        int ret, p;
+        
+        key.len = read_prop(key_val, 256, 2);
+        key.n0inv = read_prop(key_val, 100, 4);
+        modulus = &key_val[512]; 
+        rr = &key_val[1024]; 
+
+        /* Sanity check for stack size */
+        if (key.len > RSA_MAX_KEY_BITS || key.len < RSA_MIN_KEY_BITS) {
+                debug("RSA key bits %u outside allowed range %d..%d\n",
+                      key.len, RSA_MIN_KEY_BITS, RSA_MAX_KEY_BITS);
+                return -EFAULT;
+        }
+
+        key.len /= sizeof(uint32_t) * 8;
+        uint32_t key1[key.len], key2[key.len];
+        key.modulus = key1;
+        key.rr = key2;
+        rsa_convert_big_endian(key.modulus, modulus, key.len);
+        rsa_convert_big_endian(key.rr, rr, key.len);
+
+        if (!key.modulus || !key.rr) {
+                debug("%s: Out of memory", __func__);
+                return -ENOMEM;
+        }
+
+        debug("key length %d\n", key.len);
+
+        for(p=0; p < hash_len/sizeof(uint32_t); p++)
+        {
+                hash_copy[p] = *(((uint32_t *)(hash))+p);
+        }
+
+        ret = rsa_verify_key_SHA256(&key, enc_hash, enc_hash_len, (uint8_t *)(hash_copy), hash_len);
+
+        if (ret) {
+                printf("%s: RSA failed to verify: %d\n", __func__, ret);
+                return ret;
+        }
+        return 0;
+}
+
 #if defined(CONFIG_CMD_ZYNQ_RSA)
 /**
  * zynq_pow_mod - in-place public exponentiation
diff -Naur uboot_old/oem/ami/fmh/cmd_fmh.c uboot/oem/ami/fmh/cmd_fmh.c
--- uboot_old/oem/ami/fmh/cmd_fmh.c	2021-02-01 16:11:13.286416772 +0800
+++ uboot/oem/ami/fmh/cmd_fmh.c	2021-02-02 16:53:46.115479747 +0800
@@ -32,6 +32,13 @@
 # define  KERNEL_LOADADDR	0xC00000
 # define  KERNEL_FILE		"/boot/uImage"
 
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT
+# define UIMAGE_LOADADDR	(ASPEED_DRAM_BASE + 0x8000 )
+# define DTB_LOADADDR		(ASPEED_DRAM_BASE + 0x1000000 )
+# define INITRD_LOADADDR	(ASPEED_DRAM_BASE + 0x2000000 )
+# define SECURE_KEY_LOADADDR	(ASPEED_SRAM_BASE + 0xec00 ) 
+# define SECURE_IV_LOADADDR		(ASPEED_SRAM_BASE + 0xee00 ) 
+#endif
 
 # define AUTO_HIGH_VER_FW          	0x0
 # define IMAGE_1                   	0x1
@@ -1123,11 +1130,21 @@
     char goldenside[16];
 	char INITRDAddrStr[128] = "0xFFFFFFFF";
 	char dtsaddrstr[128] = "0xFFFFFFFF";
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT	
+	char lenStr[128] = "0xFFFFFFFF";
+	char INITRDLenStr[128] = "0xFFFFFFFF";
+	char dtsLenrstr[128] = "0xFFFFFFFF";	
+	char aesCMD[5][128] = {"aes.256","dec","0xFFFFFFFF","0xFFFFFFFF","0xFFFFFFFF"};
+#endif		
 	char baudrate_str[16] = {0};
 	unsigned char mod_Name[9]={0};
 	char FSName[16] = {0};  /* Hope no filesystem name is bigger then 15 char long */
 	u8 imagetoboot = IMAGE_1; /* By default will boot image-1 */
-	char *argv[6];
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT		
+	char *argv[7];
+#else
+	char *argv[6];	
+#endif	
 	char *s = NULL;
 	//flash_info_t *flinfo = NULL;
 	FMH	*fmh = NULL;
@@ -1138,6 +1155,11 @@
 	long SkipSize;
 	unsigned long ExecuteAddr = 0xFFFFFFFF;
 	unsigned long dtsaddr = 0xFFFFFFFF;
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT		
+	unsigned long dtslen = 0xFFFFFFFF;
+	unsigned long initrdlen = 0xFFFFFFFF;
+	unsigned long len = 0xFFFFFFFF;
+#endif	
 	unsigned short ExecuteType = MODULE_BOOTLOADER;
 	unsigned short Compression;
 	int retval = -1;
@@ -1353,10 +1375,20 @@
 					printf("Found Root File System @ /dev/mtdblock%d\n",RootMtdNo);
 				}
 				else
-				{
-					if ((fmh->FMH_Ver_Major == 1) && (fmh->FMH_Ver_Minor >= 8))
-						initrd_address = startaddress + le32_to_host(mod->Module_Location);
-					printf("Found INITRD Image for Root File System @ /dev/mtdblock%d flash address %lx\n",RootMtdNo,initrd_address);
+				{				
+					if ((fmh->FMH_Ver_Major == 1) && (fmh->FMH_Ver_Minor >= 8)){
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT		
+						if ( initrd_address == 0xFFFFFFFF){
+							initrdlen = le32_to_host(mod->Module_Size);
+							initrd_address = startaddress + le32_to_host(mod->Module_Location);
+							printf("Found INITRD Image for Root File System @ /dev/mtdblock%d flash address %lx\n",RootMtdNo,initrd_address);								
+						}
+#else
+						initrd_address = startaddress + le32_to_host(mod->Module_Location);						
+						printf("Found INITRD Image for Root File System @ /dev/mtdblock%d flash address %lx\n",RootMtdNo,initrd_address);								
+#endif						
+					}
+
 				}
 
  				switch (le16_to_host(mod->Module_Type))
@@ -1383,7 +1415,17 @@
                 		strncpy(FSName,"",15);
        	 		}
 			}
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT										
+			if (strncasecmp((char *)mod->Module_Name,"INITRD",8) == 0)
+			{
+				rootisinitrd = 1; //encrypt mode of secure boot should has initrd to luanch root					
+				RootMtdNo = MtdPartition;	
+				initrd_address =  le32_to_host(mod->Module_Location);
+				initrdlen = le32_to_host(mod->Module_Size);			
+				printf("Found Encrypt INITRD Image for Root File System @ /dev/mtdblock%d flash address %lx size %lx\n",RootMtdNo,initrd_address,initrdlen);
 
+			}
+#endif	
 			if ((fmh->FMH_Ver_Major == 1) && (fmh->FMH_Ver_Minor >= 8))
 				printf("%s @ /dev/mtdblock%d Address %lx\n",mod_Name, MtdPartition, startaddress + le32_to_host(mod->Module_Location));
 
@@ -1393,6 +1435,9 @@
 		if (le16_to_host(mod->Module_Type) == MODULE_FPGA)
 		{
 			dtsaddr = startaddress + le32_to_host(mod->Module_Location);
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT				
+			dtslen = le32_to_host(mod->Module_Size);
+#endif			
 		}
 
 
@@ -1427,9 +1472,23 @@
 					if(rootisinitrd == 1)
 					{
 						initrd_address =  le32_to_host(mod->Module_Load_Address);
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT						
+						initrdlen = le32_to_host(mod->Module_Size);
+#endif						
 						printf("INITRD Image moved to 0x%lx\n",initrd_address);
 					}
 				}
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT										
+				if (strncasecmp((char *)mod->Module_Name,"INITRD",8) == 0)
+				{
+					if(rootisinitrd == 1)
+					{
+						initrd_address =  le32_to_host(mod->Module_Load_Address);
+						initrdlen = le32_to_host(mod->Module_Size);			
+						printf("Encrypt INITRD Image moved to 0x%lx\n",initrd_address);
+					}
+				}
+#endif							
 			}
 			else
 			{
@@ -1444,14 +1503,22 @@
 						&& 	(ExecuteAddr == 0xFFFFFFFF))
 		{
 			ExecuteType =le16_to_host(mod->Module_Type);
-			if (le16_to_host(mod->Module_Flags) & MODULE_FLAG_COPY_TO_RAM)
+			if (le16_to_host(mod->Module_Flags) & MODULE_FLAG_COPY_TO_RAM){
 				ExecuteAddr =le32_to_host(mod->Module_Load_Address);
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT				
+				len = le32_to_host(mod->Module_Size);
+#endif				
+			}
 			else
 			{
 				if (Compression == MODULE_COMPRESSION_NONE)
 				{
-					if ((fmh->FMH_Ver_Major == 1) && (fmh->FMH_Ver_Minor >= 8))
+					if ((fmh->FMH_Ver_Major == 1) && (fmh->FMH_Ver_Minor >= 8)){
 						ExecuteAddr = startaddress + le32_to_host(mod->Module_Location);
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT						
+						len = le32_to_host(mod->Module_Size);
+#endif						
+					}
 				}
 				else
 					printf("ERROR: Compressed Module cannot be XIP\n");
@@ -1609,9 +1676,57 @@
 		}
 		else
 		{
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT	
+			sprintf(&aesCMD[2][0],"0x%x",SECURE_KEY_LOADADDR);
+			sprintf(&aesCMD[3][0],"0x%x",SECURE_IV_LOADADDR);			
+
+			printf("Decrypt DTS to 0x%x ...",DTB_LOADADDR);
+			sprintf(&aesCMD[4][0],"0x%x",DTB_LOADADDR);
+			sprintf(dtsaddrstr,"0x%lx",dtsaddr);
+			sprintf(dtsLenrstr,"0x%lx",dtslen);
+			argv[0] = &aesCMD[0][0];
+			argv[1] = &aesCMD[1][0];
+			argv[2] = &aesCMD[2][0];
+			argv[3] = &aesCMD[3][0];
+			argv[4] = &dtsaddrstr[0];
+			argv[5] = &aesCMD[4][0];
+			argv[6] = &dtsLenrstr[0];
+			retval =  do_aes(NULL,0,7,argv);
+			if(retval == 0) { printf("Success\n"); }  else { printf("Failed\n"); return retval;}
+			printf("Decrypt Kernel to 0x%x ...",UIMAGE_LOADADDR);
+			sprintf(&aesCMD[4][0],"0x%x",UIMAGE_LOADADDR);
 			sprintf(AddrStr,"0x%lx",ExecuteAddr);
+			sprintf(lenStr,"0x%lx",len);
+			argv[0] = &aesCMD[0][0];
+			argv[1] = &aesCMD[1][0];
+			argv[2] = &aesCMD[2][0];
+			argv[3] = &aesCMD[3][0];
+			argv[4] = &AddrStr[0];
+			argv[5] = &aesCMD[4][0];
+			argv[6] = &lenStr[0];
+			retval =  do_aes(NULL,0,7,argv);			
+			if(retval == 0) { printf("Success\n"); }  else { printf("Failed\n"); return retval;}
+			printf("Decrypt InitRD to 0x%x ...",INITRD_LOADADDR);
+			sprintf(&aesCMD[4][0],"0x%x",INITRD_LOADADDR);
 			sprintf(INITRDAddrStr,"0x%lx",initrd_address);
-			sprintf(dtsaddrstr,"0x%lx",dtsaddr);
+			sprintf(INITRDLenStr,"0x%lx",initrdlen);
+			argv[0] = &aesCMD[0][0];
+			argv[1] = &aesCMD[1][0];
+			argv[2] = &aesCMD[2][0];
+			argv[3] = &aesCMD[3][0];
+			argv[4] = &INITRDAddrStr[0];
+			argv[5] = &aesCMD[4][0];
+			argv[6] = &INITRDLenStr[0];
+			retval =  do_aes(NULL,0,7,argv);
+			if(retval == 0) { printf("Success\n"); }  else { printf("Failed\n"); return retval;}
+			sprintf(AddrStr,"0x%x",UIMAGE_LOADADDR);
+			sprintf(INITRDAddrStr,"0x%x",INITRD_LOADADDR);
+			sprintf(dtsaddrstr,"0x%x",DTB_LOADADDR);			
+#else
+			sprintf(AddrStr,"0x%lx",ExecuteAddr);
+			sprintf(INITRDAddrStr,"0x%lx",initrd_address);
+			sprintf(dtsaddrstr,"0x%lx",dtsaddr);			
+#endif		
 			argv[0] = &Command[0];
 			argv[1] = &AddrStr[0];
 			argv[2] = &INITRDAddrStr[0];
diff -Naur uboot_old/oem/ami/fmh/cmd_fmh.h uboot/oem/ami/fmh/cmd_fmh.h
--- uboot_old/oem/ami/fmh/cmd_fmh.h	2021-02-01 16:11:13.110425101 +0800
+++ uboot/oem/ami/fmh/cmd_fmh.h	2021-01-12 18:32:13.573274741 +0800
@@ -9,7 +9,9 @@
 /* U-boot's cmd function to list and bootFMH */
 extern int  do_fmh(cmd_tbl_t *, int, int, char * const []);
 extern int  do_bootfmh(cmd_tbl_t *, int, int, char * const []);
-
+#ifdef CONFIG_SPX_FEATURE_SECURE_BOOT_ENCRYPTION_SUPPORT
+extern int  do_aes(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+#endif
 /* Actual function implementing listing of FMH*/
 extern int  ListFMH(void);	
 extern int  GetFMHSectorLocationSize(char * Name, unsigned long * Location, unsigned long * Size);
diff -Naur uboot_old/oem/ami/fmh/hrotcore.c uboot/oem/ami/fmh/hrotcore.c
--- uboot_old/oem/ami/fmh/hrotcore.c	1970-01-01 08:00:00.000000000 +0800
+++ uboot/oem/ami/fmh/hrotcore.c	2021-01-12 18:32:13.573274741 +0800
@@ -0,0 +1,196 @@
+# include <common.h>
+# include <config.h>
+# include <command.h>
+# include <flash.h>
+# include "cmd.h"
+# include <oem/ami/fmh/fmh.h>
+# include "hrot_ifc.h"
+#include "u-boot/sha256.h"
+#include "u-boot/rsa.h"
+
+#ifdef CONFIG_SPX_FEATURE_UBOOT_VALIDATE_SUPPORT
+	#define UBOOT_VALIDATE		1
+#else
+	#define UBOOT_VALIDATE          0
+#endif
+#define PROD_SIG_OFFSET		4096
+#define SIG_OFFSET		4088
+#define SIZE_OF_UBOOT_FMH	256
+#define SIGNATURE_LENGTH	256
+#define KEY_INFO_LENGTH		4096
+#define HASH_BLK_SIZE           262144
+
+static sha256_context ctx;
+static UINT32 boot_fmh_location,product_info_offset=0;
+static char placeToHash[HASH_BLK_SIZE];
+
+void
+hrot_start(){
+	sha256_starts(&ctx);
+	return;
+}
+
+int
+hrot_update(unsigned short ModType, void *ModName, UINT32 location, UINT32 AllocSize, UINT32 fmhLocation, unsigned long startaddress){
+
+	int hs_size=HASH_BLK_SIZE;
+	UINT32 stopHash;
+        unsigned char *hash_data;
+        int rc = 0;
+	UINT32 hash_start, size_to_hash;
+	struct spi_flash *flash;
+
+	if((ModType == MODULE_BOOTLOADER) && (strncmp((char *)ModName,"boot",sizeof("boot")) == 0)){
+		boot_fmh_location = fmhLocation;
+	}
+	flash = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+                        CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+    if (flash == NULL) 
+    {
+        puts("\nspi_flash_probe failed");
+        hang();
+    }
+
+	if((ModType != MODULE_JFFS2 && ModType != MODULE_BOOTLOADER) || (UBOOT_VALIDATE && ModType == MODULE_BOOTLOADER)){
+
+		if(ModType != MODULE_BOOTLOADER && ModType != MODULE_FMH_FIRMWARE){
+                        hash_start = startaddress + fmhLocation;
+                        size_to_hash = AllocSize;
+                }
+                else if(ModType == MODULE_FMH_FIRMWARE){
+                        hash_start = startaddress + fmhLocation;
+                        size_to_hash = AllocSize - (3*PROD_SIG_OFFSET+1024);
+			product_info_offset=startaddress + fmhLocation +AllocSize;
+                }
+                else{
+                        hash_start = startaddress + location;
+                	size_to_hash = fmhLocation + SIZE_OF_UBOOT_FMH - PROD_SIG_OFFSET;
+                }
+
+		stopHash = (size_to_hash+hash_start);
+                while(hash_start < stopHash)
+                {
+                        if((hash_start+hs_size) > stopHash && hash_start < stopHash){
+                                hs_size = stopHash - hash_start;
+                        }
+
+						spi_flash_read(flash,hash_start, hs_size, placeToHash);
+                        hash_data = (rc == ERR_OK) ? (unsigned char*)placeToHash : NULL;
+
+                        if(hash_data == NULL){
+                                printf("ERROR setting hash data!\n");
+                                return 1;
+                        }
+						
+						if ((ModType == MODULE_FMH_FIRMWARE) && (hash_start == (startaddress + fmhLocation)))
+						{
+							// Start with FmhLocation + 0x17 offset exclude 1 Byte FMH_Header_Checksum
+							memset(&hash_data[23], 0, 1);
+							// Start with FmhLocation + 0x32 offset exclude 4 Byte Module_Checksum
+							memset(&hash_data[50], 0, 4);
+						}
+
+                        sha256_update(&ctx, hash_data, hs_size);
+                        hash_start += hs_size;
+                }
+
+	}
+        return 0;
+}
+
+
+#define START_IDENTIFIER "$start$"
+#define FWIMG_IDENTIFIER "$fwimg$"
+#define END_IDENTIFIER   "$end$"
+
+int
+hrot_finish(unsigned long startaddress){
+        unsigned char output [65];
+        UINT32 keyInfo = startaddress + boot_fmh_location - KEY_INFO_LENGTH;
+        UINT32 sigaddr = product_info_offset  - PROD_SIG_OFFSET;
+        int rc = 0;
+        int size = 64;
+        char    linebuf[16384] = {0}, linebuf1[1024] = {0};
+        void *buf=NULL, *buf1=NULL;
+        int ret =0;
+		int sig_length;
+		char identifier[8];
+		struct spi_flash *flash;
+	
+		flash = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+							CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+		if (flash == NULL) 
+		{
+			puts("\nspi_flash_probe failed");
+			hang();
+		}
+        sha256_finish(&ctx, output);
+
+
+	   rc = spi_flash_read(flash,keyInfo, KEY_INFO_LENGTH*4, linebuf);
+        buf = (rc == ERR_OK) ? linebuf : (void*)keyInfo;
+
+        memset(identifier,0,sizeof(START_IDENTIFIER));
+        memcpy(identifier,buf,sizeof(START_IDENTIFIER));
+        identifier[7]=0;
+        if(strncmp(identifier,START_IDENTIFIER,sizeof(START_IDENTIFIER)) != 0)
+		{
+			printf("unable to find rsa public key start identifier :( \n");
+			return -1;
+		}
+		memset(identifier,0,sizeof(START_IDENTIFIER));
+		spi_flash_read(flash,sigaddr,sizeof(START_IDENTIFIER),identifier);
+		if(strncmp(identifier,START_IDENTIFIER,sizeof(START_IDENTIFIER)) != 0)
+		{
+			printf("unable to find signature start identifier :( \n");
+			return -1;
+		}
+	
+		sigaddr +=sizeof(START_IDENTIFIER);
+		/* scan through hash area and find the proper hash for firmware image*/
+		while(product_info_offset > sigaddr )
+		{
+			spi_flash_read(flash,sigaddr,sizeof(identifier),identifier);
+
+			sigaddr +=sizeof(identifier);
+				
+			if(strncmp(identifier,FWIMG_IDENTIFIER,sizeof(FWIMG_IDENTIFIER)) != 0)
+			{
+				if(strncmp(identifier,END_IDENTIFIER,strlen(END_IDENTIFIER)) != 0)
+				{
+					printf("unable to find signature for firmware image");
+					return -1;
+				}
+				spi_flash_read(flash,sigaddr,sizeof(sig_length),(char *) &sig_length);
+				sigaddr +=sizeof(sig_length)+sig_length;
+
+				continue;
+
+			}
+
+			spi_flash_read(flash,sigaddr,sizeof(sig_length),(char *) &sig_length);
+            sigaddr +=sizeof(sig_length);
+
+			rc = spi_flash_read(flash,sigaddr, sig_length, linebuf1);
+			buf1 = (rc == ERR_OK) ? linebuf1 : (void*)sigaddr;
+			break;
+
+		}
+		if(product_info_offset < sigaddr)
+		{
+			printf("signature not found :(");
+			return -1;
+		}
+
+        char *key_data = (char *)buf;
+        unsigned char *sig = (unsigned char *)buf1;
+        
+        if(0){
+                printf("%s", key_data);
+                printf("%s", sig);
+        }
+        ret = rsa_get_pub_key_uboot_verify(key_data, sig, sig_length, output, size);
+        return ret;
+}
+
+
diff -Naur uboot_old/oem/ami/fmh/hrot_ifc.h uboot/oem/ami/fmh/hrot_ifc.h
--- uboot_old/oem/ami/fmh/hrot_ifc.h	1970-01-01 08:00:00.000000000 +0800
+++ uboot/oem/ami/fmh/hrot_ifc.h	2021-01-12 18:32:13.573274741 +0800
@@ -0,0 +1,11 @@
+#ifndef __AMI_CMD_SECURE_BOOT_H__
+#define __AMI_CMD_SECURE_BOOT_H__
+
+
+typedef unsigned long   UINT32;
+void hrot_start(void);
+int hrot_update(unsigned short ModType, void *ModName, UINT32 location, UINT32 ModSize, UINT32 fmhLocation, unsigned long startaddress);
+int hrot_finish(unsigned long startaddress);
+extern int rsa_get_pub_key_uboot_verify(const char *key_val, unsigned char *enc_hash, unsigned int enc_hash_len, unsigned char *hash, unsigned int hash_len);
+
+#endif
