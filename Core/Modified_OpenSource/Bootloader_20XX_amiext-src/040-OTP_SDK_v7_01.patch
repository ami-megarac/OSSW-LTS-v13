--- uboot_org/cmd/otp.c	2021-09-08 15:15:35.757789670 +0800
+++ uboot/cmd/otp.c	2021-09-08 17:34:28.507194855 +0800
@@ -1,13 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Copyright 2021 Aspeed Technology Inc.
  */
+
 #include <stdlib.h>
 #include <common.h>
 #include <console.h>
@@ -25,7 +20,7 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#define OTP_VER				"1.0.1"
+#define OTP_VER				"1.1.0"
 
 #define OTP_PASSWD			0x349fe38a
 #define RETRY				20
@@ -58,20 +53,46 @@
 #define OTP_COMPARE_2		OTP_BASE + 0x24
 #define OTP_COMPARE_3		OTP_BASE + 0x28
 #define OTP_COMPARE_4		OTP_BASE + 0x2c
+#define SW_REV_ID0		OTP_BASE + 0x68
+#define SW_REV_ID1		OTP_BASE + 0x6c
 
 #define OTP_MAGIC		"SOCOTP"
 #define CHECKSUM_LEN		32
-#define OTP_INC_DATA		(1 << 31)
-#define OTP_INC_CONFIG		(1 << 30)
-#define OTP_INC_STRAP		(1 << 29)
-#define OTP_ECC_EN		(1 << 28)
+#define OTP_INC_DATA		BIT(31)
+#define OTP_INC_CONFIG		BIT(30)
+#define OTP_INC_STRAP		BIT(29)
+#define OTP_ECC_EN		BIT(28)
 #define OTP_REGION_SIZE(info)	((info >> 16) & 0xffff)
 #define OTP_REGION_OFFSET(info)	(info & 0xffff)
 #define OTP_IMAGE_SIZE(info)	(info & 0xffff)
 
-#define OTP_AST2600A0		0
-#define OTP_AST2600A1		1
-#define OTP_AST2600A2		2
+#define OTP_A0		0
+#define OTP_A1		1
+#define OTP_A2		2
+#define OTP_A3		3
+
+#define ID0_AST2600A0	0x05000303
+#define ID1_AST2600A0	0x05000303
+#define ID0_AST2600A1	0x05010303
+#define ID1_AST2600A1	0x05010303
+#define ID0_AST2600A2	0x05010303
+#define ID1_AST2600A2	0x05020303
+#define ID0_AST2600A3	0x05030303
+#define ID1_AST2600A3	0x05030303
+#define ID0_AST2620A1	0x05010203
+#define ID1_AST2620A1	0x05010203
+#define ID0_AST2620A2	0x05010203
+#define ID1_AST2620A2	0x05020203
+#define ID0_AST2620A3	0x05030203
+#define ID1_AST2620A3	0x05030203
+#define ID0_AST2620A3	0x05030203
+#define ID1_AST2620A3	0x05030203
+#define ID0_AST2605A2	0x05010103
+#define ID1_AST2605A2	0x05020103
+#define ID0_AST2605A3	0x05030103
+#define ID1_AST2605A3	0x05030103
+#define ID0_AST2625A3	0x05030403
+#define ID1_AST2625A3	0x05030403
 
 struct otp_header {
 	u8	otp_magic[8];
@@ -81,7 +102,7 @@
 	u32	config_info;
 	u32	strap_info;
 	u32	checksum_offset;
-} __attribute__((packed));
+} __packed;
 
 struct otpstrap_status {
 	int value;
@@ -110,27 +131,27 @@
 
 struct otp_info_cb {
 	int version;
+	char ver_name[3];
 	const struct otpstrap_info *strap_info;
 	int strap_info_len;
 	const struct otpconf_info *conf_info;
 	int conf_info_len;
 	const struct otpkey_type *key_info;
 	int key_info_len;
-
 };
 
 struct otp_image_layout {
 	int data_length;
 	int conf_length;
 	int strap_length;
-	uint8_t *data;
-	uint8_t *data_ignore;
-	uint8_t *conf;
-	uint8_t *conf_ignore;
-	uint8_t *strap;
-	uint8_t *strap_reg_pro;
-	uint8_t *strap_pro;
-	uint8_t *strap_ignore;
+	u8 *data;
+	u8 *data_ignore;
+	u8 *conf;
+	u8 *conf_ignore;
+	u8 *strap;
+	u8 *strap_reg_pro;
+	u8 *strap_pro;
+	u8 *strap_ignore;
 };
 
 static struct otp_info_cb info_cb;
@@ -154,8 +175,6 @@
 	{14, OTP_KEY_TYPE_RSA_PRIV,  0, "RSA-private as AES key decryption key"},
 };
 
-/*
- * AMI mark it, the reason is  build erro => 「a2_key_type」 defined but not used [-Werror=unused-const-variable=]
 static const struct otpkey_type a2_key_type[] = {
 	{1, OTP_KEY_TYPE_VAULT, 0, "AES-256 as secret vault key"},
 	{2, OTP_KEY_TYPE_AES,   1, "AES-256 as OEM platform key for image encryption/decryption in Mode 2 or AES-256 as OEM DSS keys for Mode GCM"},
@@ -163,7 +182,6 @@
 	{10, OTP_KEY_TYPE_RSA_PUB,  0, "RSA-public as AES key decryption key"},
 	{14, OTP_KEY_TYPE_RSA_PRIV,  0, "RSA-private as AES key decryption key"},
 };
-*/
 
 static const struct otpkey_type a3_key_type[] = {
 	{1, OTP_KEY_TYPE_VAULT, 0, "AES-256 as secret vault key"},
@@ -176,34 +194,101 @@
 	{13, OTP_KEY_TYPE_RSA_PRIV,  0, "RSA-private as AES key decryption key(big endian)"},
 };
 
-static uint32_t  chip_version(void)
+static void buf_print(u8 *buf, int len)
+{
+	int i;
+
+	printf("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n");
+	for (i = 0; i < len; i++) {
+		if (i % 16 == 0)
+			printf("%04X: ", i);
+		printf("%02X ", buf[i]);
+		if ((i + 1) % 16 == 0)
+			printf("\n");
+	}
+}
+
+static int get_dw_bit(u32 *rid, int offset)
+{
+	int bit_offset;
+	int i;
+
+	if (offset < 32) {
+		i = 0;
+		bit_offset = offset;
+	} else {
+		i = 1;
+		bit_offset = offset - 32;
+	}
+	if ((rid[i] >> bit_offset) & 0x1)
+		return 1;
+	else
+		return 0;
+}
+
+static int get_rid_num(u32 *rid)
+{
+	int i;
+	int fz = 0;
+	int rid_num = 0;
+	int ret = 0;
+
+	for (i = 0; i < 64; i++) {
+		if (get_dw_bit(rid, i) == 0) {
+			if (!fz)
+				fz = 1;
+
+		} else {
+			rid_num++;
+			if (fz)
+				ret = OTP_FAILURE;
+		}
+	}
+	if (ret)
+		return ret;
+
+	return rid_num;
+}
+
+static u32 chip_version(void)
 {
-	u64 rev_id;
+	u32 revid0, revid1;
 
-	rev_id = readl(ASPEED_REVISION_ID0);
-	rev_id = ((u64)readl(ASPEED_REVISION_ID1) << 32) | rev_id;
+	revid0 = readl(ASPEED_REVISION_ID0);
+	revid1 = readl(ASPEED_REVISION_ID1);
 
-	if (rev_id == 0x0500030305000303) {
+	if (revid0 == ID0_AST2600A0 && revid1 == ID1_AST2600A0) {
 		/* AST2600-A0 */
-		return OTP_AST2600A0;
-	} else if (rev_id == 0x0501030305010303) {
+		return OTP_A0;
+	} else if (revid0 == ID0_AST2600A1 && revid1 == ID1_AST2600A1) {
 		/* AST2600-A1 */
-		return OTP_AST2600A1;
-	} else if (rev_id == 0x0501020305010203) {
-		/* AST2620-A1 */
-		return OTP_AST2600A1;
-	} else if (rev_id == 0x0502030305010303) {
+		return OTP_A1;
+	} else if (revid0 == ID0_AST2600A2 && revid1 == ID1_AST2600A2) {
 		/* AST2600-A2 */
-		return OTP_AST2600A2;
-	} else if (rev_id == 0x0502020305010203) {
+		return OTP_A2;
+	} else if (revid0 == ID0_AST2600A3 && revid1 == ID1_AST2600A3) {
+		/* AST2600-A3 */
+		return OTP_A3;
+	} else if (revid0 == ID0_AST2620A1 && revid1 == ID1_AST2620A1) {
+		/* AST2620-A1 */
+		return OTP_A1;
+	} else if (revid0 == ID0_AST2620A2 && revid1 == ID1_AST2620A2) {
 		/* AST2620-A2 */
-		return OTP_AST2600A2;
-	} else if (rev_id == 0x0502010305010103) {
+		return OTP_A2;
+	} else if (revid0 == ID0_AST2620A3 && revid1 == ID1_AST2620A3) {
+		/* AST2620-A3 */
+		return OTP_A3;
+	} else if (revid0 == ID0_AST2605A2 && revid1 == ID1_AST2605A2) {
 		/* AST2605-A2 */
-		return OTP_AST2600A2;
+		return OTP_A2;
+	} else if (revid0 == ID0_AST2605A3 && revid1 == ID1_AST2605A3) {
+		/* AST2605-A3 */
+		return OTP_A3;
+	} else if (revid0 == ID0_AST2625A3 && revid1 == ID1_AST2625A3) {
+		/* AST2605-A3 */
+		return OTP_A3;
 	}
-
-	return -1;
+	return OTP_FAILURE;
 }
 
 static void wait_complete(void)
@@ -215,9 +300,8 @@
 	} while ((reg & 0x6) != 0x6);
 }
 
-static void otp_write(uint32_t otp_addr, uint32_t data)
+static void otp_write(u32 otp_addr, u32 data)
 {
-	otp_write(0x0, data);
 	writel(otp_addr, OTP_ADDR); //write address
 	writel(data, OTP_COMPARE_1); //write data
 	writel(0x23b1e362, OTP_COMMAND); //write command
@@ -226,7 +310,7 @@
 
 static void otp_soak(int soak)
 {
-	if (info_cb.version == OTP_AST2600A2) {
+	if (info_cb.version == OTP_A2 || info_cb.version == OTP_A3) {
 		switch (soak) {
 		case 0: //default
 			otp_write(0x3000, 0x0210); // Write MRA
@@ -271,7 +355,7 @@
 	wait_complete();
 }
 
-static void otp_read_data(uint32_t offset, uint32_t *data)
+static void otp_read_data(u32 offset, u32 *data)
 {
 	writel(offset, OTP_ADDR); //Read address
 	writel(0x23b1e361, OTP_COMMAND); //trigger read
@@ -280,7 +364,7 @@
 	data[1] = readl(OTP_COMPARE_2);
 }
 
-static void otp_read_config(uint32_t offset, uint32_t *data)
+static void otp_read_conf(u32 offset, u32 *data)
 {
 	int config_offset;
 
@@ -294,46 +378,10 @@
 	data[0] = readl(OTP_COMPARE_1);
 }
 
-static int otp_print_config(uint32_t offset, int dw_count)
-{
-	int i;
-	uint32_t ret[1];
-
-	if (offset + dw_count > 32)
-		return OTP_USAGE;
-	otp_soak(0);
-	for (i = offset; i < offset + dw_count; i ++) {
-		otp_read_config(i, ret);
-		printf("OTPCFG%X: %08X\n", i, ret[0]);
-	}
-	printf("\n");
-	return OTP_SUCCESS;
-}
-
-static int otp_print_data(uint32_t offset, int dw_count)
-{
-	int i;
-	uint32_t ret[2];
-
-	if (offset + dw_count > 2048 || offset % 4 != 0)
-		return OTP_USAGE;
-	otp_soak(0);
-	for (i = offset; i < offset + dw_count; i += 2) {
-		otp_read_data(i, ret);
-		if (i % 4 == 0)
-			printf("%03X: %08X %08X ", i * 4, ret[0], ret[1]);
-		else
-			printf("%08X %08X\n", ret[0], ret[1]);
-
-	}
-	printf("\n");
-	return OTP_SUCCESS;
-}
-
-static int otp_compare(uint32_t otp_addr, uint32_t addr)
+static int otp_compare(u32 otp_addr, u32 addr)
 {
-	uint32_t ret;
-	uint32_t *buf;
+	u32 ret;
+	u32 *buf;
 
 	buf = map_physmem(addr, 16, MAP_WRBACK);
 	printf("%08X\n", buf[0]);
@@ -349,14 +397,14 @@
 	wait_complete();
 	ret = readl(OTP_STATUS); //Compare command
 	if (ret & 0x1)
-		return 0;
+		return OTP_SUCCESS;
 	else
-		return -1;
+		return OTP_FAILURE;
 }
 
-static int verify_bit(uint32_t otp_addr, int bit_offset, int value)
+static int verify_bit(u32 otp_addr, int bit_offset, int value)
 {
-	uint32_t ret[2];
+	u32 ret[2];
 
 	if (otp_addr % 2 == 0)
 		writel(otp_addr, OTP_ADDR); //Read address
@@ -370,21 +418,20 @@
 
 	if (otp_addr % 2 == 0) {
 		if (((ret[0] >> bit_offset) & 1) == value)
-			return 0;
+			return OTP_SUCCESS;
 		else
-			return -1;
+			return OTP_FAILURE;
 	} else {
 		if (((ret[1] >> bit_offset) & 1) == value)
-			return 0;
+			return OTP_SUCCESS;
 		else
-			return -1;
+			return OTP_FAILURE;
 	}
-
 }
 
-static uint32_t verify_dw(uint32_t otp_addr, uint32_t *value, uint32_t *ignore, uint32_t *compare, int size)
+static u32 verify_dw(u32 otp_addr, u32 *value, u32 *ignore, u32 *compare, int size)
 {
-	uint32_t ret[2];
+	u32 ret[2];
 
 	otp_addr &= ~(1 << 15);
 
@@ -401,21 +448,19 @@
 			// printf("check %x : %x = %x\n", otp_addr, ret[0], value[0]);
 			if ((value[0] & ~ignore[0]) == (ret[0] & ~ignore[0])) {
 				compare[0] = 0;
-				return 0;
-			} else {
-				compare[0] = value[0] ^ ret[0];
-				return -1;
+				return OTP_SUCCESS;
 			}
+			compare[0] = value[0] ^ ret[0];
+			return OTP_FAILURE;
 
 		} else {
 			// printf("check %x : %x = %x\n", otp_addr, ret[1], value[0]);
 			if ((value[0] & ~ignore[0]) == (ret[1] & ~ignore[0])) {
 				compare[0] = ~0;
-				return 0;
-			} else {
-				compare[0] = ~(value[0] ^ ret[1]);
-				return -1;
+				return OTP_SUCCESS;
 			}
+			compare[0] = ~(value[0] ^ ret[1]);
+			return OTP_FAILURE;
 		}
 	} else if (size == 2) {
 		// otp_addr should be even
@@ -424,20 +469,19 @@
 			// printf("check[1] %x : %x = %x\n", otp_addr, ret[1], value[1]);
 			compare[0] = 0;
 			compare[1] = ~0;
-			return 0;
-		} else {
-			// printf("check[0] %x : %x = %x\n", otp_addr, ret[0], value[0]);
-			// printf("check[1] %x : %x = %x\n", otp_addr, ret[1], value[1]);
-			compare[0] = value[0] ^ ret[0];
-			compare[1] = ~(value[1] ^ ret[1]);
-			return -1;
+			return OTP_SUCCESS;
 		}
+		// printf("check[0] %x : %x = %x\n", otp_addr, ret[0], value[0]);
+		// printf("check[1] %x : %x = %x\n", otp_addr, ret[1], value[1]);
+		compare[0] = value[0] ^ ret[0];
+		compare[1] = ~(value[1] ^ ret[1]);
+		return OTP_FAILURE;
 	} else {
-		return -1;
+		return OTP_FAILURE;
 	}
 }
 
-static void otp_prog(uint32_t otp_addr, uint32_t prog_bit)
+static void otp_prog(u32 otp_addr, u32 prog_bit)
 {
 	otp_write(0x0, prog_bit);
 	writel(otp_addr, OTP_ADDR); //write address
@@ -446,7 +490,7 @@
 	wait_complete();
 }
 
-static void _otp_prog_bit(uint32_t value, uint32_t prog_address, uint32_t bit_offset)
+static void _otp_prog_bit(u32 value, u32 prog_address, u32 bit_offset)
 {
 	int prog_bit;
 
@@ -456,7 +500,8 @@
 		else
 			return;
 	} else {
-		prog_address |= 1 << 15;
+		if (info_cb.version != OTP_A3)
+			prog_address |= 1 << 15;
 		if (!value)
 			prog_bit = 0x1 << bit_offset;
 		else
@@ -465,7 +510,7 @@
 	otp_prog(prog_address, prog_bit);
 }
 
-static int otp_prog_bit(uint32_t value, uint32_t prog_address, uint32_t bit_offset)
+static int otp_prog_dc_b(u32 value, u32 prog_address, u32 bit_offset)
 {
 	int pass;
 	int i;
@@ -489,11 +534,13 @@
 			break;
 		}
 	}
+	if (pass)
+		return OTP_SUCCESS;
 
-	return pass;
+	return OTP_FAILURE;
 }
 
-static void otp_prog_dw(uint32_t value, uint32_t ignore, uint32_t prog_address)
+static void otp_prog_dw(u32 value, u32 ignore, u32 prog_address)
 {
 	int j, bit_value, prog_bit;
 
@@ -507,7 +554,8 @@
 			else
 				continue;
 		} else {
-			prog_address |= 1 << 15;
+			if (info_cb.version != OTP_A3)
+				prog_address |= 1 << 15;
 			if (bit_value)
 				continue;
 			else
@@ -517,22 +565,22 @@
 	}
 }
 
-static int otp_prog_verify_2dw(uint32_t *data, uint32_t *buf, uint32_t *ignore_mask, uint32_t prog_address)
+static int otp_prog_verify_2dw(u32 *data, u32 *buf, u32 *ignore_mask, u32 prog_address)
 {
 	int pass;
 	int i;
-	uint32_t data0_masked;
-	uint32_t data1_masked;
-	uint32_t buf0_masked;
-	uint32_t buf1_masked;
-	uint32_t compare[2];
+	u32 data0_masked;
+	u32 data1_masked;
+	u32 buf0_masked;
+	u32 buf1_masked;
+	u32 compare[2];
 
 	data0_masked = data[0]  & ~ignore_mask[0];
 	buf0_masked  = buf[0] & ~ignore_mask[0];
 	data1_masked = data[1]  & ~ignore_mask[1];
 	buf1_masked  = buf[1] & ~ignore_mask[1];
-	if ((data0_masked == buf0_masked) && (data1_masked == buf1_masked))
-		return 0;
+	if (data0_masked == buf0_masked && data1_masked == buf1_masked)
+		return OTP_SUCCESS;
 
 	otp_soak(1);
 	if (data0_masked != buf0_masked)
@@ -544,12 +592,10 @@
 	for (i = 0; i < RETRY; i++) {
 		if (verify_dw(prog_address, buf, ignore_mask, compare, 2) != 0) {
 			otp_soak(2);
-			if (compare[0] != 0) {
+			if (compare[0] != 0)
 				otp_prog_dw(compare[0], ignore_mask[0], prog_address);
-			}
-			if (compare[1] != ~0) {
+			if (compare[1] != ~0)
 				otp_prog_dw(compare[1], ignore_mask[1], prog_address + 1);
-			}
 			if (verify_dw(prog_address, buf, ignore_mask, compare, 2) != 0) {
 				otp_soak(1);
 			} else {
@@ -571,11 +617,11 @@
 
 static void otp_strap_status(struct otpstrap_status *otpstrap)
 {
-	uint32_t OTPSTRAP_RAW[2];
+	u32 OTPSTRAP_RAW[2];
 	int strap_end;
 	int i, j;
 
-	if (info_cb.version == OTP_AST2600A0) {
+	if (info_cb.version == OTP_A0) {
 		for (j = 0; j < 64; j++) {
 			otpstrap[j].value = 0;
 			otpstrap[j].remain_times = 7;
@@ -597,33 +643,34 @@
 	otp_soak(0);
 	for (i = 16; i < strap_end; i += 2) {
 		int option = (i - 16) / 2;
-		otp_read_config(i, &OTPSTRAP_RAW[0]);
-		otp_read_config(i + 1, &OTPSTRAP_RAW[1]);
+
+		otp_read_conf(i, &OTPSTRAP_RAW[0]);
+		otp_read_conf(i + 1, &OTPSTRAP_RAW[1]);
 		for (j = 0; j < 32; j++) {
 			char bit_value = ((OTPSTRAP_RAW[0] >> j) & 0x1);
-			if ((bit_value == 0) && (otpstrap[j].writeable_option == -1)) {
+
+			if (bit_value == 0 && otpstrap[j].writeable_option == -1)
 				otpstrap[j].writeable_option = option;
-			}
 			if (bit_value == 1)
-				otpstrap[j].remain_times --;
+				otpstrap[j].remain_times--;
 			otpstrap[j].value ^= bit_value;
 			otpstrap[j].option_array[option] = bit_value;
 		}
 		for (j = 32; j < 64; j++) {
 			char bit_value = ((OTPSTRAP_RAW[1] >> (j - 32)) & 0x1);
-			if ((bit_value == 0) && (otpstrap[j].writeable_option == -1)) {
+
+			if (bit_value == 0 && otpstrap[j].writeable_option == -1)
 				otpstrap[j].writeable_option = option;
-			}
 			if (bit_value == 1)
-				otpstrap[j].remain_times --;
+				otpstrap[j].remain_times--;
 			otpstrap[j].value ^= bit_value;
 			otpstrap[j].option_array[option] = bit_value;
 		}
 	}
 
-	if (info_cb.version != OTP_AST2600A0) {
-		otp_read_config(28, &OTPSTRAP_RAW[0]);
-		otp_read_config(29, &OTPSTRAP_RAW[1]);
+	if (info_cb.version != OTP_A0) {
+		otp_read_conf(28, &OTPSTRAP_RAW[0]);
+		otp_read_conf(29, &OTPSTRAP_RAW[1]);
 		for (j = 0; j < 32; j++) {
 			if (((OTPSTRAP_RAW[0] >> j) & 0x1) == 1)
 				otpstrap[j].reg_protected = 1;
@@ -632,11 +679,10 @@
 			if (((OTPSTRAP_RAW[1] >> (j - 32)) & 0x1) == 1)
 				otpstrap[j].reg_protected = 1;
 		}
-
 	}
 
-	otp_read_config(30, &OTPSTRAP_RAW[0]);
-	otp_read_config(31, &OTPSTRAP_RAW[1]);
+	otp_read_conf(30, &OTPSTRAP_RAW[0]);
+	otp_read_conf(31, &OTPSTRAP_RAW[1]);
 	for (j = 0; j < 32; j++) {
 		if (((OTPSTRAP_RAW[0] >> j) & 0x1) == 1)
 			otpstrap[j].protected = 1;
@@ -647,37 +693,218 @@
 	}
 }
 
+static int otp_strap_bit_confirm(struct otpstrap_status *otpstrap, int offset, int ibit, int bit, int pbit, int rpbit)
+{
+	int prog_flag = 0;
+
+	// ignore this bit
+	if (ibit == 1)
+		return OTP_SUCCESS;
+	printf("OTPSTRAP[%X]:\n", offset);
+
+	if (bit == otpstrap->value) {
+		if (!pbit && !rpbit) {
+			printf("    The value is same as before, skip it.\n");
+			return OTP_PROG_SKIP;
+		}
+		printf("    The value is same as before.\n");
+	} else {
+		prog_flag = 1;
+	}
+	if (otpstrap->protected == 1 && prog_flag) {
+		printf("    This bit is protected and is not writable\n");
+		return OTP_FAILURE;
+	}
+	if (otpstrap->remain_times == 0 && prog_flag) {
+		printf("    This bit is no remaining times to write.\n");
+		return OTP_FAILURE;
+	}
+	if (pbit == 1)
+		printf("    This bit will be protected and become non-writable.\n");
+	if (rpbit == 1 && info_cb.version != OTP_A0)
+		printf("    The relative register will be protected.\n");
+	if (prog_flag)
+		printf("    Write 1 to OTPSTRAP[%X] OPTION[%X], that value becomes from %d to %d.\n", offset, otpstrap->writeable_option + 1, otpstrap->value, otpstrap->value ^ 1);
+
+	return OTP_SUCCESS;
+}
+
+static int otp_prog_strap_b(int bit_offset, int value)
+{
+	struct otpstrap_status otpstrap[64];
+	u32 prog_address;
+	int offset;
+	int ret;
+
+	otp_strap_status(otpstrap);
+
+	ret = otp_strap_bit_confirm(&otpstrap[bit_offset], bit_offset, 0, value, 0, 0);
+
+	if (ret != OTP_SUCCESS)
+		return ret;
+
+	prog_address = 0x800;
+	if (bit_offset < 32) {
+		offset = bit_offset;
+		prog_address |= ((otpstrap[bit_offset].writeable_option * 2 + 16) / 8) * 0x200;
+		prog_address |= ((otpstrap[bit_offset].writeable_option * 2 + 16) % 8) * 0x2;
+
+	} else {
+		offset = (bit_offset - 32);
+		prog_address |= ((otpstrap[bit_offset].writeable_option * 2 + 17) / 8) * 0x200;
+		prog_address |= ((otpstrap[bit_offset].writeable_option * 2 + 17) % 8) * 0x2;
+	}
+
+	return otp_prog_dc_b(1, prog_address, offset);
+}
+
+static int otp_print_conf(u32 offset, int dw_count)
+{
+	int i;
+	u32 ret[1];
+
+	if (offset + dw_count > 32)
+		return OTP_USAGE;
+	otp_soak(0);
+	for (i = offset; i < offset + dw_count; i++) {
+		otp_read_conf(i, ret);
+		printf("OTPCFG%X: %08X\n", i, ret[0]);
+	}
+	printf("\n");
+	return OTP_SUCCESS;
+}
+
+static int otp_print_data(u32 offset, int dw_count)
+{
+	int i;
+	u32 ret[2];
+
+	if (offset + dw_count > 2048 || offset % 4 != 0)
+		return OTP_USAGE;
+	otp_soak(0);
+	for (i = offset; i < offset + dw_count; i += 2) {
+		otp_read_data(i, ret);
+		if (i % 4 == 0)
+			printf("%03X: %08X %08X ", i * 4, ret[0], ret[1]);
+		else
+			printf("%08X %08X\n", ret[0], ret[1]);
+	}
+	printf("\n");
+	return OTP_SUCCESS;
+}
+
+static int otp_print_strap(int start, int count)
+{
+	int i, j;
+	int remains;
+	struct otpstrap_status otpstrap[64];
+
+	if (start < 0 || start > 64)
+		return OTP_USAGE;
+
+	if ((start + count) < 0 || (start + count) > 64)
+		return OTP_USAGE;
+
+	otp_strap_status(otpstrap);
+
+	if (info_cb.version == OTP_A0) {
+		remains = 7;
+		printf("BIT(hex)  Value  Option           Status\n");
+	} else {
+		remains = 6;
+		printf("BIT(hex)  Value  Option         Reg_Protect Status\n");
+	}
+	printf("______________________________________________________________________________\n");
+
+	for (i = start; i < start + count; i++) {
+		printf("0x%-8X", i);
+		printf("%-7d", otpstrap[i].value);
+		for (j = 0; j < remains; j++)
+			printf("%d ", otpstrap[i].option_array[j]);
+		printf("   ");
+		if (info_cb.version != OTP_A0)
+			printf("%d           ", otpstrap[i].reg_protected);
+		if (otpstrap[i].protected == 1) {
+			printf("protected and not writable");
+		} else {
+			printf("not protected ");
+			if (otpstrap[i].remain_times == 0)
+				printf("and no remaining times to write.");
+			else
+				printf("and still can write %d times", otpstrap[i].remain_times);
+		}
+		printf("\n");
+	}
+
+	return OTP_SUCCESS;
+}
+
+static void otp_print_revid(u32 *rid)
+{
+	int bit_offset;
+	int i, j;
+
+	printf("     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\n");
+	printf("___________________________________________________\n");
+	for (i = 0; i < 64; i++) {
+		if (i < 32) {
+			j = 0;
+			bit_offset = i;
+		} else {
+			j = 1;
+			bit_offset = i - 32;
+		}
+		if (i % 16 == 0)
+			printf("%2x | ", i);
+		printf("%d  ", (rid[j] >> bit_offset) & 0x1);
+		if ((i + 1) % 16 == 0)
+			printf("\n");
+	}
+}
+
 static int otp_print_conf_image(struct otp_image_layout *image_layout)
 {
 	const struct otpconf_info *conf_info = info_cb.conf_info;
-	uint32_t *OTPCFG = (uint32_t *)image_layout->conf;
-	uint32_t *OTPCFG_IGNORE = (uint32_t *)image_layout->conf_ignore;
-	uint32_t mask;
-	uint32_t dw_offset;
-	uint32_t bit_offset;
-	uint32_t otp_value;
-	uint32_t otp_ignore;
+	u32 *OTPCFG = (u32 *)image_layout->conf;
+	u32 *OTPCFG_IGNORE = (u32 *)image_layout->conf_ignore;
+	u32 mask;
+	u32 dw_offset;
+	u32 bit_offset;
+	u32 otp_value;
+	u32 otp_ignore;
 	int fail = 0;
+	int mask_err;
+	int rid_num = 0;
 	char valid_bit[20];
+	int fz;
 	int i;
 	int j;
 
 	printf("DW    BIT        Value       Description\n");
 	printf("__________________________________________________________________________\n");
 	for (i = 0; i < info_cb.conf_info_len; i++) {
+		mask_err = 0;
 		dw_offset = conf_info[i].dw_offset;
 		bit_offset = conf_info[i].bit_offset;
 		mask = BIT(conf_info[i].length) - 1;
 		otp_value = (OTPCFG[dw_offset] >> bit_offset) & mask;
 		otp_ignore = (OTPCFG_IGNORE[dw_offset] >> bit_offset) & mask;
 
-		if (otp_ignore == mask) {
-			continue;
-		} else if (otp_ignore != 0) {
-			fail = 1;
+		if (conf_info[i].value == OTP_REG_VALID_BIT) {
+			if (((otp_value + otp_ignore) & mask) != mask) {
+				fail = 1;
+				mask_err = 1;
+			}
+		} else {
+			if (otp_ignore == mask) {
+				continue;
+			} else if (otp_ignore != 0) {
+				fail = 1;
+				mask_err = 1;
+			}
 		}
 
-		if ((otp_value != conf_info[i].value) &&
+		if (otp_value != conf_info[i].value &&
 		    conf_info[i].value != OTP_REG_RESERVED &&
 		    conf_info[i].value != OTP_REG_VALUE &&
 		    conf_info[i].value != OTP_REG_VALID_BIT)
@@ -693,34 +920,60 @@
 		}
 		printf("0x%-10x", otp_value);
 
-		if (fail) {
-			printf("Ignore mask error\n");
+		if (mask_err) {
+			printf("Ignore, mask error\n");
+			continue;
+		}
+		if (conf_info[i].value == OTP_REG_RESERVED) {
+			printf("Reserved\n");
+		} else if (conf_info[i].value == OTP_REG_VALUE) {
+			printf(conf_info[i].information, otp_value);
+			printf("\n");
+		} else if (conf_info[i].value == OTP_REG_VALID_BIT) {
+			if (otp_value != 0) {
+				for (j = 0; j < 7; j++) {
+					if (otp_value == (1 << j))
+						valid_bit[j * 2] = '1';
+					else
+						valid_bit[j * 2] = '0';
+					valid_bit[j * 2 + 1] = ' ';
+				}
+				valid_bit[15] = 0;
+			} else {
+				strcpy(valid_bit, "0 0 0 0 0 0 0 0\0");
+			}
+			printf(conf_info[i].information, valid_bit);
+			printf("\n");
 		} else {
-			if (conf_info[i].value == OTP_REG_RESERVED) {
-				printf("Reserved\n");
-			} else if (conf_info[i].value == OTP_REG_VALUE) {
-				printf(conf_info[i].information, otp_value);
-				printf("\n");
-			} else if (conf_info[i].value == OTP_REG_VALID_BIT) {
-				if (otp_value != 0) {
-					for (j = 0; j < 7; j++) {
-						if (otp_value == (1 << j)) {
-							valid_bit[j * 2] = '1';
-						} else {
-							valid_bit[j * 2] = '0';
-						}
-						valid_bit[j * 2 + 1] = ' ';
-					}
-					valid_bit[15] = 0;
+			printf("%s\n", conf_info[i].information);
+		}
+	}
+
+	if (OTPCFG[0xa] != 0 || OTPCFG[0xb] != 0) {
+		if (OTPCFG_IGNORE[0xa] != 0 && OTPCFG_IGNORE[0xb] != 0) {
+			printf("OTP revision ID is invalid.\n");
+			fail = 1;
+		} else {
+			fz = 0;
+			for (i = 0; i < 64; i++) {
+				if (get_dw_bit(&OTPCFG[0xa], i) == 0) {
+					if (!fz)
+						fz = 1;
 				} else {
-					strcpy(valid_bit, "0 0 0 0 0 0 0 0\0");
+					rid_num++;
+					if (fz) {
+						printf("OTP revision ID is invalid.\n");
+						fail = 1;
+						break;
+					}
 				}
-				printf(conf_info[i].information, valid_bit);
-				printf("\n");
-			} else {
-				printf("%s\n", conf_info[i].information);
 			}
 		}
+		if (fail)
+			printf("OTP revision ID\n");
+		else
+			printf("OTP revision ID: 0x%x\n", rid_num);
+		otp_print_revid(&OTPCFG[0xa]);
 	}
 
 	if (fail)
@@ -732,19 +985,18 @@
 static int otp_print_conf_info(int input_offset)
 {
 	const struct otpconf_info *conf_info = info_cb.conf_info;
-	uint32_t OTPCFG[16];
-	uint32_t mask;
-	uint32_t dw_offset;
-	uint32_t bit_offset;
-	uint32_t otp_value;
+	u32 OTPCFG[16];
+	u32 mask;
+	u32 dw_offset;
+	u32 bit_offset;
+	u32 otp_value;
 	char valid_bit[20];
 	int i;
 	int j;
 
 	otp_soak(0);
 	for (i = 0; i < 16; i++)
-		otp_read_config(i, &OTPCFG[i]);
-
+		otp_read_conf(i, &OTPCFG[i]);
 
 	printf("DW    BIT        Value       Description\n");
 	printf("__________________________________________________________________________\n");
@@ -756,7 +1008,7 @@
 		mask = BIT(conf_info[i].length) - 1;
 		otp_value = (OTPCFG[dw_offset] >> bit_offset) & mask;
 
-		if ((otp_value != conf_info[i].value) &&
+		if (otp_value != conf_info[i].value &&
 		    conf_info[i].value != OTP_REG_RESERVED &&
 		    conf_info[i].value != OTP_REG_VALUE &&
 		    conf_info[i].value != OTP_REG_VALID_BIT)
@@ -780,11 +1032,10 @@
 		} else if (conf_info[i].value == OTP_REG_VALID_BIT) {
 			if (otp_value != 0) {
 				for (j = 0; j < 7; j++) {
-					if (otp_value == (1 << j)) {
+					if (otp_value == (1 << j))
 						valid_bit[j * 2] = '1';
-					} else {
+					else
 						valid_bit[j * 2] = '0';
-					}
 					valid_bit[j * 2 + 1] = ' ';
 				}
 				valid_bit[15] = 0;
@@ -803,33 +1054,34 @@
 static int otp_print_strap_image(struct otp_image_layout *image_layout)
 {
 	const struct otpstrap_info *strap_info = info_cb.strap_info;
-	uint32_t *OTPSTRAP;
-	uint32_t *OTPSTRAP_REG_PRO;
-	uint32_t *OTPSTRAP_PRO;
-	uint32_t *OTPSTRAP_IGNORE;
+	u32 *OTPSTRAP;
+	u32 *OTPSTRAP_REG_PRO;
+	u32 *OTPSTRAP_PRO;
+	u32 *OTPSTRAP_IGNORE;
 	int i;
 	int fail = 0;
-	uint32_t bit_offset;
-	uint32_t dw_offset;
-	uint32_t mask;
-	uint32_t otp_value;
-	uint32_t otp_reg_protect;
-	uint32_t otp_protect;
-	uint32_t otp_ignore;
-
-	OTPSTRAP = (uint32_t *)image_layout->strap;
-	OTPSTRAP_PRO = (uint32_t *)image_layout->strap_pro;
-	OTPSTRAP_IGNORE = (uint32_t *)image_layout->strap_ignore;
-	if (info_cb.version == OTP_AST2600A0) {
+	u32 bit_offset;
+	u32 dw_offset;
+	u32 mask;
+	u32 otp_value;
+	u32 otp_reg_protect;
+	u32 otp_protect;
+	u32 otp_ignore;
+
+	OTPSTRAP = (u32 *)image_layout->strap;
+	OTPSTRAP_PRO = (u32 *)image_layout->strap_pro;
+	OTPSTRAP_IGNORE = (u32 *)image_layout->strap_ignore;
+	if (info_cb.version == OTP_A0) {
 		OTPSTRAP_REG_PRO = NULL;
 		printf("BIT(hex)   Value       Protect     Description\n");
 	} else {
-		OTPSTRAP_REG_PRO = (uint32_t *)image_layout->strap_reg_pro;
+		OTPSTRAP_REG_PRO = (u32 *)image_layout->strap_reg_pro;
 		printf("BIT(hex)   Value       Reg_Protect Protect     Description\n");
 	}
 	printf("__________________________________________________________________________________________\n");
 
 	for (i = 0; i < info_cb.strap_info_len; i++) {
+		fail = 0;
 		if (strap_info[i].bit_offset > 31) {
 			dw_offset = 1;
 			bit_offset = strap_info[i].bit_offset - 32;
@@ -843,18 +1095,17 @@
 		otp_protect = (OTPSTRAP_PRO[dw_offset] >> bit_offset) & mask;
 		otp_ignore = (OTPSTRAP_IGNORE[dw_offset] >> bit_offset) & mask;
 
-		if (info_cb.version != OTP_AST2600A0)
+		if (info_cb.version != OTP_A0)
 			otp_reg_protect = (OTPSTRAP_REG_PRO[dw_offset] >> bit_offset) & mask;
 		else
 			otp_reg_protect = 0;
 
-		if (otp_ignore == mask) {
+		if (otp_ignore == mask)
 			continue;
-		} else if (otp_ignore != 0) {
+		else if (otp_ignore != 0)
 			fail = 1;
-		}
 
-		if ((otp_value != strap_info[i].value) &&
+		if (otp_value != strap_info[i].value &&
 		    strap_info[i].value != OTP_REG_RESERVED)
 			continue;
 
@@ -866,7 +1117,7 @@
 			       strap_info[i].bit_offset);
 		}
 		printf("0x%-10x", otp_value);
-		if (info_cb.version != OTP_AST2600A0)
+		if (info_cb.version != OTP_A0)
 			printf("0x%-10x", otp_reg_protect);
 		printf("0x%-10x", otp_protect);
 
@@ -892,15 +1143,15 @@
 	struct otpstrap_status strap_status[64];
 	int i, j;
 	int fail = 0;
-	uint32_t bit_offset;
-	uint32_t length;
-	uint32_t otp_value;
-	uint32_t otp_protect;
+	u32 bit_offset;
+	u32 length;
+	u32 otp_value;
+	u32 otp_protect;
 
 	otp_strap_status(strap_status);
 
 	if (view) {
-		if (info_cb.version == OTP_AST2600A0)
+		if (info_cb.version == OTP_A0)
 			printf("BIT(hex) Value  Remains  Protect   Description\n");
 		else
 			printf("BIT(hex) Value  Remains  Reg_Protect Protect   Description\n");
@@ -917,7 +1168,7 @@
 			otp_value |= strap_status[bit_offset + j].value << j;
 			otp_protect |= strap_status[bit_offset + j].protected << j;
 		}
-		if ((otp_value != strap_info[i].value) &&
+		if (otp_value != strap_info[i].value &&
 		    strap_info[i].value != OTP_REG_RESERVED)
 			continue;
 		if (view) {
@@ -925,7 +1176,7 @@
 				printf("0x%-7X", strap_info[i].bit_offset + j);
 				printf("0x%-5X", strap_status[bit_offset + j].value);
 				printf("%-9d", strap_status[bit_offset + j].remain_times);
-				if (info_cb.version != OTP_AST2600A0)
+				if (info_cb.version != OTP_A0)
 					printf("0x%-10X", strap_status[bit_offset + j].reg_protected);
 				printf("0x%-7X", strap_status[bit_offset + j].protected);
 				if (strap_info[i].value == OTP_REG_RESERVED) {
@@ -967,42 +1218,26 @@
 	return OTP_SUCCESS;
 }
 
-static void buf_print(uint8_t *buf, int len)
-{
-	int i;
-	printf("      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n");
-	for (i = 0; i < len; i++) {
-		if (i % 16 == 0) {
-			printf("%04X: ", i);
-		}
-		printf("%02X ", buf[i]);
-		if ((i + 1) % 16 == 0) {
-			printf("\n");
-		}
-	}
-}
-
-static int otp_print_data_info(struct otp_image_layout *image_layout)
+static int otp_print_data_image(struct otp_image_layout *image_layout)
 {
 	int key_id, key_offset, last, key_type, key_length, exp_length;
 	const struct otpkey_type *key_info_array = info_cb.key_info;
 	struct otpkey_type key_info;
-	uint32_t *buf;
-	uint8_t *byte_buf;
+	u32 *buf;
+	u8 *byte_buf;
 	char empty = 1;
 	int i = 0, len = 0;
 	int j;
 
 	byte_buf = image_layout->data;
-	buf = (uint32_t *)byte_buf;
+	buf = (u32 *)byte_buf;
 
 	for (i = 0; i < 16; i++) {
-		if (buf[i] != 0) {
+		if (buf[i] != 0)
 			empty = 0;
-		}
 	}
 	if (empty)
-		return 0;
+		return OTP_SUCCESS;
 
 	i = 0;
 	while (1) {
@@ -1071,13 +1306,13 @@
 		} else if (key_info.key_type == OTP_KEY_TYPE_AES) {
 			printf("AES Key:\n");
 			buf_print(&byte_buf[key_offset], 0x20);
-			if (info_cb.version == OTP_AST2600A0) {
+			if (info_cb.version == OTP_A0) {
 				printf("AES IV:\n");
 				buf_print(&byte_buf[key_offset + 0x20], 0x10);
 			}
 
 		} else if (key_info.key_type == OTP_KEY_TYPE_VAULT) {
-			if (info_cb.version == OTP_AST2600A0) {
+			if (info_cb.version == OTP_A0) {
 				printf("AES Key:\n");
 				buf_print(&byte_buf[key_offset], 0x20);
 				printf("AES IV:\n");
@@ -1088,7 +1323,6 @@
 				printf("AES Key 2:\n");
 				buf_print(&byte_buf[key_offset + 0x20], 0x20);
 			}
-
 		} else if (key_info.key_type == OTP_KEY_TYPE_RSA_PRIV) {
 			printf("RSA mod:\n");
 			buf_print(&byte_buf[key_offset], len / 2);
@@ -1098,147 +1332,31 @@
 			printf("RSA mod:\n");
 			buf_print(&byte_buf[key_offset], len / 2);
 			printf("RSA exp:\n");
-			buf_print((uint8_t *)"\x01\x00\x01", 3);
+			buf_print((u8 *)"\x01\x00\x01", 3);
 		}
 		if (last)
 			break;
 		i++;
 	}
-	return 0;
-}
-
-static int otp_prog_conf(struct otp_image_layout *image_layout)
-{
-	int i, k;
-	int pass = 0;
-	uint32_t prog_address;
-	uint32_t data[16];
-	uint32_t compare[2];
-	uint32_t *conf = (uint32_t *)image_layout->conf;
-	uint32_t *conf_ignore = (uint32_t *)image_layout->conf_ignore;
-	uint32_t data_masked;
-	uint32_t buf_masked;
-
-	printf("Read OTP Config Region:\n");
-
-	for (i = 0; i < 16 ; i ++) {
-		prog_address = 0x800;
-		prog_address |= (i / 8) * 0x200;
-		prog_address |= (i % 8) * 0x2;
-		otp_read_data(prog_address, &data[i]);
-	}
-
-	printf("Check writable...\n");
-	for (i = 0; i < 16; i++) {
-		data_masked = data[i]  & ~conf_ignore[i];
-		buf_masked  = conf[i] & ~conf_ignore[i];
-		if (data_masked == buf_masked)
-			continue;
-		if ((data_masked | buf_masked) == buf_masked) {
-			continue;
-		} else {
-			printf("Input image can't program into OTP, please check.\n");
-			printf("OTPCFG[%X] = %x\n", i, data[i]);
-			printf("Input [%X] = %x\n", i, conf[i]);
-			printf("Mask  [%X] = %x\n", i, ~conf_ignore[i]);
-			return OTP_FAILURE;
-		}
-	}
-
-	printf("Start Programing...\n");
-	otp_soak(0);
-	for (i = 0; i < 16; i++) {
-		data_masked = data[i]  & ~conf_ignore[i];
-		buf_masked  = conf[i] & ~conf_ignore[i];
-		prog_address = 0x800;
-		prog_address |= (i / 8) * 0x200;
-		prog_address |= (i % 8) * 0x2;
-		if (data_masked == buf_masked) {
-			pass = 1;
-			continue;
-		}
-
-
-		otp_soak(1);
-		otp_prog_dw(conf[i], conf_ignore[i], prog_address);
-
-		pass = 0;
-		for (k = 0; k < RETRY; k++) {
-			if (verify_dw(prog_address, &conf[i], &conf_ignore[i], compare, 1) != 0) {
-				otp_soak(2);
-				otp_prog_dw(compare[0], conf_ignore[i], prog_address);
-				if (verify_dw(prog_address, &conf[i], &conf_ignore[i], compare, 1) != 0) {
-					otp_soak(1);
-				} else {
-					pass = 1;
-					break;
-				}
-			} else {
-				pass = 1;
-				break;
-			}
-		}
-		if (pass == 0) {
-			printf("address: %08x, data: %08x, buffer: %08x, mask: %08x\n",
-			       i, data[i], conf[i], conf_ignore[i]);
-			break;
-		}
-	}
-
-	otp_soak(0);
-	if (!pass)
-		return OTP_FAILURE;
-
-	return OTP_SUCCESS;
-
-}
-
-static int otp_strap_bit_confirm(struct otpstrap_status *otpstrap, int offset, int ibit, int bit, int pbit, int rpbit)
-{
-	if (ibit == 1) {
-		return OTP_SUCCESS;
-	} else {
-		printf("OTPSTRAP[%X]:\n", offset);
-	}
-	if (bit == otpstrap->value) {
-		printf("    The value is same as before, skip it.\n");
-		return OTP_PROG_SKIP;
-	}
-	if (otpstrap->protected == 1) {
-		printf("    This bit is protected and is not writable\n");
-		return OTP_FAILURE;
-	}
-	if (otpstrap->remain_times == 0) {
-		printf("    This bit is no remaining times to write.\n");
-		return OTP_FAILURE;
-	}
-	if (pbit == 1) {
-		printf("    This bit will be protected and become non-writable.\n");
-	}
-	if (rpbit == 1 && info_cb.version != OTP_AST2600A0) {
-		printf("    The relative register will be protected.\n");
-	}
-	printf("    Write 1 to OTPSTRAP[%X] OPTION[%X], that value becomes from %d to %d.\n", offset, otpstrap->writeable_option + 1, otpstrap->value, otpstrap->value ^ 1);
 	return OTP_SUCCESS;
 }
 
 static int otp_strap_image_confirm(struct otp_image_layout *image_layout)
 {
 	int i;
-	uint32_t *strap;
-	uint32_t *strap_ignore;
-	uint32_t *strap_reg_protect;
-	uint32_t *strap_pro;
+	u32 *strap;
+	u32 *strap_ignore;
+	u32 *strap_reg_protect;
+	u32 *strap_pro;
 	int bit, pbit, ibit, rpbit;
 	int fail = 0;
-	int skip = -1;
 	int ret;
 	struct otpstrap_status otpstrap[64];
 
-	strap = (uint32_t *)image_layout->strap;
-	strap_pro = (uint32_t *)image_layout->strap_pro;
-	strap_ignore = (uint32_t *)image_layout->strap_ignore;
-	strap_reg_protect = (uint32_t *)image_layout->strap_reg_pro;
+	strap = (u32 *)image_layout->strap;
+	strap_pro = (u32 *)image_layout->strap_pro;
+	strap_ignore = (u32 *)image_layout->strap_ignore;
+	strap_reg_protect = (u32 *)image_layout->strap_reg_pro;
 
 	otp_strap_status(otpstrap);
 	for (i = 0; i < 64; i++) {
@@ -1252,132 +1370,118 @@
 			pbit = (strap_pro[1] >> (i - 32)) & 0x1;
 		}
 
-		if (info_cb.version != OTP_AST2600A0) {
-			if (i < 32) {
+		if (info_cb.version != OTP_A0) {
+			if (i < 32)
 				rpbit = (strap_reg_protect[0] >> i) & 0x1;
-			} else {
+			else
 				rpbit = (strap_reg_protect[1] >> (i - 32)) & 0x1;
-			}
 		} else {
 			rpbit = 0;
 		}
 		ret = otp_strap_bit_confirm(&otpstrap[i], i, ibit, bit, pbit, rpbit);
-		if (ret == OTP_PROG_SKIP) {
-			if (skip == -1)
-				skip = 1;
-			continue;
-		} else {
-			skip = 1;
-		}
 
 		if (ret == OTP_FAILURE)
 			fail = 1;
 	}
 	if (fail == 1)
 		return OTP_FAILURE;
-	else if (skip == 1)
-		return OTP_PROG_SKIP;
-
-	return OTP_SUCCESS;
+	else
+		return OTP_SUCCESS;
 }
 
-static int otp_print_strap(int start, int count)
+static int otp_prog_data(struct otp_image_layout *image_layout)
 {
-	int i, j;
-	int remains;
-	struct otpstrap_status otpstrap[64];
+	int i;
+	int ret;
+	int data_dw;
+	u32 data[2048];
+	u32 *buf;
+	u32 *buf_ignore;
+	u32 data_masked;
+	u32 buf_masked;
 
-	if (start < 0 || start > 64)
-		return OTP_USAGE;
+	buf = (u32 *)image_layout->data;
+	buf_ignore = (u32 *)image_layout->data_ignore;
 
-	if ((start + count) < 0 || (start + count) > 64)
-		return OTP_USAGE;
+	data_dw = image_layout->data_length / 4;
 
-	otp_strap_status(otpstrap);
+	printf("Read OTP Data:\n");
 
-	if (info_cb.version == OTP_AST2600A0) {
-		remains = 7;
-		printf("BIT(hex)  Value  Option           Status\n");
-	} else {
-		remains = 6;
-		printf("BIT(hex)  Value  Option         Reg_Protect Status\n");
-	}
-	printf("______________________________________________________________________________\n");
+	for (i = 0; i < data_dw - 2 ; i += 2)
+		otp_read_data(i, &data[i]);
 
-	for (i = start; i < start + count; i++) {
-		printf("0x%-8X", i);
-		printf("%-7d", otpstrap[i].value);
-		for (j = 0; j < remains; j++)
-			printf("%d ", otpstrap[i].option_array[j]);
-		printf("   ");
-		if (info_cb.version != OTP_AST2600A0) {
-			printf("%d           ", otpstrap[i].reg_protected);
-		}
-		if (otpstrap[i].protected == 1) {
-			printf("protected and not writable");
+	printf("Check writable...\n");
+	// ignore last two dw, the last two dw is used for slt otp write check.
+	for (i = 0; i < data_dw - 2; i++) {
+		data_masked = data[i]  & ~buf_ignore[i];
+		buf_masked  = buf[i] & ~buf_ignore[i];
+		if (data_masked == buf_masked)
+			continue;
+		if (i % 2 == 0) {
+			if ((data_masked | buf_masked) == buf_masked) {
+				continue;
+			} else {
+				printf("Input image can't program into OTP, please check.\n");
+				printf("OTP_ADDR[%x] = %x\n", i, data[i]);
+				printf("Input   [%x] = %x\n", i, buf[i]);
+				printf("Mask    [%x] = %x\n", i, ~buf_ignore[i]);
+				return OTP_FAILURE;
+			}
 		} else {
-			printf("not protected ");
-			if (otpstrap[i].remain_times == 0) {
-				printf("and no remaining times to write.");
+			if ((data_masked & buf_masked) == buf_masked) {
+				continue;
 			} else {
-				printf("and still can write %d times", otpstrap[i].remain_times);
+				printf("Input image can't program into OTP, please check.\n");
+				printf("OTP_ADDR[%x] = %x\n", i, data[i]);
+				printf("Input   [%x] = %x\n", i, buf[i]);
+				printf("Mask    [%x] = %x\n", i, ~buf_ignore[i]);
+				return OTP_FAILURE;
 			}
 		}
-		printf("\n");
 	}
 
-	return OTP_SUCCESS;
-}
-
-static int otp_prog_strap_bit(int bit_offset, int value)
-{
-	struct otpstrap_status otpstrap[64];
-	uint32_t prog_address;
-	int offset;
-	int ret;
-
-
-	otp_strap_status(otpstrap);
-
-	ret = otp_strap_bit_confirm(&otpstrap[bit_offset], bit_offset, 0, value, 0, 0);
+	printf("Start Programing...\n");
 
-	if (ret != OTP_SUCCESS) {
-		return ret;
+	// programing ecc region first
+	for (i = 1792; i < 2046; i += 2) {
+		ret = otp_prog_verify_2dw(&data[i], &buf[i], &buf_ignore[i], i);
+		if (ret != OTP_SUCCESS) {
+			printf("address: %08x, data: %08x %08x, buffer: %08x %08x, mask: %08x %08x\n",
+			       i, data[i], data[i + 1], buf[i], buf[i + 1], buf_ignore[i], buf_ignore[i + 1]);
+			return ret;
+		}
 	}
 
-	prog_address = 0x800;
-	if (bit_offset < 32) {
-		offset = bit_offset;
-		prog_address |= ((otpstrap[bit_offset].writeable_option * 2 + 16) / 8) * 0x200;
-		prog_address |= ((otpstrap[bit_offset].writeable_option * 2 + 16) % 8) * 0x2;
-
-	} else {
-		offset = (bit_offset - 32);
-		prog_address |= ((otpstrap[bit_offset].writeable_option * 2 + 17) / 8) * 0x200;
-		prog_address |= ((otpstrap[bit_offset].writeable_option * 2 + 17) % 8) * 0x2;
+	for (i = 0; i < 1792; i += 2) {
+		ret = otp_prog_verify_2dw(&data[i], &buf[i], &buf_ignore[i], i);
+		if (ret != OTP_SUCCESS) {
+			printf("address: %08x, data: %08x %08x, buffer: %08x %08x, mask: %08x %08x\n",
+			       i, data[i], data[i + 1], buf[i], buf[i + 1], buf_ignore[i], buf_ignore[i + 1]);
+			return ret;
+		}
 	}
-
-
-	return otp_prog_bit(1, prog_address, offset);
+	otp_soak(0);
+	return OTP_SUCCESS;
 }
 
 static int otp_prog_strap(struct otp_image_layout *image_layout)
 {
-	uint32_t *strap;
-	uint32_t *strap_ignore;
-	uint32_t *strap_pro;
-	uint32_t *strap_reg_protect;
-	uint32_t prog_address;
+	u32 *strap;
+	u32 *strap_ignore;
+	u32 *strap_pro;
+	u32 *strap_reg_protect;
+	u32 prog_address;
 	int i;
 	int bit, pbit, ibit, offset, rpbit;
 	int fail = 0;
 	int ret;
+	int prog_flag = 0;
 	struct otpstrap_status otpstrap[64];
 
-	strap = (uint32_t *)image_layout->strap;
-	strap_pro = (uint32_t *)image_layout->strap_pro;
-	strap_ignore = (uint32_t *)image_layout->strap_ignore;
-	strap_reg_protect = (uint32_t *)image_layout->strap_reg_pro;
+	strap = (u32 *)image_layout->strap;
+	strap_pro = (u32 *)image_layout->strap_pro;
+	strap_ignore = (u32 *)image_layout->strap_ignore;
+	strap_reg_protect = (u32 *)image_layout->strap_reg_pro;
 
 	printf("Read OTP Strap Region:\n");
 	otp_strap_status(otpstrap);
@@ -1406,44 +1510,46 @@
 			prog_address |= ((otpstrap[i].writeable_option * 2 + 17) / 8) * 0x200;
 			prog_address |= ((otpstrap[i].writeable_option * 2 + 17) % 8) * 0x2;
 		}
-		if (info_cb.version != OTP_AST2600A0) {
-			if (i < 32) {
+		if (info_cb.version != OTP_A0) {
+			if (i < 32)
 				rpbit = (strap_reg_protect[0] >> i) & 0x1;
-			} else {
+			else
 				rpbit = (strap_reg_protect[1] >> (i - 32)) & 0x1;
-			}
 		} else {
 			rpbit = 0;
 		}
 
-		if (ibit == 1) {
-			continue;
-		}
-		if (bit == otpstrap[i].value) {
+		if (ibit == 1)
 			continue;
-		}
-		if (otpstrap[i].protected == 1) {
+		if (bit == otpstrap[i].value)
+			prog_flag = 0;
+		else
+			prog_flag = 1;
+
+		if (otpstrap[i].protected == 1 && prog_flag) {
 			fail = 1;
 			continue;
 		}
-		if (otpstrap[i].remain_times == 0) {
+		if (otpstrap[i].remain_times == 0 && prog_flag) {
 			fail = 1;
 			continue;
 		}
 
-		ret = otp_prog_bit(1, prog_address, offset);
-		if (!ret)
-			return OTP_FAILURE;
+		if (prog_flag) {
+			ret = otp_prog_dc_b(1, prog_address, offset);
+			if (ret)
+				return OTP_FAILURE;
+		}
 
-		if (rpbit == 1 && info_cb.version != OTP_AST2600A0) {
+		if (rpbit == 1 && info_cb.version != OTP_A0) {
 			prog_address = 0x800;
 			if (i < 32)
 				prog_address |= 0x608;
 			else
 				prog_address |= 0x60a;
 
-			ret = otp_prog_bit(1, prog_address, offset);
-			if (!ret)
+			ret = otp_prog_dc_b(1, prog_address, offset);
+			if (ret)
 				return OTP_FAILURE;
 		}
 
@@ -1454,99 +1560,102 @@
 			else
 				prog_address |= 0x60e;
 
-			ret = otp_prog_bit(1, prog_address, offset);
-			if (!ret)
+			ret = otp_prog_dc_b(1, prog_address, offset);
+			if (ret)
 				return OTP_FAILURE;
 		}
-
 	}
 	otp_soak(0);
 	if (fail == 1)
 		return OTP_FAILURE;
-	else
-		return OTP_SUCCESS;
-
+	return OTP_SUCCESS;
 }
 
-static int otp_prog_data(struct otp_image_layout *image_layout)
+static int otp_prog_conf(struct otp_image_layout *image_layout)
 {
-	int i;
-	int ret;
-	int data_dw;
-	uint32_t data[2048];
-	uint32_t *buf;
-	uint32_t *buf_ignore;
-
-	uint32_t data_masked;
-	uint32_t buf_masked;
-
-	buf = (uint32_t *)image_layout->data;
-	buf_ignore = (uint32_t *)image_layout->data_ignore;
-
-	data_dw = image_layout->data_length / 4;
+	int i, k;
+	int pass = 0;
+	u32 prog_address;
+	u32 data[16];
+	u32 compare[2];
+	u32 *conf = (u32 *)image_layout->conf;
+	u32 *conf_ignore = (u32 *)image_layout->conf_ignore;
+	u32 data_masked;
+	u32 buf_masked;
 
-	printf("Read OTP Data:\n");
+	printf("Read OTP Config Region:\n");
 
-	for (i = 0; i < data_dw - 2 ; i += 2) {
-		otp_read_data(i, &data[i]);
+	for (i = 0; i < 16 ; i++) {
+		prog_address = 0x800;
+		prog_address |= (i / 8) * 0x200;
+		prog_address |= (i % 8) * 0x2;
+		otp_read_data(prog_address, &data[i]);
 	}
 
 	printf("Check writable...\n");
-	// ignore last two dw, the last two dw is used for slt otp write check.
-	for (i = 0; i < data_dw - 2; i++) {
-		data_masked = data[i]  & ~buf_ignore[i];
-		buf_masked  = buf[i] & ~buf_ignore[i];
+	for (i = 0; i < 16; i++) {
+		data_masked = data[i]  & ~conf_ignore[i];
+		buf_masked  = conf[i] & ~conf_ignore[i];
 		if (data_masked == buf_masked)
 			continue;
-		if (i % 2 == 0) {
-			if ((data_masked | buf_masked) == buf_masked) {
-				continue;
-			} else {
-				printf("Input image can't program into OTP, please check.\n");
-				printf("OTP_ADDR[%x] = %x\n", i, data[i]);
-				printf("Input   [%x] = %x\n", i, buf[i]);
-				printf("Mask    [%x] = %x\n", i, ~buf_ignore[i]);
-				return OTP_FAILURE;
-			}
+		if ((data_masked | buf_masked) == buf_masked) {
+			continue;
 		} else {
-			if ((data_masked & buf_masked) == buf_masked) {
-				continue;
-			} else {
-				printf("Input image can't program into OTP, please check.\n");
-				printf("OTP_ADDR[%x] = %x\n", i, data[i]);
-				printf("Input   [%x] = %x\n", i, buf[i]);
-				printf("Mask    [%x] = %x\n", i, ~buf_ignore[i]);
-				return OTP_FAILURE;
-			}
+			printf("Input image can't program into OTP, please check.\n");
+			printf("OTPCFG[%X] = %x\n", i, data[i]);
+			printf("Input [%X] = %x\n", i, conf[i]);
+			printf("Mask  [%X] = %x\n", i, ~conf_ignore[i]);
+			return OTP_FAILURE;
 		}
 	}
 
 	printf("Start Programing...\n");
-
-	// programing ecc region first
-	for (i = 1792; i < 2046; i += 2) {
-		ret = otp_prog_verify_2dw(&data[i], &buf[i], &buf_ignore[i], i);
-		if (ret != OTP_SUCCESS) {
-			printf("address: %08x, data: %08x %08x, buffer: %08x %08x, mask: %08x %08x\n",
-			       i, data[i], data[i + 1], buf[i], buf[i + 1], buf_ignore[i], buf_ignore[i + 1]);
-			return ret;
+	otp_soak(0);
+	for (i = 0; i < 16; i++) {
+		data_masked = data[i]  & ~conf_ignore[i];
+		buf_masked  = conf[i] & ~conf_ignore[i];
+		prog_address = 0x800;
+		prog_address |= (i / 8) * 0x200;
+		prog_address |= (i % 8) * 0x2;
+		if (data_masked == buf_masked) {
+			pass = 1;
+			continue;
 		}
-	}
 
-	for (i = 0; i < 1792; i += 2) {
-		ret = otp_prog_verify_2dw(&data[i], &buf[i], &buf_ignore[i], i);
-		if (ret != OTP_SUCCESS) {
-			printf("address: %08x, data: %08x %08x, buffer: %08x %08x, mask: %08x %08x\n",
-			       i, data[i], data[i + 1], buf[i], buf[i + 1], buf_ignore[i], buf_ignore[i + 1]);
-			return ret;
+		otp_soak(1);
+		otp_prog_dw(conf[i], conf_ignore[i], prog_address);
+
+		pass = 0;
+		for (k = 0; k < RETRY; k++) {
+			if (verify_dw(prog_address, &conf[i], &conf_ignore[i], compare, 1) != 0) {
+				otp_soak(2);
+				otp_prog_dw(compare[0], conf_ignore[i], prog_address);
+				if (verify_dw(prog_address, &conf[i], &conf_ignore[i], compare, 1) != 0) {
+					otp_soak(1);
+				} else {
+					pass = 1;
+					break;
+				}
+			} else {
+				pass = 1;
+				break;
+			}
+		}
+		if (pass == 0) {
+			printf("address: %08x, data: %08x, buffer: %08x, mask: %08x\n",
+			       i, data[i], conf[i], conf_ignore[i]);
+			break;
 		}
 	}
+
 	otp_soak(0);
-	return OTP_SUCCESS;
+	if (!pass)
+		return OTP_FAILURE;
 
+	return OTP_SUCCESS;
 }
 
-static int otp_image_verify(uint8_t *src_buf, uint32_t length, uint8_t *digest_buf)
+static int otp_verify_image(u8 *src_buf, u32 length, u8 *digest_buf)
 {
 	sha256_context ctx;
 	u8 digest_ret[CHECKSUM_LEN];
@@ -1556,21 +1665,19 @@
 	sha256_finish(&ctx, digest_ret);
 
 	if (!memcmp(digest_buf, digest_ret, CHECKSUM_LEN))
-		return 0;
-	else
-		return -1;
-
+		return OTP_SUCCESS;
+	return OTP_FAILURE;
 }
 
-static int do_otp_prog(int addr, int nconfirm)
+static int otp_prog_image(int addr, int nconfirm)
 {
 	int ret;
 	int image_version = 0;
 	struct otp_header *otp_header;
 	struct otp_image_layout image_layout;
 	int image_size;
-	uint8_t *buf;
-	uint8_t *checksum;
+	u8 *buf;
+	u8 *checksum;
 
 	otp_header = map_physmem(addr, sizeof(struct otp_header), MAP_WRBACK);
 	if (!otp_header) {
@@ -1587,7 +1694,7 @@
 		puts("Failed to map physical memory\n");
 		return OTP_FAILURE;
 	}
-	otp_header = (struct otp_header *) buf;
+	otp_header = (struct otp_header *)buf;
 	checksum = buf + otp_header->checksum_offset;
 
 	if (strcmp(OTP_MAGIC, (char *)otp_header->otp_magic) != 0) {
@@ -1595,7 +1702,6 @@
 		return OTP_FAILURE;
 	}
 
-
 	image_layout.data_length = (int)(OTP_REGION_SIZE(otp_header->data_info) / 2);
 	image_layout.data = buf + OTP_REGION_OFFSET(otp_header->data_info);
 	image_layout.data_ignore = image_layout.data + image_layout.data_length;
@@ -1607,18 +1713,24 @@
 	image_layout.strap = buf + OTP_REGION_OFFSET(otp_header->strap_info);
 
 	if (!strcmp("A0", (char *)otp_header->otp_version)) {
-		image_version = OTP_AST2600A0;
+		image_version = OTP_A0;
 		image_layout.strap_length = (int)(OTP_REGION_SIZE(otp_header->strap_info) / 3);
 		image_layout.strap_pro = image_layout.strap + image_layout.strap_length;
 		image_layout.strap_ignore = image_layout.strap + 2 * image_layout.strap_length;
 	} else if (!strcmp("A1", (char *)otp_header->otp_version)) {
-		image_version = OTP_AST2600A1;
+		image_version = OTP_A1;
 		image_layout.strap_length = (int)(OTP_REGION_SIZE(otp_header->strap_info) / 4);
 		image_layout.strap_reg_pro = image_layout.strap + image_layout.strap_length;
 		image_layout.strap_pro = image_layout.strap + 2 * image_layout.strap_length;
 		image_layout.strap_ignore = image_layout.strap + 3 * image_layout.strap_length;
 	} else if (!strcmp("A2", (char *)otp_header->otp_version)) {
-		image_version = OTP_AST2600A2;
+		image_version = OTP_A2;
+		image_layout.strap_length = (int)(OTP_REGION_SIZE(otp_header->strap_info) / 4);
+		image_layout.strap_reg_pro = image_layout.strap + image_layout.strap_length;
+		image_layout.strap_pro = image_layout.strap + 2 * image_layout.strap_length;
+		image_layout.strap_ignore = image_layout.strap + 3 * image_layout.strap_length;
+	} else if (!strcmp("A3", (char *)otp_header->otp_version)) {
+		image_version = OTP_A3;
 		image_layout.strap_length = (int)(OTP_REGION_SIZE(otp_header->strap_info) / 4);
 		image_layout.strap_reg_pro = image_layout.strap + image_layout.strap_length;
 		image_layout.strap_pro = image_layout.strap + 2 * image_layout.strap_length;
@@ -1633,7 +1745,7 @@
 		return OTP_FAILURE;
 	}
 
-	if (otp_image_verify(buf, image_size, checksum)) {
+	if (otp_verify_image(buf, image_size, checksum)) {
 		puts("checksum is invalid\n");
 		return OTP_FAILURE;
 	}
@@ -1641,18 +1753,11 @@
 	if (!nconfirm) {
 		if (otp_header->image_info & OTP_INC_DATA) {
 			printf("\nOTP data region :\n");
-			if (otp_print_data_info(&image_layout) < 0) {
+			if (otp_print_data_image(&image_layout) < 0) {
 				printf("OTP data error, please check.\n");
 				return OTP_FAILURE;
 			}
 		}
-		if (otp_header->image_info & OTP_INC_STRAP) {
-			printf("\nOTP strap region :\n");
-			if (otp_print_strap_image(&image_layout) < 0) {
-				printf("OTP strap error, please check.\n");
-				return OTP_FAILURE;
-			}
-		}
 		if (otp_header->image_info & OTP_INC_CONFIG) {
 			printf("\nOTP configuration region :\n");
 			if (otp_print_conf_image(&image_layout) < 0) {
@@ -1660,6 +1765,13 @@
 				return OTP_FAILURE;
 			}
 		}
+		if (otp_header->image_info & OTP_INC_STRAP) {
+			printf("\nOTP strap region :\n");
+			if (otp_print_strap_image(&image_layout) < 0) {
+				printf("OTP strap error, please check.\n");
+				return OTP_FAILURE;
+			}
+		}
 
 		printf("type \"YES\" (no quotes) to continue:\n");
 		if (!confirm_yesno()) {
@@ -1674,9 +1786,8 @@
 		if (ret != 0) {
 			printf("Error\n");
 			return ret;
-		} else {
-			printf("Done\n");
 		}
+		printf("Done\n");
 	}
 	if (otp_header->image_info & OTP_INC_STRAP) {
 		printf("programing strap region ...\n");
@@ -1684,9 +1795,8 @@
 		if (ret != 0) {
 			printf("Error\n");
 			return ret;
-		} else {
-			printf("Done\n");
 		}
+		printf("Done\n");
 	}
 	if (otp_header->image_info & OTP_INC_CONFIG) {
 		printf("programing configuration region ...\n");
@@ -1701,10 +1811,10 @@
 	return OTP_SUCCESS;
 }
 
-static int do_otp_prog_bit(int mode, int otp_dw_offset, int bit_offset, int value, int nconfirm)
+static int otp_prog_bit(int mode, int otp_dw_offset, int bit_offset, int value, int nconfirm)
 {
-	uint32_t read[2];
-	uint32_t prog_address = 0;
+	u32 read[2];
+	u32 prog_address = 0;
 	struct otpstrap_status otpstrap[64];
 	int otp_bit;
 	int ret = 0;
@@ -1712,7 +1822,7 @@
 	otp_soak(0);
 	switch (mode) {
 	case OTP_REGION_CONF:
-		otp_read_config(otp_dw_offset, read);
+		otp_read_conf(otp_dw_offset, read);
 		prog_address = 0x800;
 		prog_address |= (otp_dw_offset / 8) * 0x200;
 		prog_address |= (otp_dw_offset % 8) * 0x2;
@@ -1781,29 +1891,132 @@
 
 	switch (mode) {
 	case OTP_REGION_STRAP:
-		ret =  otp_prog_strap_bit(bit_offset, value);
+		ret =  otp_prog_strap_b(bit_offset, value);
 		break;
 	case OTP_REGION_CONF:
 	case OTP_REGION_DATA:
-		ret = otp_prog_bit(value, prog_address, bit_offset);
+		ret = otp_prog_dc_b(value, prog_address, bit_offset);
 		break;
 	}
 	otp_soak(0);
 	if (ret) {
-		printf("SUCCESS\n");
-		return OTP_SUCCESS;
-	} else {
 		printf("OTP cannot be programed\n");
-		printf("FAILED\n");
+		printf("FAILURE\n");
+		return OTP_FAILURE;
+	}
+
+	printf("SUCCESS\n");
+	return OTP_SUCCESS;
+}
+
+static int otp_update_rid(u32 update_num, int force)
+{
+	u32 otp_rid[2];
+	u32 sw_rid[2];
+	int rid_num = 0;
+	int sw_rid_num = 0;
+	int bit_offset;
+	int dw_offset;
+	int i;
+	int ret;
+
+	otp_read_conf(10, &otp_rid[0]);
+	otp_read_conf(11, &otp_rid[1]);
+
+	sw_rid[0] = readl(SW_REV_ID0);
+	sw_rid[1] = readl(SW_REV_ID1);
+
+	rid_num = get_rid_num(otp_rid);
+	sw_rid_num = get_rid_num(sw_rid);
+
+	if (sw_rid_num < 0) {
+		printf("SW revision id is invalid, please check.\n");
+		return OTP_FAILURE;
+	}
+
+	if (update_num > sw_rid_num) {
+		printf("current SW revision ID: 0x%x\n", sw_rid_num);
+		printf("update number could not bigger than current SW revision id\n");
+		return OTP_FAILURE;
+	}
+
+	if (rid_num < 0) {
+		printf("Currennt OTP revision ID cannot handle by this command,\n"
+		       "plase use 'otp pb' command to update it manually\n");
+		otp_print_revid(otp_rid);
 		return OTP_FAILURE;
 	}
 
-	return OTP_USAGE;
+	printf("current OTP revision ID: 0x%x\n", rid_num);
+	otp_print_revid(otp_rid);
+	printf("input update number: 0x%x\n", update_num);
+
+	if (rid_num > update_num) {
+		printf("OTP rev_id is bigger than 0x%X\n", update_num);
+		printf("Skip\n");
+		return OTP_FAILURE;
+	} else if (rid_num == update_num) {
+		printf("OTP rev_id is same as input\n");
+		printf("Skip\n");
+		return OTP_FAILURE;
+	}
+
+	for (i = rid_num; i < update_num; i++) {
+		if (i < 32) {
+			dw_offset = 0xa;
+			bit_offset = i;
+		} else {
+			dw_offset = 0xb;
+			bit_offset = i - 32;
+		}
+		printf("OTPCFG%X[%d]", dw_offset, bit_offset);
+		if (i + 1 != update_num)
+			printf(", ");
+	}
+
+	printf(" will be programmed\n");
+	if (force == 0) {
+		printf("type \"YES\" (no quotes) to continue:\n");
+		if (!confirm_yesno()) {
+			printf(" Aborting\n");
+			return OTP_FAILURE;
+		}
+	}
+
+	ret = 0;
+	for (i = rid_num; i < update_num; i++) {
+		if (i < 32) {
+			dw_offset = 0xa04;
+			bit_offset = i;
+		} else {
+			dw_offset = 0xa06;
+			bit_offset = i - 32;
+		}
+		if (otp_prog_dc_b(1, dw_offset, bit_offset)) {
+			printf("OTPCFG%X[%d] programming failed\n", dw_offset, bit_offset);
+			ret = OTP_FAILURE;
+			break;
+		}
+	}
+
+	otp_read_conf(10, &otp_rid[0]);
+	otp_read_conf(11, &otp_rid[1]);
+	rid_num = get_rid_num(otp_rid);
+	if (rid_num >= 0)
+		printf("OTP revision ID: 0x%x\n", rid_num);
+	else
+		printf("OTP revision ID\n");
+	otp_print_revid(otp_rid);
+	if (!ret)
+		printf("SUCCESS\n");
+	else
+		printf("FAILED\n");
+	return ret;
 }
 
 static int do_otpread(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
-	uint32_t offset, count;
+	u32 offset, count;
 	int ret;
 
 	if (argc == 4) {
@@ -1816,10 +2029,9 @@
 		return CMD_RET_USAGE;
 	}
 
-
 	if (!strcmp(argv[1], "conf")) {
 		writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
-		ret = otp_print_config(offset, count);
+		ret = otp_print_conf(offset, count);
 	} else if (!strcmp(argv[1], "data")) {
 		writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
 		ret = otp_print_data(offset, count);
@@ -1832,9 +2044,7 @@
 
 	if (ret == OTP_SUCCESS)
 		return CMD_RET_SUCCESS;
-	else
-		return CMD_RET_USAGE;
-
+	return CMD_RET_USAGE;
 }
 
 static int do_otpprog(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
@@ -1847,11 +2057,11 @@
 			return CMD_RET_USAGE;
 		addr = simple_strtoul(argv[2], NULL, 16);
 		writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
-		ret = do_otp_prog(addr, 1);
+		ret = otp_prog_image(addr, 1);
 	} else if (argc == 2) {
 		addr = simple_strtoul(argv[1], NULL, 16);
 		writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
-		ret = do_otp_prog(addr, 0);
+		ret = otp_prog_image(addr, 0);
 	} else {
 		return CMD_RET_USAGE;
 	}
@@ -1923,7 +2133,7 @@
 		return CMD_RET_USAGE;
 
 	writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
-	ret = do_otp_prog_bit(mode, otp_addr, bit_offset, value, nconfirm);
+	ret = otp_prog_bit(mode, otp_addr, bit_offset, value, nconfirm);
 
 	if (ret == OTP_SUCCESS)
 		return CMD_RET_SUCCESS;
@@ -1947,10 +2157,9 @@
 	if (otp_compare(otp_addr, addr) == 0) {
 		printf("Compare pass\n");
 		return CMD_RET_SUCCESS;
-	} else {
-		printf("Compare fail\n");
-		return CMD_RET_FAILURE;
 	}
+	printf("Compare fail\n");
+	return CMD_RET_FAILURE;
 }
 
 static int do_otpinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
@@ -1962,7 +2171,6 @@
 		return CMD_RET_USAGE;
 
 	if (!strcmp(argv[1], "conf")) {
-
 		writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
 		if (argc == 3) {
 			input = simple_strtoul(argv[2], NULL, 16);
@@ -1986,20 +2194,30 @@
 	return CMD_RET_SUCCESS;
 }
 
-static int do_otpprotect(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+static int _do_otpprotect(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[], int preg)
 {
 	int input;
 	int bit_offset;
-	int prog_address;
+	u32 prog_address;
 	int ret;
+	char info[10];
+
+	if (preg) {
+		sprintf(info, "register ");
+		prog_address = 0xe08;
+	} else {
+		info[0] = 0;
+		prog_address = 0xe0c;
+	}
+
 	if (argc != 3 && argc != 2)
 		return CMD_RET_USAGE;
 
-	if (!strcmp(argv[0], "o")) {
+	if (!strcmp(argv[1], "o")) {
 		input = simple_strtoul(argv[2], NULL, 16);
 	} else {
 		input = simple_strtoul(argv[1], NULL, 16);
-		printf("OTPSTRAP[%d] will be protected\n", input);
+		printf("OTPSTRAP[%d] %swill be protected\n", input, info);
 		printf("type \"YES\" (no quotes) to continue:\n");
 		if (!confirm_yesno()) {
 			printf(" Aborting\n");
@@ -2007,42 +2225,114 @@
 		}
 	}
 
-	prog_address = 0x800;
 	if (input < 32) {
 		bit_offset = input;
-		prog_address |= 0x60c;
 	} else if (input < 64) {
 		bit_offset = input - 32;
-		prog_address |= 0x60e;
+		prog_address += 2;
 	} else {
 		return CMD_RET_USAGE;
 	}
 
+	writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
 	if (verify_bit(prog_address, bit_offset, 1) == 0) {
-		printf("OTPSTRAP[%d] already protected\n", input);
+		printf("OTPSTRAP[%d] %salready protected\n", input, info);
+		return CMD_RET_SUCCESS;
 	}
 
-	ret = otp_prog_bit(1, prog_address, bit_offset);
+	ret = otp_prog_dc_b(1, prog_address, bit_offset);
 	otp_soak(0);
 
 	if (ret) {
-		printf("OTPSTRAP[%d] is protected\n", input);
-		return CMD_RET_SUCCESS;
+		printf("Protect OTPSTRAP[%d] %sfail\n", input, info);
+		return CMD_RET_FAILURE;
 	}
 
-	printf("Protect OTPSTRAP[%d] fail\n", input);
-	return CMD_RET_FAILURE;
+	printf("OTPSTRAP[%d] %sis protected\n", input, info);
+	return CMD_RET_SUCCESS;
+}
+
+static int do_otpprotect(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	return _do_otpprotect(cmdtp, flag, argc, argv, 0);
+}
 
+static int do_otprprotect(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	return _do_otpprotect(cmdtp, flag, argc, argv, 1);
 }
 
 static int do_otpver(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
+	printf("SOC OTP version: %s\n", info_cb.ver_name);
 	printf("OTP tool version: %s\n", OTP_VER);
 	printf("OTP info version: %s\n", OTP_INFO_VER);
 
 	return CMD_RET_SUCCESS;
 }
 
+static int do_otpupdate(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	u32 update_num;
+	int force = 0;
+	int ret;
+
+	if (argc == 3) {
+		if (strcmp(argv[1], "o"))
+			return CMD_RET_USAGE;
+		force = 1;
+		update_num = simple_strtoul(argv[2], NULL, 16);
+	} else if (argc == 2) {
+		update_num = simple_strtoul(argv[1], NULL, 16);
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	if (update_num > 64)
+		return CMD_RET_USAGE;
+	writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
+	ret = otp_update_rid(update_num, force);
+	if (ret)
+		return CMD_RET_FAILURE;
+	return CMD_RET_SUCCESS;
+}
+
+static int do_otprid(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	u32 otp_rid[2];
+	u32 sw_rid[2];
+	int rid_num = 0;
+	int sw_rid_num = 0;
+	int ret;
+
+	if (argc != 1)
+		return CMD_RET_USAGE;
+
+	writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
+	otp_read_conf(10, &otp_rid[0]);
+	otp_read_conf(11, &otp_rid[1]);
+
+	sw_rid[0] = readl(SW_REV_ID0);
+	sw_rid[1] = readl(SW_REV_ID1);
+
+	rid_num = get_rid_num(otp_rid);
+	sw_rid_num = get_rid_num(sw_rid);
+
+	printf("current SW revision ID: 0x%x\n", sw_rid_num);
+	if (rid_num >= 0) {
+		printf("current OTP revision ID: 0x%x\n", rid_num);
+		ret = CMD_RET_SUCCESS;
+	} else {
+		printf("Currennt OTP revision ID cannot handle by 'otp update',\n"
+		       "plase use 'otp pb' command to update it manually\n"
+		       "current OTP revision ID\n");
+		ret = CMD_RET_FAILURE;
+	}
+	otp_print_revid(otp_rid);
+
+	return ret;
+}
+
 static cmd_tbl_t cmd_otp[] = {
 	U_BOOT_CMD_MKENT(version, 1, 0, do_otpver, "", ""),
 	U_BOOT_CMD_MKENT(read, 4, 0, do_otpread, "", ""),
@@ -2050,13 +2340,17 @@
 	U_BOOT_CMD_MKENT(prog, 3, 0, do_otpprog, "", ""),
 	U_BOOT_CMD_MKENT(pb, 6, 0, do_otppb, "", ""),
 	U_BOOT_CMD_MKENT(protect, 3, 0, do_otpprotect, "", ""),
+	U_BOOT_CMD_MKENT(rprotect, 3, 0, do_otprprotect, "", ""),
 	U_BOOT_CMD_MKENT(cmp, 3, 0, do_otpcmp, "", ""),
+	U_BOOT_CMD_MKENT(update, 3, 0, do_otpupdate, "", ""),
+	U_BOOT_CMD_MKENT(rid, 1, 0, do_otprid, "", ""),
 };
 
 static int do_ast_otp(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
 	cmd_tbl_t *cp;
-	uint32_t ver;
+	u32 ver;
+	int ret;
 
 	cp = find_cmd_tbl(argv[1], cmd_otp, ARRAY_SIZE(cmd_otp));
 
@@ -2064,59 +2358,76 @@
 	argc--;
 	argv++;
 
-	if (cp == NULL || argc > cp->maxargs)
+	if (!cp || argc > cp->maxargs)
 		return CMD_RET_USAGE;
 	if (flag == CMD_FLAG_REPEAT && !cmd_is_repeatable(cp))
 		return CMD_RET_SUCCESS;
 
 	ver = chip_version();
 	switch (ver) {
-	case OTP_AST2600A0:
-		info_cb.version = OTP_AST2600A0;
+	case OTP_A0:
+		info_cb.version = OTP_A0;
 		info_cb.conf_info = a0_conf_info;
 		info_cb.conf_info_len = ARRAY_SIZE(a0_conf_info);
 		info_cb.strap_info = a0_strap_info;
 		info_cb.strap_info_len = ARRAY_SIZE(a0_strap_info);
 		info_cb.key_info = a0_key_type;
 		info_cb.key_info_len = ARRAY_SIZE(a0_key_type);
+		sprintf(info_cb.ver_name, "A0");
 		break;
-	case OTP_AST2600A1:
-		info_cb.version = OTP_AST2600A1;
+	case OTP_A1:
+		info_cb.version = OTP_A1;
 		info_cb.conf_info = a1_conf_info;
 		info_cb.conf_info_len = ARRAY_SIZE(a1_conf_info);
 		info_cb.strap_info = a1_strap_info;
 		info_cb.strap_info_len = ARRAY_SIZE(a1_strap_info);
 		info_cb.key_info = a1_key_type;
 		info_cb.key_info_len = ARRAY_SIZE(a1_key_type);
+		sprintf(info_cb.ver_name, "A1");
 		break;
-	case OTP_AST2600A2:
-		info_cb.version = OTP_AST2600A2;
+	case OTP_A2:
+		info_cb.version = OTP_A2;
 		info_cb.conf_info = a2_conf_info;
 		info_cb.conf_info_len = ARRAY_SIZE(a2_conf_info);
 		info_cb.strap_info = a2_strap_info;
 		info_cb.strap_info_len = ARRAY_SIZE(a2_strap_info);
+		info_cb.key_info = a2_key_type;
+		info_cb.key_info_len = ARRAY_SIZE(a2_key_type);
+		sprintf(info_cb.ver_name, "A2");
+		break;
+	case OTP_A3:
+		info_cb.version = OTP_A3;
+		info_cb.conf_info = a3_conf_info;
+		info_cb.conf_info_len = ARRAY_SIZE(a3_conf_info);
+		info_cb.strap_info = a3_strap_info;
+		info_cb.strap_info_len = ARRAY_SIZE(a3_strap_info);
 		info_cb.key_info = a3_key_type;
 		info_cb.key_info_len = ARRAY_SIZE(a3_key_type);
+		sprintf(info_cb.ver_name, "A3");
 		break;
 	default:
 		printf("SOC is not supported\n");
 		return CMD_RET_FAILURE;
 	}
 
-	return cp->cmd(cmdtp, flag, argc, argv);
+	ret = cp->cmd(cmdtp, flag, argc, argv);
+	writel(1, OTP_PROTECT_KEY); //password
+
+	return ret;
 }
 
-U_BOOT_CMD(
-	otp, 7, 0,  do_ast_otp,
-	"ASPEED One-Time-Programmable sub-system",
-	"version\n"
-	"otp read conf|data <otp_dw_offset> <dw_count>\n"
-	"otp read strap <strap_bit_offset> <bit_count>\n"
-	"otp info strap [v]\n"
-	"otp info conf [otp_dw_offset]\n"
-	"otp prog [o] <addr>\n"
-	"otp pb conf|data [o] <otp_dw_offset> <bit_offset> <value>\n"
-	"otp pb strap [o] <bit_offset> <value>\n"
-	"otp protect [o] <bit_offset>\n"
-	"otp cmp <addr> <otp_dw_offset>\n"
-);
+U_BOOT_CMD(otp, 7, 0,  do_ast_otp,
+	   "ASPEED One-Time-Programmable sub-system",
+	   "version\n"
+	   "otp read conf|data <otp_dw_offset> <dw_count>\n"
+	   "otp read strap <strap_bit_offset> <bit_count>\n"
+	   "otp info strap [v]\n"
+	   "otp info conf [otp_dw_offset]\n"
+	   "otp prog [o] <addr>\n"
+	   "otp pb conf|data [o] <otp_dw_offset> <bit_offset> <value>\n"
+	   "otp pb strap [o] <bit_offset> <value>\n"
+	   "otp protect [o] <bit_offset>\n"
+	   "otp rprotect [o] <bit_offset>\n"
+	   "otp update [o] <revision_id>\n"
+	   "otp rid\n"
+	  );
--- uboot_org/cmd/otp_info.h	2021-09-08 15:15:33.721846998 +0800
+++ uboot/cmd/otp_info.h	2021-09-08 16:34:05.539892636 +0800
@@ -3,7 +3,7 @@
  * Do not edit it.
  */
 
-#define OTP_INFO_VER		"1.0.1"
+#define OTP_INFO_VER		"1.1.0"
 #define OTP_REG_RESERVED	-1
 #define OTP_REG_VALUE		-2
 #define OTP_REG_VALID_BIT	-3
@@ -54,8 +54,8 @@
 	{ 15, 1, 1, "CPU/AXI clock ratio : 1:1" },
 	{ 16, 1, 0, "Enable ARM JTAG debug" },
 	{ 16, 1, 1, "Disable ARM JTAG debug" },
-	{ 17, 1, 0, "VGA class code : video_device" },
-	{ 17, 1, 1, "VGA class code : vga_device" },
+	{ 17, 1, 0, "VGA class code : vga_device" },
+	{ 17, 1, 1, "VGA class code : video_device" },
 	{ 18, 1, 0, "Enable debug interfaces 0" },
 	{ 18, 1, 1, "Disable debug interfaces 0" },
 	{ 19, 1, 0, "Boot from eMMC speed mode : normal" },
@@ -158,7 +158,7 @@
 	{ 6, 1, 0, "MAC 2 : RMII/NCSI" },
 	{ 6, 1, 1, "MAC 2 : RGMII" },
 	{ 7, 3, 0, "CPU Frequency : 1.2GHz" },
-	{ 7, 3, 1, "CPU Frequency : 1.6MHz" },
+	{ 7, 3, 1, "CPU Frequency : 1.6GHz" },
 	{ 7, 3, 2, "CPU Frequency : 1.2GHz" },
 	{ 7, 3, 3, "CPU Frequency : 1.6GHz" },
 	{ 7, 3, 4, "CPU Frequency : 800MHz" },
@@ -173,12 +173,13 @@
 	{ 12, 2, 1, "VGA memory size : 16MB" },
 	{ 12, 2, 2, "VGA memory size : 32MB" },
 	{ 12, 2, 3, "VGA memory size : 64MB" },
+	{ 14, 1, OTP_REG_RESERVED, "Reserved" },
 	{ 15, 1, 0, "CPU/AXI clock ratio : 2:1" },
 	{ 15, 1, 1, "CPU/AXI clock ratio : 1:1" },
 	{ 16, 1, 0, "Enable ARM JTAG debug" },
 	{ 16, 1, 1, "Disable ARM JTAG debug" },
-	{ 17, 1, 0, "VGA class code : video_device" },
-	{ 17, 1, 1, "VGA class code : vga_device" },
+	{ 17, 1, 0, "VGA class code : vga_device" },
+	{ 17, 1, 1, "VGA class code : video_device" },
 	{ 18, 1, 0, "Enable debug interfaces 0" },
 	{ 18, 1, 1, "Disable debug interfaces 0" },
 	{ 19, 1, 0, "Boot from eMMC speed mode : normal" },
@@ -197,8 +198,13 @@
 	{ 25, 2, 1, "Internal bridge speed selection : 1/2x" },
 	{ 25, 2, 2, "Internal bridge speed selection : 1/4x" },
 	{ 25, 2, 3, "Internal bridge speed selection : 1/8x" },
+	{ 27, 2, 0, "Reset Source of eMMC part : GPIOY3" },
+	{ 27, 2, 1, "Reset Source of eMMC part : GPIO18A2" },
+	{ 27, 2, 2, "Reset Source of eMMC part : GPIO18B6" },
+	{ 27, 2, 3, "Reset Source of eMMC part : GPIO18A2" },
 	{ 29, 1, 0, "Enable RVAS function" },
 	{ 29, 1, 1, "Disable RVAS function" },
+	{ 30, 2, OTP_REG_RESERVED, "Reserved" },
 	{ 32, 1, 0, "MAC 3 : RMII/NCSI" },
 	{ 32, 1, 1, "MAC 3 : RGMII" },
 	{ 33, 1, 0, "MAC 4 : RMII/NCSI" },
@@ -261,8 +267,10 @@
 	{ 59, 1, 1, "Enable host SPI auxiliary control pins" },
 	{ 60, 1, 0, "Disable GPIO pass through" },
 	{ 60, 1, 1, "Enable GPIO pass through" },
+	{ 61, 1, OTP_REG_RESERVED, "Reserved" },
 	{ 62, 1, 0, "Disable dedicate GPIO strap pins" },
-	{ 62, 1, 1, "Enable dedicate GPIO strap pins" }
+	{ 62, 1, 1, "Enable dedicate GPIO strap pins" },
+	{ 63, 1, OTP_REG_RESERVED, "Reserved" }
 };
 
 static const struct otpstrap_info a2_strap_info[] = {
@@ -281,7 +289,7 @@
 	{ 6, 1, 0, "MAC 2 : RMII/NCSI" },
 	{ 6, 1, 1, "MAC 2 : RGMII" },
 	{ 7, 3, 0, "CPU Frequency : 1.2GHz" },
-	{ 7, 3, 1, "CPU Frequency : 1.6MHz" },
+	{ 7, 3, 1, "CPU Frequency : 1.6GHz" },
 	{ 7, 3, 2, "CPU Frequency : 1.2GHz" },
 	{ 7, 3, 3, "CPU Frequency : 1.6GHz" },
 	{ 7, 3, 4, "CPU Frequency : 800MHz" },
@@ -296,12 +304,13 @@
 	{ 12, 2, 1, "VGA memory size : 16MB" },
 	{ 12, 2, 2, "VGA memory size : 32MB" },
 	{ 12, 2, 3, "VGA memory size : 64MB" },
+	{ 14, 1, OTP_REG_RESERVED, "Reserved" },
 	{ 15, 1, 0, "CPU/AXI clock ratio : 2:1" },
 	{ 15, 1, 1, "CPU/AXI clock ratio : 1:1" },
 	{ 16, 1, 0, "Enable ARM JTAG debug" },
 	{ 16, 1, 1, "Disable ARM JTAG debug" },
-	{ 17, 1, 0, "VGA class code : video_device" },
-	{ 17, 1, 1, "VGA class code : vga_device" },
+	{ 17, 1, 0, "VGA class code : vga_device" },
+	{ 17, 1, 1, "VGA class code : video_device" },
 	{ 18, 1, 0, "Enable debug interfaces 0" },
 	{ 18, 1, 1, "Disable debug interfaces 0" },
 	{ 19, 1, 0, "Boot from eMMC speed mode : normal" },
@@ -320,8 +329,13 @@
 	{ 25, 2, 1, "Internal bridge speed selection : 1/2x" },
 	{ 25, 2, 2, "Internal bridge speed selection : 1/4x" },
 	{ 25, 2, 3, "Internal bridge speed selection : 1/8x" },
+	{ 27, 2, 0, "Reset Source of eMMC part : GPIOY3" },
+	{ 27, 2, 1, "Reset Source of eMMC part : GPIO18A2" },
+	{ 27, 2, 2, "Reset Source of eMMC part : GPIO18B6" },
+	{ 27, 2, 3, "Reset Source of eMMC part : GPIO18A2" },
 	{ 29, 1, 0, "Enable RVAS function" },
 	{ 29, 1, 1, "Disable RVAS function" },
+	{ 30, 2, OTP_REG_RESERVED, "Reserved" },
 	{ 32, 1, 0, "MAC 3 : RMII/NCSI" },
 	{ 32, 1, 1, "MAC 3 : RGMII" },
 	{ 33, 1, 0, "MAC 4 : RMII/NCSI" },
@@ -384,8 +398,141 @@
 	{ 59, 1, 1, "Enable host SPI auxiliary control pins" },
 	{ 60, 1, 0, "Disable GPIO pass through" },
 	{ 60, 1, 1, "Enable GPIO pass through" },
+	{ 61, 1, OTP_REG_RESERVED, "Reserved" },
 	{ 62, 1, 0, "Disable dedicate GPIO strap pins" },
-	{ 62, 1, 1, "Enable dedicate GPIO strap pins" }
+	{ 62, 1, 1, "Enable dedicate GPIO strap pins" },
+	{ 63, 1, OTP_REG_RESERVED, "Reserved" }
+};
+
+static const struct otpstrap_info a3_strap_info[] = {
+	{ 0, 1, 0, "Disable Secure Boot" },
+	{ 0, 1, 1, "Enable Secure Boot" },
+	{ 1, 1, 0, "Disable boot from eMMC" },
+	{ 1, 1, 1, "Enable boot from eMMC" },
+	{ 2, 1, 0, "Disable Boot from debug SPI" },
+	{ 2, 1, 1, "Enable Boot from debug SPI" },
+	{ 3, 1, 0, "Enable ARM CM3" },
+	{ 3, 1, 1, "Disable ARM CM3" },
+	{ 4, 1, 0, "No VGA BIOS ROM, VGA BIOS is merged in the system BIOS" },
+	{ 4, 1, 1, "Enable dedicated VGA BIOS ROM" },
+	{ 5, 1, 0, "MAC 1 : RMII/NCSI" },
+	{ 5, 1, 1, "MAC 1 : RGMII" },
+	{ 6, 1, 0, "MAC 2 : RMII/NCSI" },
+	{ 6, 1, 1, "MAC 2 : RGMII" },
+	{ 7, 3, 0, "CPU Frequency : 1.2GHz" },
+	{ 7, 3, 1, "CPU Frequency : 1.6GHz" },
+	{ 7, 3, 2, "CPU Frequency : 1.2GHz" },
+	{ 7, 3, 3, "CPU Frequency : 1.6GHz" },
+	{ 7, 3, 4, "CPU Frequency : 800MHz" },
+	{ 7, 3, 5, "CPU Frequency : 800MHz" },
+	{ 7, 3, 6, "CPU Frequency : 800MHz" },
+	{ 7, 3, 7, "CPU Frequency : 800MHz" },
+	{ 10, 2, 0, "HCLK ratio AXI:AHB = default" },
+	{ 10, 2, 1, "HCLK ratio AXI:AHB = 2:1" },
+	{ 10, 2, 2, "HCLK ratio AXI:AHB = 3:1" },
+	{ 10, 2, 3, "HCLK ratio AXI:AHB = 4:1" },
+	{ 12, 2, 0, "VGA memory size : 8MB" },
+	{ 12, 2, 1, "VGA memory size : 16MB" },
+	{ 12, 2, 2, "VGA memory size : 32MB" },
+	{ 12, 2, 3, "VGA memory size : 64MB" },
+	{ 14, 1, OTP_REG_RESERVED, "Reserved" },
+	{ 15, 1, 0, "CPU/AXI clock ratio : 2:1" },
+	{ 15, 1, 1, "CPU/AXI clock ratio : 1:1" },
+	{ 16, 1, 0, "Enable ARM JTAG debug" },
+	{ 16, 1, 1, "Disable ARM JTAG debug" },
+	{ 17, 1, 0, "VGA class code : vga_device" },
+	{ 17, 1, 1, "VGA class code : video_device" },
+	{ 18, 1, 0, "Enable debug interfaces 0" },
+	{ 18, 1, 1, "Disable debug interfaces 0" },
+	{ 19, 1, 0, "Boot from eMMC speed mode : normal" },
+	{ 19, 1, 1, "Boot from eMMC speed mode : high" },
+	{ 20, 1, 0, "Disable Pcie EHCI device" },
+	{ 20, 1, 1, "Enable Pcie EHCI device" },
+	{ 21, 1, 0, "Enable ARM JTAG trust world debug" },
+	{ 21, 1, 1, "Disable ARM JTAG trust world debug" },
+	{ 22, 1, 0, "Normal BMC mode" },
+	{ 22, 1, 1, "Disable dedicated BMC functions for non-BMC application" },
+	{ 23, 1, 0, "SSPRST# pin is for secondary processor dedicated reset pin" },
+	{ 23, 1, 1, "SSPRST# pin is for PCIE root complex dedicated reset pin" },
+	{ 24, 1, 0, "Enable watchdog to reset full chip" },
+	{ 24, 1, 1, "Disable watchdog to reset full chip" },
+	{ 25, 2, 0, "Internal bridge speed selection : 1x" },
+	{ 25, 2, 1, "Internal bridge speed selection : 1/2x" },
+	{ 25, 2, 2, "Internal bridge speed selection : 1/4x" },
+	{ 25, 2, 3, "Internal bridge speed selection : 1/8x" },
+	{ 27, 2, 0, "Reset Source of eMMC part : GPIOY3" },
+	{ 27, 2, 1, "Reset Source of eMMC part : GPIO18A2" },
+	{ 27, 2, 2, "Reset Source of eMMC part : GPIO18B6" },
+	{ 27, 2, 3, "Reset Source of eMMC part : GPIO18A2" },
+	{ 29, 1, 0, "Enable RVAS function" },
+	{ 29, 1, 1, "Disable RVAS function" },
+	{ 30, 2, OTP_REG_RESERVED, "Reserved" },
+	{ 32, 1, 0, "MAC 3 : RMII/NCSI" },
+	{ 32, 1, 1, "MAC 3 : RGMII" },
+	{ 33, 1, 0, "MAC 4 : RMII/NCSI" },
+	{ 33, 1, 1, "MAC 4 : RGMII" },
+	{ 34, 1, 0, "SuperIO configuration address : 0x2e" },
+	{ 34, 1, 1, "SuperIO configuration address : 0x4e" },
+	{ 35, 1, 0, "Enable LPC to decode SuperIO" },
+	{ 35, 1, 1, "Disable LPC to decode SuperIO" },
+	{ 36, 1, 0, "Enable debug interfaces 1" },
+	{ 36, 1, 1, "Disable debug interfaces 1" },
+	{ 37, 1, 0, "Disable ACPI function" },
+	{ 37, 1, 1, "Enable ACPI function" },
+	{ 38, 1, 0, "Select LPC/eSPI : eSPI" },
+	{ 38, 1, 1, "Select LPC/eSPI : LPC" },
+	{ 39, 1, 0, "Disable SAFS mode" },
+	{ 39, 1, 1, "Enable SAFS mode" },
+	{ 40, 1, 0, "Disable boot from uart5" },
+	{ 40, 1, 1, "Enable boot from uart5" },
+	{ 41, 1, 0, "Disable boot SPI 3B address mode auto-clear" },
+	{ 41, 1, 1, "Enable boot SPI 3B address mode auto-clear" },
+	{ 42, 1, 0, "Disable boot SPI 3B/4B address mode auto detection" },
+	{ 42, 1, 1, "Enable boot SPI 3B/4B address mode auto detection" },
+	{ 43, 1, 0, "Disable boot SPI or eMMC ABR" },
+	{ 43, 1, 1, "Enable boot SPI or eMMC ABR" },
+	{ 44, 1, 0, "Boot SPI ABR Mode : dual" },
+	{ 44, 1, 1, "Boot SPI ABR Mode : single" },
+	{ 45, 3, 0, "Boot SPI flash size : 0MB" },
+	{ 45, 3, 1, "Boot SPI flash size : 2MB" },
+	{ 45, 3, 2, "Boot SPI flash size : 4MB" },
+	{ 45, 3, 3, "Boot SPI flash size : 8MB" },
+	{ 45, 3, 4, "Boot SPI flash size : 16MB" },
+	{ 45, 3, 5, "Boot SPI flash size : 32MB" },
+	{ 45, 3, 6, "Boot SPI flash size : 64MB" },
+	{ 45, 3, 7, "Boot SPI flash size : 128MB" },
+	{ 48, 1, 0, "Disable host SPI ABR" },
+	{ 48, 1, 1, "Enable host SPI ABR" },
+	{ 49, 1, 0, "Disable host SPI ABR mode select pin" },
+	{ 49, 1, 1, "Enable host SPI ABR mode select pin" },
+	{ 50, 1, 0, "Host SPI ABR mode : dual" },
+	{ 50, 1, 1, "Host SPI ABR mode : single" },
+	{ 51, 3, 0, "Host SPI flash size : 0MB" },
+	{ 51, 3, 1, "Host SPI flash size : 2MB" },
+	{ 51, 3, 2, "Host SPI flash size : 4MB" },
+	{ 51, 3, 3, "Host SPI flash size : 8MB" },
+	{ 51, 3, 4, "Host SPI flash size : 16MB" },
+	{ 51, 3, 5, "Host SPI flash size : 32MB" },
+	{ 51, 3, 6, "Host SPI flash size : 64MB" },
+	{ 51, 3, 7, "Host SPI flash size : 128MB" },
+	{ 54, 1, 0, "Disable boot SPI auxiliary control pins" },
+	{ 54, 1, 1, "Enable boot SPI auxiliary control pins" },
+	{ 55, 2, 0, "Boot SPI CRTM size : 0KB" },
+	{ 55, 2, 1, "Boot SPI CRTM size : 256KB" },
+	{ 55, 2, 2, "Boot SPI CRTM size : 512KB" },
+	{ 55, 2, 3, "Boot SPI CRTM size : 1024KB" },
+	{ 57, 2, 0, "Host SPI CRTM size : 0KB" },
+	{ 57, 2, 1, "Host SPI CRTM size : 1024KB" },
+	{ 57, 2, 2, "Host SPI CRTM size : 2048KB" },
+	{ 57, 2, 3, "Host SPI CRTM size : 4096KB" },
+	{ 59, 1, 0, "Disable host SPI auxiliary control pins" },
+	{ 59, 1, 1, "Enable host SPI auxiliary control pins" },
+	{ 60, 1, 0, "Disable GPIO pass through" },
+	{ 60, 1, 1, "Enable GPIO pass through" },
+	{ 61, 1, OTP_REG_RESERVED, "Reserved" },
+	{ 62, 1, 0, "Disable dedicate GPIO strap pins" },
+	{ 62, 1, 1, "Enable dedicate GPIO strap pins" },
+	{ 63, 1, OTP_REG_RESERVED, "Reserved" }
 };
 
 static const struct otpconf_info a0_conf_info[] = {
@@ -436,7 +583,6 @@
 	{ 4, 0, 8, OTP_REG_VALID_BIT, "Keys retire : %s" },
 	{ 5, 0, 32, OTP_REG_VALUE, "User define data, random number low : 0x%x" },
 	{ 6, 0, 32, OTP_REG_VALUE, "User define data, random number high : 0x%x" },
-	{ 10, 0, 64, OTP_REG_VALUE, "Manifest ID : 0x%x" },
 	{ 14, 0, 11, OTP_REG_VALUE, "Patch code location (DW): 0x%x" },
 	{ 14, 11, 6, OTP_REG_VALUE, "Patch code size (DW): 0x%x" }
 };
@@ -462,6 +608,66 @@
 	{ 0, 12, 2, 1, "SHA mode : SHA256" },
 	{ 0, 12, 2, 2, "SHA mode : SHA384" },
 	{ 0, 12, 2, 3, "SHA mode : SHA512" },
+	{ 0, 14, 1, 0, "Disable patch code" },
+	{ 0, 14, 1, 1, "Enable patch code" },
+	{ 0, 15, 1, 0, "Enable Boot from Uart" },
+	{ 0, 15, 1, 1, "Disable Boot from Uart" },
+	{ 0, 16, 6, OTP_REG_VALUE, "Secure Region size (DW): 0x%x" },
+	{ 0, 22, 1, 0, "Secure Region : Writable" },
+	{ 0, 22, 1, 1, "Secure Region : Write Protect" },
+	{ 0, 23, 1, 0, "User Region : Writable" },
+	{ 0, 23, 1, 1, "User Region : Write Protect" },
+	{ 0, 24, 1, 0, "Configure Region : Writable" },
+	{ 0, 24, 1, 1, "Configure Region : Write Protect" },
+	{ 0, 25, 1, 0, "OTP strap Region : Writable" },
+	{ 0, 25, 1, 1, "OTP strap Region : Write Protect" },
+	{ 0, 26, 1, 0, "Disable Copy Boot Image to Internal SRAM" },
+	{ 0, 26, 1, 1, "Copy Boot Image to Internal SRAM" },
+	{ 0, 27, 1, 0, "Disable image encryption" },
+	{ 0, 27, 1, 1, "Enable image encryption" },
+	{ 0, 29, 1, 0, "OTP key retire Region : Writable" },
+	{ 0, 29, 1, 1, "OTP key retire Region : Write Protect" },
+	{ 0, 31, 1, 0, "OTP memory lock disable" },
+	{ 0, 31, 1, 1, "OTP memory lock enable" },
+	{ 2, 0, 16, OTP_REG_VALUE, "Vender ID : 0x%x" },
+	{ 2, 16, 16, OTP_REG_VALUE, "Key Revision : 0x%x" },
+	{ 3, 0, 16, OTP_REG_VALUE, "Secure boot header offset : 0x%x" },
+	{ 4, 0, 8, OTP_REG_VALID_BIT, "Keys retire : %s" },
+	{ 5, 0, 32, OTP_REG_VALUE, "User define data, random number low : 0x%x" },
+	{ 6, 0, 32, OTP_REG_VALUE, "User define data, random number high : 0x%x" },
+	{ 7, 0, 15, OTP_REG_VALUE, "SCU0C8[14:0] auto setting : 0x%x" },
+	{ 7, 16, 15, OTP_REG_VALUE, "SCU0D8[14:0] auto setting : 0x%x" },
+	{ 7, 31, 1, 0, "Disable chip security setting" },
+	{ 7, 31, 1, 1, "Enable chip security setting" },
+	{ 14, 0, 11, OTP_REG_VALUE, "Patch code location (DW): 0x%x" },
+	{ 14, 11, 6, OTP_REG_VALUE, "Patch code size (DW): 0x%x" }
+};
+
+static const struct otpconf_info a2_conf_info[] = {
+	{ 0, 0, 1, 0, "Enable OTP Memory BIST Mode" },
+	{ 0, 0, 1, 1, "Disable OTP Memory BIST Mode" },
+	{ 0, 1, 1, 0, "Disable Secure Boot" },
+	{ 0, 1, 1, 1, "Enable Secure Boot" },
+	{ 0, 3, 1, 0, "User region ECC disable" },
+	{ 0, 3, 1, 1, "User region ECC enable" },
+	{ 0, 4, 1, 0, "Secure Region ECC disable" },
+	{ 0, 4, 1, 1, "Secure Region ECC enable" },
+	{ 0, 5, 1, 0, "Enable low security key" },
+	{ 0, 5, 1, 1, "Disable low security key" },
+	{ 0, 6, 1, 0, "Do not ignore Secure Boot hardware strap" },
+	{ 0, 6, 1, 1, "Ignore Secure Boot hardware strap" },
+	{ 0, 7, 1, 0, "Secure Boot Mode: Mode_GCM" },
+	{ 0, 7, 1, 1, "Secure Boot Mode: Mode_2" },
+	{ 0, 9, 1, 0, "ROM code will dump boot messages" },
+	{ 0, 9, 1, 1, "ROM code message is disabled" },
+	{ 0, 10, 2, 0, "RSA mode : RSA1024" },
+	{ 0, 10, 2, 1, "RSA mode : RSA2048" },
+	{ 0, 10, 2, 2, "RSA mode : RSA3072" },
+	{ 0, 10, 2, 3, "RSA mode : RSA4096" },
+	{ 0, 12, 2, 0, "SHA mode : SHA224" },
+	{ 0, 12, 2, 1, "SHA mode : SHA256" },
+	{ 0, 12, 2, 2, "SHA mode : SHA384" },
+	{ 0, 12, 2, 3, "SHA mode : SHA512" },
 	{ 0, 14, 1, 0, "Enable patch code" },
 	{ 0, 14, 1, 1, "Disable patch code" },
 	{ 0, 15, 1, 0, "Enable Boot from Uart" },
@@ -479,24 +685,47 @@
 	{ 0, 26, 1, 1, "Copy Boot Image to Internal SRAM" },
 	{ 0, 27, 1, 0, "Disable image encryption" },
 	{ 0, 27, 1, 1, "Enable image encryption" },
+	{ 0, 28, 1, 0, "Enable Flash Patch Code" },
+	{ 0, 28, 1, 1, "Disable Flash Patch Code" },
 	{ 0, 29, 1, 0, "OTP key retire Region : Writable" },
 	{ 0, 29, 1, 1, "OTP key retire Region : Write Protect" },
+	{ 0, 30, 1, 0, "Boot from UART/VUART when normal boot is fail" },
+	{ 0, 30, 1, 1, "Disable auto UART/VUART boot option" },
 	{ 0, 31, 1, 0, "OTP memory lock disable" },
 	{ 0, 31, 1, 1, "OTP memory lock enable" },
 	{ 2, 0, 16, OTP_REG_VALUE, "Vender ID : 0x%x" },
 	{ 2, 16, 16, OTP_REG_VALUE, "Key Revision : 0x%x" },
 	{ 3, 0, 16, OTP_REG_VALUE, "Secure boot header offset : 0x%x" },
+	{ 3, 16, 1, 0, "Boot from UART using: UART5" },
+	{ 3, 16, 1, 1, "Boot from UART using: UART1" },
+	{ 3, 17, 1, 0, "Enable Auto Boot from UART" },
+	{ 3, 17, 1, 1, "Disable Auto Boot from UART" },
+	{ 3, 18, 1, 0, "Enable Auto Boot from VUART2 over PCIE" },
+	{ 3, 18, 1, 1, "Disable Auto Boot from VUART2 over PCIE" },
+	{ 3, 19, 1, 0, "Enable Auto Boot from VUART2 over LPC" },
+	{ 3, 19, 1, 1, "Disable Auto Boot from VUART2 over LPC" },
+	{ 3, 20, 1, 0, "Enable ROM code based programming control" },
+	{ 3, 20, 1, 1, "Disable ROM code based programming control" },
+	{ 3, 21, 3, OTP_REG_VALUE, "Rollback prevention shift bit : 0x%x" },
+	{ 3, 24, 6, OTP_REG_VALUE, "Extra Data Write Protection Region size (DW): 0x%x" },
+	{ 3, 30, 1, 0, "Do not erase signature data after secure boot check" },
+	{ 3, 30, 1, 1, "Erase signature data after secure boot check" },
+	{ 3, 31, 1, 0, "Do not erase RSA public key after secure boot check" },
+	{ 3, 31, 1, 1, "Erase RSA public key after secure boot check" },
 	{ 4, 0, 8, OTP_REG_VALID_BIT, "Keys retire : %s" },
 	{ 5, 0, 32, OTP_REG_VALUE, "User define data, random number low : 0x%x" },
 	{ 6, 0, 32, OTP_REG_VALUE, "User define data, random number high : 0x%x" },
-	{ 10, 0, 64, OTP_REG_VALUE, "Manifest ID : 0x%x" },
+	{ 7, 0, 15, OTP_REG_VALUE, "SCU0C8[14:0] auto setting : 0x%x" },
+	{ 7, 16, 15, OTP_REG_VALUE, "SCU0D8[14:0] auto setting : 0x%x" },
+	{ 7, 31, 1, 0, "Disable chip security setting" },
+	{ 7, 31, 1, 1, "Enable chip security setting" },
 	{ 14, 0, 11, OTP_REG_VALUE, "Patch code location (DW): 0x%x" },
 	{ 14, 11, 6, OTP_REG_VALUE, "Patch code size (DW): 0x%x" }
 };
 
-static const struct otpconf_info a2_conf_info[] = {
-	{ 0, 1, 1, 0, "Enable OTP Memory BIST Mode" },
-	{ 0, 1, 1, 1, "Disable OTP Memory BIST Mode" },
+static const struct otpconf_info a3_conf_info[] = {
+	{ 0, 0, 1, 0, "Enable OTP Memory BIST Mode" },
+	{ 0, 0, 1, 1, "Disable OTP Memory BIST Mode" },
 	{ 0, 1, 1, 0, "Disable Secure Boot" },
 	{ 0, 1, 1, 1, "Enable Secure Boot" },
 	{ 0, 3, 1, 0, "User region ECC disable" },
@@ -536,6 +765,8 @@
 	{ 0, 26, 1, 1, "Copy Boot Image to Internal SRAM" },
 	{ 0, 27, 1, 0, "Disable image encryption" },
 	{ 0, 27, 1, 1, "Enable image encryption" },
+	{ 0, 28, 1, 0, "Enable Flash Patch Code" },
+	{ 0, 28, 1, 1, "Disable Flash Patch Code" },
 	{ 0, 29, 1, 0, "OTP key retire Region : Writable" },
 	{ 0, 29, 1, 1, "OTP key retire Region : Write Protect" },
 	{ 0, 30, 1, 0, "Boot from UART/VUART when normal boot is fail" },
@@ -547,8 +778,8 @@
 	{ 3, 0, 16, OTP_REG_VALUE, "Secure boot header offset : 0x%x" },
 	{ 3, 16, 1, 0, "Boot from UART using: UART5" },
 	{ 3, 16, 1, 1, "Boot from UART using: UART1" },
-	{ 3, 17, 1, 0, "Enable Auto Boot from UART or VUART" },
-	{ 3, 17, 1, 1, "Disable Auto Boot from UART or VUART" },
+	{ 3, 17, 1, 0, "Enable Auto Boot from UART" },
+	{ 3, 17, 1, 1, "Disable Auto Boot from UART" },
 	{ 3, 18, 1, 0, "Enable Auto Boot from VUART2 over PCIE" },
 	{ 3, 18, 1, 1, "Disable Auto Boot from VUART2 over PCIE" },
 	{ 3, 19, 1, 0, "Enable Auto Boot from VUART2 over LPC" },
@@ -564,7 +795,12 @@
 	{ 4, 0, 8, OTP_REG_VALID_BIT, "Keys retire : %s" },
 	{ 5, 0, 32, OTP_REG_VALUE, "User define data, random number low : 0x%x" },
 	{ 6, 0, 32, OTP_REG_VALUE, "User define data, random number high : 0x%x" },
-	{ 10, 0, 64, OTP_REG_VALUE, "Manifest ID : 0x%x" },
+	{ 7, 0, 15, OTP_REG_VALUE, "SCU0C8[14:0] auto setting : 0x%x" },
+	{ 7, 15, 1, 0, "Disable write protection for SCU0C8 and SCU0D8" },
+	{ 7, 15, 1, 1, "Enable write protection for SCU0C8 and SCU0D8" },
+	{ 7, 16, 15, OTP_REG_VALUE, "SCU0D8[14:0] auto setting : 0x%x" },
+	{ 7, 31, 1, 0, "Disable chip security setting" },
+	{ 7, 31, 1, 1, "Enable chip security setting" },
 	{ 14, 0, 11, OTP_REG_VALUE, "Patch code location (DW): 0x%x" },
 	{ 14, 11, 6, OTP_REG_VALUE, "Patch code size (DW): 0x%x" }
 };
