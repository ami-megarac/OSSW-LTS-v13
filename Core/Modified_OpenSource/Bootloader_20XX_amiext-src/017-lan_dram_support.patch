diff -Naur uboot/include/_exports.h uboot-new/include/_exports.h
--- uboot/include/_exports.h	2021-01-06 11:22:28.497594276 -0500
+++ uboot-new/include/_exports.h	2021-01-06 11:27:29.986288150 -0500
@@ -13,6 +13,7 @@
 	EXPORT_FUNC(putc, void, putc, const char)
 	EXPORT_FUNC(puts, void, puts, const char *)
 	EXPORT_FUNC(printf, int, printf, const char*, ...)
+	EXPORT_FUNC(hang,void,hang,void)
 #if (defined(CONFIG_X86) && !defined(CONFIG_X86_64)) || defined(CONFIG_PPC)
 	EXPORT_FUNC(irq_install_handler, void, install_hdlr,
 		    int, interrupt_handler_t, void*)
@@ -29,6 +30,8 @@
 	EXPORT_FUNC(udelay, void, udelay, unsigned long)
 	EXPORT_FUNC(get_timer, unsigned long, get_timer, unsigned long)
 	EXPORT_FUNC(vprintf, int, vprintf, const char *, va_list)
+	EXPORT_FUNC(sprintf,int,sprintf,char *, const char *, ...)
+	EXPORT_FUNC(fprintf,int,fprintf,int, const char *, ...)
 	EXPORT_FUNC(do_reset, int, do_reset, cmd_tbl_t *,
 		    int , int , char * const [])
 	EXPORT_FUNC(env_get, char  *, env_get, const char*)
@@ -40,6 +43,7 @@
 	EXPORT_FUNC(simple_strtol, long, simple_strtol,
 		    const char *, char **, unsigned int)
 	EXPORT_FUNC(strcmp, int, strcmp, const char *cs, const char *ct)
+	EXPORT_FUNC(memcpy,void *, memcpy, void * destination, const void * source, size_t num)
 #if defined(CONFIG_CMD_I2C) && \
 		(!defined(CONFIG_DM_I2C) || defined(CONFIG_DM_I2C_COMPAT))
 	EXPORT_FUNC(i2c_write, int, i2c_write, uchar, uint, int , uchar * , int)
diff -Naur uboot/include/exports.h uboot-new/include/exports.h
--- uboot/include/exports.h	2021-01-06 11:22:28.493594161 -0500
+++ uboot-new/include/exports.h	2021-01-06 11:27:29.982288034 -0500
@@ -18,18 +18,22 @@
 void install_hdlr(int, interrupt_handler_t, void*);
 void free_hdlr(int);
 void *malloc(size_t);
+void hang(void);
 #if !CONFIG_IS_ENABLED(SYS_MALLOC_SIMPLE)
 void free(void*);
 #endif
 void __udelay(unsigned long);
 unsigned long get_timer(unsigned long);
 int vprintf(const char *, va_list);
+int sprintf(char *buf, const char *fmt, ...);
+int fprintf(int file, const char *fmt, ...);
 unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base);
 int strict_strtoul(const char *cp, unsigned int base, unsigned long *res);
 char *env_get(const char *name);
 int env_set(const char *varname, const char *value);
 long simple_strtol(const char *cp, char **endp, unsigned int base);
 int strcmp(const char *cs, const char *ct);
+void *memcpy ( void * destination, const void * source, size_t num );
 unsigned long ustrtoul(const char *cp, char **endp, unsigned int base);
 unsigned long long ustrtoull(const char *cp, char **endp, unsigned int base);
 #if defined(CONFIG_CMD_I2C) && \
diff -Naur uboot/oem/ami/standalone/cmd_nettest.c uboot-new/oem/ami/standalone/cmd_nettest.c
--- uboot/oem/ami/standalone/cmd_nettest.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/cmd_nettest.c	2021-01-06 11:27:30.074290697 -0500
@@ -0,0 +1,118 @@
+/*
+(C) Copyright 2020
+ American Megatrends Inc
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of
+ the License, or (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ MA 02111-1307 USA
+*/
+
+#include <common.h>
+#include <command.h>
+#include "common_std.h"
+
+#define NETESTCMD_MAX_ARGS CONFIG_SYS_MAXARGS
+#define MODULE_NAME "testapps"
+/*
+ * @fn do_mactest
+ *
+ */
+static int do_mactest (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    char module_name[] = MODULE_NAME;
+    int rcode = 0;
+
+    rcode = load_app(module_name);
+    if (rcode != 0) {
+    	printf("load_app() failed\n");
+	return rcode;
+    }
+
+    return exec_app(argc + 1, argv - 1);
+}
+/*
+ * @fn do_mactestd
+ *
+ */
+static int do_mactestd (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    char module_name[] = MODULE_NAME;
+    int rcode = 0;
+
+    rcode = load_app(module_name);
+    if (rcode != 0) {
+    	printf("load_app() failed\n");
+	return rcode;
+    }
+
+    return exec_app(argc + 1, argv - 1);
+}
+
+U_BOOT_CMD(
+    mactest,    NETESTCMD_MAX_ARGS, 0,  do_mactest,
+    "Dedicated LAN test program",
+    NULL
+);
+
+U_BOOT_CMD(
+    mactestd,    NETESTCMD_MAX_ARGS, 0,  do_mactestd,
+    "Dedicated LAN test program and display more information",
+    NULL
+);
+/*
+ * @fn do_ncsitest
+ *
+ */
+static int do_ncsitest (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    char module_name[] = MODULE_NAME;
+    int rcode = 0;
+
+    rcode = load_app(module_name);
+    if (rcode != 0) {
+    	printf("load_app() failed\n");
+	return rcode;
+    }
+
+    return exec_app(argc + 1, argv - 1);
+}
+/*
+ * @fn do_ncsitestd
+ *
+ */
+static int do_ncsitestd (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    char module_name[] = MODULE_NAME;
+    int rcode = 0;
+
+    rcode = load_app(module_name);
+    if (rcode != 0) {
+    	printf("load_app() failed\n");
+	return rcode;
+    }
+
+    return exec_app(argc + 1, argv - 1);
+}
+
+U_BOOT_CMD(
+    ncsitest,    NETESTCMD_MAX_ARGS, 0,  do_ncsitest,
+    "Share LAN (NC-SI) test program",
+    NULL
+);
+
+U_BOOT_CMD(
+    ncsitestd,    NETESTCMD_MAX_ARGS, 0,  do_ncsitestd,
+    "Share LAN (NC-SI) test program and display more information",
+    NULL
+);
diff -Naur uboot/oem/ami/standalone/cmd_slt.c uboot-new/oem/ami/standalone/cmd_slt.c
--- uboot/oem/ami/standalone/cmd_slt.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/cmd_slt.c	2021-01-06 11:27:30.074290697 -0500
@@ -0,0 +1,49 @@
+/*
+(C) Copyright 2020
+ American Megatrends Inc
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of
+ the License, or (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ MA 02111-1307 USA
+*/
+
+#include <common.h>
+#include <command.h>
+#include "common_std.h"
+
+#define MODULE_NAME "testapps"
+/*
+ * @fn do_dramtest
+ *
+ */
+static int do_dramtest (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+    char module_name[] = MODULE_NAME;
+    int rcode = 0;
+
+    rcode = load_app(module_name);
+    if (rcode != 0) {
+    	printf("load_app() failed\n");
+	return rcode;
+    }
+
+    return exec_app(argc + 1, argv - 1);
+}
+
+U_BOOT_CMD(
+    dramtest,   CONFIG_SYS_MAXARGS, 0,  do_dramtest,
+    "dramtest- Stress DRAM",
+    NULL
+);
+
diff -Naur uboot/oem/ami/standalone/common_std.c uboot-new/oem/ami/standalone/common_std.c
--- uboot/oem/ami/standalone/common_std.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/common_std.c	2021-01-06 11:27:30.074290697 -0500
@@ -0,0 +1,72 @@
+/*
+(C) Copyright 2020
+ American Megatrends Inc
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of
+ the License, or (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ MA 02111-1307 USA
+*/
+
+#include <common.h>
+#include "../fmh/cmd_fmh.h"
+#include"common_std.h"
+#include <spi_flash.h>
+/*
+ * @fn load_app
+ * used to load testapp module 
+ * */
+int load_app(char * module_name)
+{
+    unsigned long img_addr = 0;
+    unsigned long size = 0;
+    int rcode = 0;
+    struct spi_flash *flash = NULL;
+
+    rcode = GetFMHSectorLocationSize(module_name, &img_addr, &size);
+    if (rcode != 0) {
+    	printf("GetFMHSectorLocationSize() failed\n");
+	return rcode;
+    }
+	
+    flash = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+                        CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+    if (flash == NULL) 
+    {
+        printf("\nspi_flash_probe failed");
+    }
+
+    rcode = spi_flash_read(flash, img_addr, size, (char *)CONFIG_STANDALONE_LOAD_ADDR);
+    if(rcode != 0)
+    {
+        printf("flash_read() failed\n");
+    }
+	
+    return rcode;
+}
+/*
+ * @fn exe_app
+ * used to execute testapps module
+ */
+int exec_app(int argc, char * const argv[])
+{
+    unsigned long rc = 0;
+    int rcode = 0;
+
+    rc = do_go_exec ((void *)CONFIG_STANDALONE_LOAD_ADDR, argc, argv);
+    if (rc != 0){
+	   rcode = 1;
+    }	   
+    printf("## Application terminated, rc = 0x%lX\n", rc);
+    return rcode;
+}
diff -Naur uboot/oem/ami/standalone/common_std.h uboot-new/oem/ami/standalone/common_std.h
--- uboot/oem/ami/standalone/common_std.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/common_std.h	2021-01-06 11:27:30.074290697 -0500
@@ -0,0 +1,8 @@
+#ifndef COMMON_STD_H
+#define COMMON_STD_H
+
+extern __attribute__((weak)) unsigned long do_go_exec(ulong (*entry)(int, char * const []), int argc, char * const argv[]);
+extern int load_app(char * module_name);
+extern int exec_app(int argc, char * const argv[]);
+
+#endif
diff -Naur uboot/oem/ami/standalone/Makefile uboot-new/oem/ami/standalone/Makefile
--- uboot/oem/ami/standalone/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/Makefile	2021-01-06 11:27:30.074290697 -0500
@@ -0,0 +1,35 @@
+#
+# (C) Copyright 2020
+# American Megatrends Inc
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+LIB	:= $(obj)libnettest.o
+
+obj-y	+= common_std.o
+obj-y	+= cmd_nettest.o
+obj-y   += cmd_slt.o
+
+#-------------------------------------------------------------------
+
+OBJS	:= $(addprefix $(obj),$(obj-y))
+
+all:	$(obj).depend  $(LIB)
+
+$(LIB): $(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
diff -Naur uboot/oem/ami/standalone/nettest/cmd_nettest.c uboot-new/oem/ami/standalone/nettest/cmd_nettest.c
--- uboot/oem/ami/standalone/nettest/cmd_nettest.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/cmd_nettest.c	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,68 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+#include "swfunc.h"
+#include "comminf.h"
+#include "mem_io.h"
+#include "mac_api.h"
+
+extern int mac_test(int argc, char * const argv[], uint32_t mode);
+/*
+ * @fn do_mactest
+ *
+ */
+int do_mactest (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	display_lantest_log_msg = 0;
+	return mac_test(argc, argv, MODE_DEDICATED);
+}
+/*
+ * @fn do_ncsitest
+ *
+ */
+int do_ncsitest (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	display_lantest_log_msg = 0;
+	return mac_test(argc, argv, MODE_NCSI);
+}
+
+U_BOOT_CMD(mactest, NETESTCMD_MAX_ARGS, 0, do_mactest,
+		"Dedicated LAN test program", NULL);
+U_BOOT_CMD(ncsitest, NETESTCMD_MAX_ARGS, 0, do_ncsitest,
+		"Share LAN (NC-SI) test program", NULL);
+
+// ------------------------------------------------------------------------------
+/*
+ * @fn do_mactestd
+ *
+ */
+int do_mactestd (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	display_lantest_log_msg = 1;
+	return mac_test(argc, argv, MODE_DEDICATED);
+}
+/*
+ * @fn do_ncsitestd
+ *
+ */
+int do_ncsitestd (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	display_lantest_log_msg = 1;
+	return mac_test(argc, argv, MODE_NCSI);
+}
+
+U_BOOT_CMD(mactestd, NETESTCMD_MAX_ARGS, 0, do_mactestd,
+		"Dedicated LAN test program and display more information", NULL);
+U_BOOT_CMD(ncsitestd, NETESTCMD_MAX_ARGS, 0, do_ncsitestd,
+		"Share LAN (NC-SI) test program and display more information", NULL);
diff -Naur uboot/oem/ami/standalone/nettest/comminf.h uboot-new/oem/ami/standalone/nettest/comminf.h
--- uboot/oem/ami/standalone/nettest/comminf.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/comminf.h	2020-11-20 04:00:27.000000000 -0500
@@ -0,0 +1,897 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef COMMINF_H
+#define COMMINF_H
+
+#include "swfunc.h"
+
+#include "mac.h"
+
+//---------------------------------------------------------
+// Print Message
+//---------------------------------------------------------
+// for function
+#define FP_LOG                                   0
+#define FP_IO                                    1
+#define STD_OUT                                  2
+
+#define PRINTF(i, ...)                                                         \
+	do {                                                                   \
+		if (i == STD_OUT) {                                            \
+			fprintf(stdout, __VA_ARGS__);                          \
+			break;                                                 \
+		}                                                              \
+		if ((display_lantest_log_msg != 0) && (i == FP_LOG)) {         \
+			fprintf(stdout, "[Log]:   ");                          \
+			fprintf(stdout, __VA_ARGS__);                          \
+		}                                                              \
+	} while (0);
+
+//---------------------------------------------------------
+// Function
+//---------------------------------------------------------
+  #define SWAP_4B( x )                                                             \
+                                                 ( ( ( ( x ) & 0xff000000 ) >> 24) \
+                                                 | ( ( ( x ) & 0x00ff0000 ) >>  8) \
+                                                 | ( ( ( x ) & 0x0000ff00 ) <<  8) \
+                                                 | ( ( ( x ) & 0x000000ff ) << 24) \
+                                                 )
+  #define SWAP_2B( x )                                                             \
+                                                 ( ( ( ( x ) & 0xff00     ) >>  8) \
+                                                 | ( ( ( x ) & 0x00ff     ) <<  8) \
+                                                 )
+
+  #define SWAP_2B_BEDN( x )                      ( SWAP_2B ( x ) )
+  #define SWAP_2B_LEDN( x )                      ( x )
+  #define SWAP_4B_BEDN( x )                      ( SWAP_4B ( x ) )
+  #define SWAP_4B_LEDN( x )                      ( x )
+
+  #define SWAP_4B_BEDN_NCSI( x )                 ( SWAP_4B( x ) )
+  #define SWAP_4B_LEDN_NCSI( x )                 ( x )
+
+#if defined(ENABLE_BIG_ENDIAN_MEM)
+  #define SWAP_4B_LEDN_MEM( x )                  ( SWAP_4B( x ) )
+#else
+  #define SWAP_4B_LEDN_MEM( x )                  ( x )
+#endif
+#if defined(ENABLE_BIG_ENDIAN_REG)
+  #define SWAP_4B_LEDN_REG( x )                  ( SWAP_4B( x ) )
+#else
+  #define SWAP_4B_LEDN_REG( x )                  ( x )
+#endif
+
+#define DELAY( x )                       	udelay( ( x ) * 1000 )
+#define GET_CAHR                         	getc
+
+//---------------------------------------------------------
+// Default argument
+//---------------------------------------------------------
+#define  DEF_GUSER_DEF_PACKET_VAL                0xaaaaaaaa     //0xff00ff00, 0xf0f0f0f0, 0xcccccccc, 0x55aa55aa, 0x5a5a5a5a, 0x66666666
+#define  DEF_GIOTIMINGBUND                       2
+#define  DEF_GPHY_ADR                            0
+#define  DEF_GTESTMODE                           0              //[0]0: no burst mode, 1: 0xff, 2: 0x55, 3: random, 4: ARP, 5: ARP, 6: IO timing, 7: IO timing+IO Strength
+#define  DEF_GLOOP_MAX                           1
+#define  DEF_GCTRL                               0
+
+#define  SET_1GBPS                               BIT(0)
+#define  SET_100MBPS                             BIT(1)
+#define  SET_10MBPS                              BIT(2)
+#define  SET_1G_100M_10MBPS                      (SET_1GBPS | SET_100MBPS | SET_10MBPS)
+#define  SET_100M_10MBPS                         (SET_100MBPS | SET_10MBPS)
+
+#define  DEF_GSPEED                              SET_1G_100M_10MBPS
+#define  DEF_GARPNUMCNT                          0
+
+//---------------------------------------------------------
+// MAC information
+//---------------------------------------------------------
+
+#define MDC_Thres                                0x3f
+#define MAC_PHYWr                                0x08000000
+#define MAC_PHYRd                                0x04000000
+
+#ifdef CONFIG_ASPEED_AST2600
+#define MAC_PHYWr_New 	(BIT(31) | BIT(28) | (0x1 << 26)) /* 0x94000000 */
+#define MAC_PHYRd_New 	(BIT(31) | BIT(28) | (0x2 << 26)) /* 0x98000000 */
+#define MAC_PHYBusy_New	BIT(31)
+#else
+#define MAC_PHYWr_New                            0x00009400
+#define MAC_PHYRd_New                            0x00009800
+#define MAC_PHYBusy_New                          0x00008000
+#endif
+
+#define MAC_048_def                          0x000002F1 //default 0xf1
+//#define MAC_058_def                              0x00000040 //0x000001c0
+
+//---------------------------------------------------------
+// Data information
+//---------------------------------------------------------
+#define ZeroCopy_OFFSET                    (( eng->run.tm_tx_only ) ? 0 : 2)
+
+//      --------------------------------- DRAM_MapAdr            = tdes_base
+//              | TX descriptor ring    |
+//              ------------------------- DRAM_MapAdr + 0x040000 = rdes_base
+//              | RX descriptor ring    |
+//              -------------------------
+//              | Reserved              |
+//              -------------------------
+//              | Reserved              |
+//      --------------------------------- DRAM_MapAdr + 0x100000 = DMA_BASE    -------------------------
+//              |   #1                  |  \                                   |     #1     Tx         |
+//  DMA buffer  |                       |   DMA_BufSize                        |      LOOP = 0         |
+// ( Tx/Rx )    -------------------------  /                                   --------------------------------------------------
+//              |   #2                  |                                      |     #2     Rx         |  #2     Tx             |
+//              |                       |                                      |      LOOP = 0         |   LOOP = 1             |
+//              -------------------------                                      --------------------------------------------------
+//              |   #3                  |                                                              |  #3     Rx             |
+//              |                       |                                                              |   LOOP = 1             |
+//              -------------------------                                                              -------------------------
+//              |   #4                  |                                                                                     ..........
+//              |                       |
+//              -------------------------
+//              |   #5                  |
+//              |                       |
+//              -------------------------
+//              |   #6                  |
+//              |                       |
+//              -------------------------
+//                           .
+//                           .
+//              -------------------------
+//              |   #n, n = DMA_BufNum  |
+//              |                       |
+//      ---------------------------------
+
+#define BUF_SIZE			0x04000000
+#define TDES_SIZE			0x00040000
+#define RDES_SIZE			0x00040000
+#define RESV_SIZE			0x00000000		/* reserved */
+
+#define TDES_IniVal (0xb0000000 + eng->dat.FRAME_LEN_Cur)
+#define RDES_IniVal (0x00000fff)
+#define EOR_IniVal (0x40000000)
+#define HWOwnTx(dat) (dat & 0x80000000)
+#define HWOwnRx(dat) ((dat & 0x80000000) == 0)
+#define HWEOR(dat) (dat & 0x40000000)
+
+#define AT_MEMRW_BUF(x) ((x) - ASPEED_DRAM_BASE)
+#define AT_BUF_MEMRW(x) ((x) + ASPEED_DRAM_BASE)
+
+//---------------------------------------------------------
+// Error Flag Bits
+//---------------------------------------------------------
+#define Err_Flag_MACMode                              ( 1 <<  0 )   // MAC interface mode mismatch
+#define Err_Flag_PHY_Type                             ( 1 <<  1 )   // Unidentifiable PHY
+#define Err_Flag_MALLOC_FrmSize                       ( 1 <<  2 )   // Malloc fail at frame size buffer
+#define Err_Flag_MALLOC_LastWP                        ( 1 <<  3 )   // Malloc fail at last WP buffer
+#define Err_Flag_Check_Buf_Data                       ( 1 <<  4 )   // Received data mismatch
+#define Err_Flag_Check_Des                            ( 1 <<  5 )   // Descriptor error
+#define ERR_FLAG_NCSI_LINKFAIL			(1 << 6)	// NCSI packet retry number over flows
+#define Err_Flag_NCSI_Check_TxOwnTimeOut              ( 1 <<  7 )   // Time out of checking Tx owner bit in NCSI packet
+#define Err_Flag_NCSI_Check_RxOwnTimeOut              ( 1 <<  8 )   // Time out of checking Rx owner bit in NCSI packet
+#define Err_Flag_NCSI_Check_ARPOwnTimeOut             ( 1 <<  9 )   // Time out of checking ARP owner bit in NCSI packet
+#define Err_Flag_NCSI_No_PHY                          ( 1 << 10 )   // Can not find NCSI PHY
+#define Err_Flag_NCSI_Channel_Num                     ( 1 << 11 )   // NCSI Channel Number Mismatch
+#define Err_Flag_NCSI_Package_Num                     ( 1 << 12 )   // NCSI Package Number Mismatch
+#define Err_Flag_PHY_TimeOut_RW                       ( 1 << 13 )   // Time out of read/write PHY register
+#define Err_Flag_PHY_TimeOut_Rst                      ( 1 << 14 )   // Time out of reset PHY register
+#define Err_Flag_RXBUF_UNAVA                          ( 1 << 15 )   // MAC00h[2]:Receiving buffer unavailable
+#define Err_Flag_RPKT_LOST                            ( 1 << 16 )   // MAC00h[3]:Received packet lost due to RX FIFO full
+#define Err_Flag_NPTXBUF_UNAVA                        ( 1 << 17 )   // MAC00h[6]:Normal priority transmit buffer unavailable
+#define Err_Flag_TPKT_LOST                            ( 1 << 18 )   // MAC00h[7]:Packets transmitted to Ethernet lost
+#define Err_Flag_DMABufNum                            ( 1 << 19 )   // DMA Buffer is not enough
+#define Err_Flag_IOMargin                             ( 1 << 20 )   // IO timing margin is not enough
+#define Err_Flag_IOMarginOUF                          ( 1 << 21 )   // IO timing testing out of boundary
+#define Err_Flag_MHCLK_Ratio                          ( 1 << 22 )   // Error setting of MAC AHB bus clock (SCU08[18:16])
+
+#define Wrn_Flag_IOMarginOUF                          ( 1 <<  0 )   // IO timing testing out of boundary
+#define Wrn_Flag_RxErFloatting                        ( 1 <<  1 )   // NCSI RXER pin may be floatting to the MAC
+//#define Wrn_Flag_RMIICK_IOMode                        ( 1 <<  2 )   // The PHY's RMII refreence clock input/output mode
+
+#define PHY_Flag_RMIICK_IOMode_RTL8201E               ( 1 <<  0 )
+#define PHY_Flag_RMIICK_IOMode_RTL8201F               ( 1 <<  1 )
+
+#define Des_Flag_TxOwnTimeOut                         ( 1 <<  0 )   // Time out of checking Tx owner bit
+#define Des_Flag_RxOwnTimeOut                         ( 1 <<  1 )   // Time out of checking Rx owner bit
+#define Des_Flag_FrameLen                             ( 1 <<  2 )   // Frame length mismatch
+#define Des_Flag_RxErr                                ( 1 <<  3 )   // Input signal RxErr
+#define Des_Flag_CRC                                  ( 1 <<  4 )   // CRC error of frame
+#define Des_Flag_FTL                                  ( 1 <<  5 )   // Frame too long
+#define Des_Flag_Runt                                 ( 1 <<  6 )   // Runt packet
+#define Des_Flag_OddNibble                            ( 1 <<  7 )   // Nibble bit happen
+#define Des_Flag_RxFIFOFull                           ( 1 <<  8 )   // Rx FIFO full
+
+#define NCSI_Flag_Get_Version_ID                      ( 1 <<  0 )   // Time out when Get Version ID
+#define NCSI_Flag_Get_Capabilities                    ( 1 <<  1 )   // Time out when Get Capabilities
+#define NCSI_Flag_Select_Active_Package               ( 1 <<  2 )   // Time out when Select Active Package
+#define NCSI_Flag_Enable_Set_MAC_Address              ( 1 <<  3 )   // Time out when Enable Set MAC Address
+#define NCSI_Flag_Enable_Broadcast_Filter             ( 1 <<  4 )   // Time out when Enable Broadcast Filter
+#define NCSI_Flag_Enable_Network_TX                   ( 1 <<  5 )   // Time out when Enable Network TX
+#define NCSI_Flag_Enable_Channel                      ( 1 <<  6 )   // Time out when Enable Channel
+#define NCSI_Flag_Disable_Network_TX                  ( 1 <<  7 )   // Time out when Disable Network TX
+#define NCSI_Flag_Disable_Channel                     ( 1 <<  8 )   // Time out when Disable Channel
+#define NCSI_Flag_Select_Package                      ( 1 <<  9 )   // Time out when Select Package
+#define NCSI_Flag_Deselect_Package                    ( 1 << 10 )   // Time out when Deselect Package
+#define NCSI_Flag_Set_Link                            ( 1 << 11 )   // Time out when Set Link
+#define NCSI_Flag_Get_Controller_Packet_Statistics    ( 1 << 12 )   // Time out when Get Controller Packet Statistics
+#define NCSI_Flag_Reset_Channel                       ( 1 << 13 )   // Time out when Reset Channel
+
+//---------------------------------------------------------
+// DMA Buffer information
+//---------------------------------------------------------
+#define DMA_BUF_SIZE				(56 * 1024 * 1024)
+extern uint8_t dma_buf[DMA_BUF_SIZE];
+
+#define DMA_BASE				((uint32_t)(&dma_buf[0]))
+/* The size of one LAN packet */
+#define DMA_PakSize 				(2 * 1024)
+
+#ifdef SelectSimpleBoundary
+#define DMA_BufSize (((((p_eng->dat.Des_Num + 15) * DMA_PakSize) >> 2) << 2))
+#else
+#define DMA_BufSize                                                            \
+	(4 + ((((p_eng->dat.Des_Num + 15) * DMA_PakSize) >> 2) << 2))
+#endif
+#define DMA_BufNum (DMA_BUF_SIZE / (p_eng->dat.DMABuf_Size))
+
+/* get DMA buffer address according to the loop counter */
+#define GET_DMA_BASE(p_eng, x)                                                 \
+	(DMA_BASE + ((((x) % p_eng->dat.DMABuf_Num)) * p_eng->dat.DMABuf_Size))
+
+#define SEED_START                               8
+#define DATA_SEED(seed)                          ( ( seed ) | (( seed + 1 ) << 16 ) )
+#define DATA_IncVal                              0x00020001
+#define PktByteSize                              ( ( ( ( ZeroCopy_OFFSET + eng->dat.FRAME_LEN_Cur - 1 ) >> 2 ) + 1) << 2 )
+
+//---------------------------------------------------------
+// Delay (ms)
+//---------------------------------------------------------
+//#define Delay_DesGap                             1    //off
+//#define Delay_CntMax                             40
+//#define Delay_CntMax                             1000
+//#define Delay_CntMax                             8465
+//#define Delay_CntMaxIncVal                       50000
+#define Delay_CntMaxIncVal                       47500
+
+
+//#define Delay_ChkRxOwn                           1
+//#define Delay_ChkTxOwn                           1
+
+#define Delay_PHYRst                             100
+//#define Delay_PHYRd                              5
+#define Delay_PHYRd                              1         //20150423
+
+#define Delay_MACRst                             1
+#define Delay_MACDump                            1
+
+//#define Delay_DES                                1
+
+//---------------------------------------------------------
+// Time Out
+//---------------------------------------------------------
+#define TIME_OUT_Des_1G                      10000     //400
+#define TIME_OUT_Des_100M                    20000     //4000
+#define TIME_OUT_Des_10M                     50000     //20000
+#define TIME_OUT_NCSI                        100000    //40000
+#define TIME_OUT_PHY_RW                      2000000   //100000
+#define TIME_OUT_PHY_Rst                     20000     //1000
+
+//---------------------------------------------------------
+// Chip memory MAP
+//---------------------------------------------------------
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t txdma_en		: 1;	/* bit[0] */
+		uint32_t rxdma_en		: 1;	/* bit[1] */
+		uint32_t txmac_en		: 1;	/* bit[2] */
+		uint32_t rxmac_en		: 1;	/* bit[3] */
+		uint32_t rm_vlan		: 1;	/* bit[4] */
+		uint32_t hptxr_en		: 1;	/* bit[5] */
+		uint32_t phy_link_sts_dtct	: 1;	/* bit[6] */
+		uint32_t enrx_in_halftx		: 1;	/* bit[7] */
+		uint32_t fulldup		: 1;	/* bit[8] */
+		uint32_t gmac_mode		: 1;	/* bit[9] */
+		uint32_t crc_apd		: 1;	/* bit[10] */
+#ifdef CONFIG_ASPEED_AST2600
+		uint32_t reserved_1		: 1;	/* bit[11] */
+#else		
+		uint32_t phy_link_lvl_dtct	: 1;	/* bit[11] */
+#endif		
+		uint32_t rx_runt		: 1;	/* bit[12] */
+		uint32_t jumbo_lf		: 1;	/* bit[13] */
+		uint32_t rx_alladr		: 1;	/* bit[14] */
+		uint32_t rx_ht_en		: 1;	/* bit[15] */
+		uint32_t rx_multipkt_en		: 1;	/* bit[16] */
+		uint32_t rx_broadpkt_en		: 1;	/* bit[17] */
+		uint32_t discard_crcerr		: 1;	/* bit[18] */
+		uint32_t speed_100		: 1;	/* bit[19] */
+		uint32_t reserved_0		: 11;	/* bit[30:20] */
+		uint32_t sw_rst			: 1;	/* bit[31] */
+	}b;
+} mac_cr_t;
+// ========================================================
+// For ncsi.c
+
+#define DEF_GPACKAGE2NUM                         1         // Default value
+#define DEF_GCHANNEL2NUM                         1         // Default value
+
+//---------------------------------------------------------
+// Variable
+//---------------------------------------------------------
+//NC-SI Command Packet
+typedef struct {
+//Ethernet Header
+	unsigned char        DA[6];                        // Destination Address
+	unsigned char        SA[6];                        // Source Address
+	uint16_t       EtherType;                    // DMTF NC-SI, it should be 0x88F8
+//NC-SI Control Packet
+	unsigned char        MC_ID;                        // Management Controller should set this field to 0x00
+	unsigned char        Header_Revision;              // For NC-SI 1.0 spec, this field has to set 0x01
+	unsigned char        Reserved_1;                   // Reserved has to set to 0x00
+	unsigned char        IID;                          // Instance ID
+	unsigned char        Command;
+//	unsigned char        Channel_ID;
+	unsigned char        ChID;
+	uint16_t	Payload_Length;               // Payload Length = 12 bits, 4 bits are reserved
+	uint32_t	Reserved_2;
+	uint32_t	Reserved_3;
+
+	uint16_t	Reserved_4;
+	uint16_t	Reserved_5;
+	uint16_t	Response_Code;
+	uint16_t       Reason_Code;
+	unsigned char        Payload_Data[64];
+#if !defined(SLT_UBOOT)
+}  NCSI_Command_Packet;
+#else
+}  __attribute__ ((__packed__)) NCSI_Command_Packet;
+#endif
+
+//NC-SI Response Packet
+typedef struct {
+	unsigned char        DA[6];
+	unsigned char        SA[6];
+	uint16_t       EtherType;                    //DMTF NC-SI
+//NC-SI Control Packet
+	unsigned char        MC_ID;                        //Management Controller should set this field to 0x00
+	unsigned char        Header_Revision;              //For NC-SI 1.0 spec, this field has to set 0x01
+	unsigned char        Reserved_1;                   //Reserved has to set to 0x00
+	unsigned char        IID;                          //Instance ID
+	unsigned char        Command;
+//	unsigned char        Channel_ID;
+	unsigned char        ChID;
+	uint16_t       Payload_Length;               //Payload Length = 12 bits, 4 bits are reserved
+	uint16_t       Reserved_2;
+	uint16_t       Reserved_3;
+	uint16_t       Reserved_4;
+	uint16_t       Reserved_5;
+
+	uint16_t       Response_Code;
+	uint16_t       Reason_Code;
+	unsigned char        Payload_Data[64];
+#if !defined(SLT_UBOOT)
+}  NCSI_Response_Packet;
+#else
+}  __attribute__ ((__packed__)) NCSI_Response_Packet;
+#endif
+
+typedef struct {
+	unsigned char        All_ID                                   ;
+	unsigned char        Package_ID                               ;
+	unsigned char        Channel_ID                               ;
+	uint32_t Capabilities_Flags                       ;
+	uint32_t Broadcast_Packet_Filter_Capabilities     ;
+	uint32_t Multicast_Packet_Filter_Capabilities     ;
+	uint32_t Buffering_Capabilities                   ;
+	uint32_t AEN_Control_Support                      ;
+	unsigned char        VLAN_Filter_Count                        ;
+	unsigned char        Mixed_Filter_Count                       ;
+	unsigned char        Multicast_Filter_Count                   ;
+	unsigned char        Unicast_Filter_Count                     ;
+	unsigned char        VLAN_Mode_Support                        ;
+	unsigned char        Channel_Count                            ;
+	uint32_t PCI_DID_VID                              ;
+	uint32_t manufacturer_id                           ;
+} NCSI_Capability;
+
+typedef struct {
+	mac_cr_t maccr;
+	uint32_t mac_madr;
+	uint32_t mac_ladr;
+	uint32_t mac_fear;
+
+	uint32_t WDT_00c                       ;
+	uint32_t WDT_02c                       ;
+	uint32_t WDT_04c                       ;
+
+	int8_t                 SCU_oldvld;
+} mac_reg_t;
+typedef struct {
+	uint8_t ast2600;
+	uint8_t ast2500;
+	uint8_t mac_num;
+	uint8_t is_new_mdio_reg[4];
+
+	uint8_t is_1g_valid[4];
+	uint8_t at_least_1g_valid;
+	uint8_t MHCLK_Ratio;
+} mac_env_t;
+
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t skip_phy_init	: 1;	/* bit[0] */
+		uint32_t skip_phy_deinit: 1;	/* bit[1] */
+		uint32_t skip_phy_id_check	: 1;	/* bit[2] */
+		uint32_t reserved_0	: 1;	/* bit[3] */
+		uint32_t phy_int_loopback : 1;	/* bit[4] */
+		uint32_t mac_int_loopback : 1;	/* bit[5] */
+		uint32_t reserved_1	: 2;	/* bit[7:6] */
+		uint32_t rmii_50m_out	: 1;	/* bit[8] */
+		uint32_t rmii_phy_in	: 1;	/* bit[9] */
+		uint32_t inv_rgmii_rxclk: 1;	/* bit[10] */
+		uint32_t reserved_2	: 1;	/* bit[11] */
+		uint32_t single_packet	: 1;	/* bit[12] */
+		uint32_t full_range	: 1;	/* bit[13] */
+		uint32_t reserved_3	: 2;	/* bit[15:14] */
+		uint32_t print_ncsi	: 1;	/* bit[16] */
+		uint32_t skip_rx_err	: 1;	/* bit[17] */
+	} b;
+} mac_arg_ctrl_t;
+typedef struct {
+	uint32_t run_mode;		/* select dedicated or NCSI */
+	uint32_t mac_idx;		/* argv[1] */
+	uint32_t mdio_idx;
+	uint32_t run_speed;		/* argv[2] for dedicated */
+	mac_arg_ctrl_t ctrl;		/* argv[3] for dedicated 
+					   argv[6] for ncsi */
+	uint32_t loop_max;		/* argv[4] for dedicated */
+	uint32_t loop_inf;		/* argv[4] for dedicated */
+
+	uint32_t GPackageTolNum;	/* argv[2] for ncsi */
+	uint32_t GChannelTolNum;	/* argv[3] for ncsi */
+	
+	uint32_t test_mode;		/* argv[5] for dedicated
+					   argv[4] for ncsi */
+
+	uint32_t phy_addr;		/* argv[6] for dedicated */
+	uint32_t delay_scan_range;	/* argv[7] for dedicated
+					   argv[5] for ncsi */	
+	uint32_t ieee_sel;		/* argv[7] for dedicated */
+
+	uint32_t GARPNumCnt;		/* argv[7] for ncsi */
+	uint32_t user_def_val;		/* argv[8] for dedicated */
+} mac_arg_t;
+typedef struct {
+	uint32_t mac_idx;
+	uint32_t mac_base;
+	uint32_t mdio_idx;
+	uint32_t mdio_base;
+	uint32_t is_rgmii;
+	uint32_t ieee_sel;		/* derived from delay_scan_range */
+
+	uint32_t tdes_base;
+	uint32_t rdes_base;
+
+	uint32_t ncsi_tdes_base;
+	uint32_t ncsi_rdes_base;
+
+	uint32_t LOOP_CheckNum                 ;
+	uint32_t CheckBuf_MBSize               ;
+	uint32_t timeout_th;	/* time out threshold (varies with run-speed) */
+
+	uint32_t loop_max;
+	uint32_t loop_of_cnt;
+	uint32_t loop_cnt;
+	uint32_t speed_idx;
+	int                  NCSI_RxTimeOutScale           ;
+
+	uint8_t speed_cfg[3];
+	uint8_t speed_sel[3];
+
+	/* test mode */
+	uint8_t delay_margin;
+	uint8_t tm_tx_only;
+	int8_t                 TM_IEEE                       ;//test_mode
+	int8_t                 TM_IOTiming                   ;//test_mode
+	int8_t                 TM_IOStrength                 ;//test_mode
+	int8_t                 TM_TxDataEn                   ;//test_mode
+	int8_t                 TM_RxDataEn                   ;//test_mode
+	int8_t                 TM_WaitStart                  ;//test_mode
+	int8_t                 TM_DefaultPHY                 ;//test_mode
+	int8_t                 TM_NCSI_DiSChannel            ;//test_mode
+
+	int8_t                 IO_MrgChk                     ;
+
+
+} MAC_Running;
+
+typedef struct {
+	uint8_t SA[6];
+} MAC_Information;
+
+typedef struct {
+	uint32_t mdio_base;
+	uint32_t loopback;
+	uint8_t phy_name[64];
+	int8_t                 default_phy                   ;
+	int8_t                 Adr                           ;
+
+	uint16_t id2                       ;
+	uint16_t id1                       ;
+
+	uint32_t PHY_00h                       ;
+	uint32_t PHY_06h                       ;
+	uint32_t PHY_09h                       ;
+	uint32_t PHY_0eh                       ;
+	uint32_t PHY_10h                       ;
+	uint32_t PHY_11h                       ;
+	uint32_t PHY_12h                       ;
+	uint32_t PHY_14h                       ;
+	uint32_t PHY_15h                       ;
+	uint32_t PHY_18h                       ;
+	uint32_t PHY_19h                       ;
+	uint32_t PHY_1ch                       ;
+	uint32_t PHY_1eh                       ;
+	uint32_t PHY_1fh                       ;
+	uint32_t PHY_06hA[7]                   ;
+
+	uint32_t RMIICK_IOMode                 ;
+} MAC_PHY;
+
+#ifdef CONFIG_ASPEED_AST2600
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t tx_delay_1		: 6;	/* bit[5:0] */
+		uint32_t tx_delay_2		: 6;	/* bit[11:6] */
+		uint32_t rx_delay_1		: 6;	/* bit[17:12] */
+		uint32_t rx_delay_2		: 6;	/* bit[23:18] */
+		uint32_t rx_clk_inv_1 		: 1;	/* bit[24] */
+		uint32_t rx_clk_inv_2 		: 1;	/* bit[25] */
+		uint32_t rmii_tx_data_at_falling_1 : 1; /* bit[26] */
+		uint32_t rmii_tx_data_at_falling_2 : 1; /* bit[27] */
+		uint32_t rgmiick_pad_dir	: 1;	/* bit[28] */
+		uint32_t rmii_50m_oe_1 		: 1;	/* bit[29] */
+		uint32_t rmii_50m_oe_2		: 1;	/* bit[30] */
+		uint32_t rgmii_125m_o_sel 	: 1;	/* bit[31] */
+	}b;
+} mac_delay_1g_t;
+
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t tx_delay_1		: 6;	/* bit[5:0] */
+		uint32_t tx_delay_2		: 6;	/* bit[11:6] */
+		uint32_t rx_delay_1		: 6;	/* bit[17:12] */
+		uint32_t rx_delay_2		: 6;	/* bit[23:18] */
+		uint32_t rx_clk_inv_1 		: 1;	/* bit[24] */
+		uint32_t rx_clk_inv_2 		: 1;	/* bit[25] */
+		uint32_t reserved_0 		: 6;	/* bit[31:26] */
+	}b;
+} mac_delay_100_10_t;
+#else
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t tx_delay_1		: 6;	/* bit[5:0] */
+		uint32_t tx_delay_2		: 6;	/* bit[11:6] */
+		uint32_t rx_delay_1		: 6;	/* bit[17:12] */
+		uint32_t rx_delay_2		: 6;	/* bit[23:18] */		
+		uint32_t rmii_tx_data_at_falling_1 : 1; /* bit[24] */
+		uint32_t rmii_tx_data_at_falling_2 : 1; /* bit[25] */
+		uint32_t reserved		: 3;	/* bit[28:26] */
+		uint32_t rmii_50m_oe_1 		: 1;	/* bit[29] */
+		uint32_t rmii_50m_oe_2		: 1;	/* bit[30] */
+		uint32_t rgmii_125m_o_sel 	: 1;	/* bit[31] */
+	}b;
+} mac_delay_1g_t;
+
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t tx_delay_1		: 6;	/* bit[5:0] */
+		uint32_t tx_delay_2		: 6;	/* bit[11:6] */
+		uint32_t rx_delay_1		: 6;	/* bit[17:12] */
+		uint32_t rx_delay_2		: 6;	/* bit[23:18] */
+		uint32_t enable 		: 1;	/* bit[24] */
+		uint32_t reserved_0 		: 7;	/* bit[31:25] */
+	}b;
+} mac_delay_100_10_t;
+#endif
+
+typedef struct mac_delay_1g_reg_s {
+	uint32_t addr;
+	int32_t tx_min;
+	int32_t tx_max;
+	int32_t rx_min;
+	int32_t rx_max;
+	int32_t rmii_tx_min;
+	int32_t rmii_tx_max;
+	int32_t rmii_rx_min;
+	int32_t rmii_rx_max;
+	mac_delay_1g_t value;	/* backup register value */
+} mac_delay_1g_reg_t;
+
+typedef struct mac_delay_100_10_reg_s {
+	uint32_t addr;
+	int32_t tx_min;
+	int32_t tx_max;
+	int32_t rx_min;
+	int32_t rx_max;
+	mac_delay_100_10_t value;
+} mac_delay_100_10_reg_t;
+
+#ifdef CONFIG_ASPEED_AST2600
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t mac3_tx_drv		: 2;	/* bit[1:0] */
+		uint32_t mac4_tx_drv		: 2;	/* bit[3:2] */
+		uint32_t reserved_0		: 28;	/* bit[31:4] */
+	}b;
+} mac34_drv_t;
+typedef struct mac34_drv_reg_s {
+	uint32_t addr;
+	uint32_t drv_max;
+	mac34_drv_t value;
+} mac34_drv_reg_t;
+
+#else
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t reserved_0		: 8;	/* bit[7:0] */
+		uint32_t mac1_rmii_tx_drv	: 1;	/* bit[8] */
+		uint32_t mac1_rgmii_tx_drv	: 1;	/* bit[9] */
+		uint32_t mac2_rmii_tx_drv	: 1;	/* bit[10] */
+		uint32_t mac2_rgmii_tx_drv	: 1;	/* bit[11] */
+		uint32_t reserved_1		: 20;	/* bit[31:12] */
+	}b;
+} mac12_drv_t;
+
+typedef struct mac12_drv_reg_s {
+	uint32_t addr;
+	uint32_t drv_max;
+	mac12_drv_t value;
+} mac12_drv_reg_t;
+#endif
+
+typedef struct delay_scan_s {
+	int8_t begin;
+	int8_t end;
+	int8_t step;
+	int8_t orig;
+} delay_scan_t;
+typedef struct {
+	/* driving strength */
+#ifdef CONFIG_ASPEED_AST2600
+	mac34_drv_reg_t mac34_drv_reg;
+#else	
+	mac12_drv_reg_t mac12_drv_reg;
+#endif
+	uint32_t drv_upper_bond;
+	uint32_t drv_lower_bond;
+	uint32_t drv_curr;
+
+	mac_delay_1g_reg_t mac12_1g_delay;
+	mac_delay_1g_reg_t mac34_1g_delay;
+	mac_delay_100_10_reg_t mac12_100m_delay;
+	mac_delay_100_10_reg_t mac34_100m_delay;
+	mac_delay_100_10_reg_t mac12_10m_delay;
+	mac_delay_100_10_reg_t mac34_10m_delay;
+
+	delay_scan_t tx_delay_scan;
+	delay_scan_t rx_delay_scan;	
+
+	uint8_t                 Dly_in_reg_idx;
+	int8_t                Dly_in_min                    ;
+	uint8_t                 Dly_in_max                    ;
+	uint8_t                 Dly_out_reg_idx               ;
+	int8_t                Dly_out_min                   ;
+	uint8_t                 Dly_out_max                   ;	
+	
+	uint8_t                 Dly_in                        ;
+	uint8_t                 Dly_in_selval                 ;
+	uint8_t                 Dly_out                       ;
+	uint8_t                 Dly_out_selval                ;
+	int8_t result;
+	int8_t result_history[128][64];
+	uint32_t init_done;
+} MAC_IO;
+typedef struct {
+#ifdef Enable_ShowBW
+	double               Total_frame_len               ;//__attribute__ ((aligned (8)));
+#endif
+	uint32_t Des_Num                       ;
+	uint32_t Des_Num_Org                   ;
+	uint32_t DMABuf_Size                   ;
+	uint32_t DMABuf_Num                    ;
+
+	uint32_t *FRAME_LEN                    ;
+	uint32_t FRAME_LEN_Cur                 ;
+	uint32_t *wp_lst                       ;
+	uint32_t wp_fir                        ;
+
+	uint32_t DMA_Base_Setup                 ;
+	uint32_t DMA_Base_Tx                  ;
+	uint32_t DMA_Base_Rx                   ;
+
+	uint32_t ARP_data[16]                  ;
+	uint32_t TxDes0DW                      ;
+	uint32_t RxDes0DW                      ;
+	uint32_t RxDes3DW                      ;
+
+	uint8_t                 number_chl                    ;
+	uint8_t                 number_pak                    ;
+	char                 NCSI_RxEr                     ;
+	uint32_t NCSI_TxDWBUF[512]             ;
+	uint32_t NCSI_RxDWBUF[512]             ;
+	char                 NCSI_CommandStr[512]          ;
+	unsigned char        *NCSI_TxByteBUF               ;
+	unsigned char        *NCSI_RxByteBUF               ;
+	unsigned char        NCSI_Payload_Data[16]         ;
+	uint32_t Payload_Checksum_NCSI         ;
+} MAC_Data;
+
+typedef struct {
+	uint32_t warn;
+	uint32_t error;
+	uint32_t desc;
+	uint32_t ncsi;
+	uint32_t error_backup;
+	uint32_t ncsi_backup;
+	uint32_t n_desc_fail;
+	uint8_t print_en;
+	uint8_t all_fail;
+} MAC_Flag;
+
+typedef struct {
+	mac_reg_t reg;
+	mac_env_t env;
+	mac_arg_t arg;	
+	MAC_Running          run;
+	MAC_Information      inf;
+	MAC_PHY              phy;
+	MAC_IO               io;
+	MAC_Data             dat;
+	MAC_Flag             flg;
+	NCSI_Command_Packet  ncsi_req;
+	NCSI_Response_Packet ncsi_rsp;
+	NCSI_Capability      ncsi_cap;	
+} MAC_ENGINE;
+typedef void (* PHY_SETTING) (MAC_ENGINE *);
+typedef struct {
+	PHY_SETTING          fp_set;
+	PHY_SETTING          fp_clr;
+} PHY_ENGINE;
+
+#undef GLOBAL
+#ifdef NCSI_C
+#define GLOBAL
+#else
+#define GLOBAL    extern
+#endif
+
+GLOBAL  char phy_ncsi (MAC_ENGINE *eng);
+
+// ========================================================
+// For mactest
+
+#undef GLOBAL
+#ifdef MACTEST_C
+#define GLOBAL
+#else
+#define GLOBAL    extern
+#endif
+
+#define MODE_DEDICATED                           0x01
+#define MODE_NCSI                                0x02
+
+GLOBAL  uint8_t            *mmiobase;
+GLOBAL  uint32_t ulPCIBaseAddress;
+GLOBAL  uint32_t ulMMIOBaseAddress;
+
+GLOBAL  uint8_t             display_lantest_log_msg;
+
+// ========================================================
+// For mac.c
+#undef GLOBAL
+#ifdef MAC_C
+#define GLOBAL
+#else
+#define GLOBAL    extern
+#endif
+
+#if defined(MAC_C)
+static  const  char version_name[] = VER_NAME;
+static  const  uint8_t IOValue_Array_A0[16] = {8,1, 10,3, 12,5, 14,7, 0,9, 2,11, 4,13, 6,15}; // AST2300-A0
+#endif
+
+GLOBAL void    debug_pause (void);
+GLOBAL uint32_t Read_Mem_Dat_NCSI_DD (uint32_t addr);
+GLOBAL uint32_t Read_Mem_Des_NCSI_DD (uint32_t addr);
+
+
+
+
+
+
+
+GLOBAL void Write_Mem_Dat_NCSI_DD (uint32_t addr, uint32_t data);
+GLOBAL void Write_Mem_Des_NCSI_DD (uint32_t addr, uint32_t data);
+
+
+GLOBAL void Write_Reg_TIMER_DD (uint32_t addr, uint32_t data);
+
+
+
+
+
+
+GLOBAL void    PrintTest (MAC_ENGINE *eng);
+GLOBAL void    PrintIOTimingBund (MAC_ENGINE *eng);
+
+
+
+GLOBAL void    PrintPHYAdr (MAC_ENGINE *eng);
+
+
+
+
+
+GLOBAL void    setup_arp (MAC_ENGINE *eng);
+GLOBAL void    TestingSetup (MAC_ENGINE *eng);
+
+
+
+GLOBAL void    init_mac (MAC_ENGINE *eng);
+GLOBAL char TestingLoop (MAC_ENGINE *eng, uint32_t loop_checknum);
+
+GLOBAL void    init_phy (MAC_ENGINE *eng, PHY_ENGINE *phyeng);
+
+
+GLOBAL void    phy_select (MAC_ENGINE *eng, PHY_ENGINE *phyeng);
+GLOBAL void    recov_phy (MAC_ENGINE *eng, PHY_ENGINE *phyeng);
+GLOBAL int     FindErr (MAC_ENGINE *eng, int value);
+GLOBAL int     FindErr_Des (MAC_ENGINE *eng, int value);
+GLOBAL void    PrintIO_Header (MAC_ENGINE *eng, uint8_t option);
+
+
+
+GLOBAL void    FPri_ErrFlag (MAC_ENGINE *eng, uint8_t option);
+
+GLOBAL void init_hwtimer( void );
+GLOBAL void delay_hwtimer(uint16_t msec);
+
+// ========================================================
+// For PHYGPIO.c
+#undef GLOBAL
+#ifdef PHYGPIO_C
+#define GLOBAL
+#else
+#define GLOBAL    extern
+#endif
+
+
+// ========================================================
+// For PHYSPECIAL.c
+#undef GLOBAL
+#ifdef PHYMISC_C
+#define GLOBAL
+#else
+#define GLOBAL    extern
+#endif
+
+
+#endif // End COMMINF_H
diff -Naur uboot/oem/ami/standalone/nettest/mac_api.h uboot-new/oem/ami/standalone/nettest/mac_api.h
--- uboot/oem/ami/standalone/nettest/mac_api.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/mac_api.h	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,31 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MAC_API_H
+#define MAC_API_H
+
+uint32_t mac_reg_read(MAC_ENGINE *p_eng, uint32_t addr);
+void mac_reg_write(MAC_ENGINE *p_eng, uint32_t addr, uint32_t data);
+void mac_set_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d);
+void mac_get_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d);
+void mac_set_driving_strength(MAC_ENGINE *p_eng, uint32_t strength);
+uint32_t mac_get_driving_strength(MAC_ENGINE *p_eng);
+void mac_set_rmii_50m_output_enable(MAC_ENGINE *p_eng);
+int mac_set_scan_boundary(MAC_ENGINE *p_eng);
+void mac_set_addr(MAC_ENGINE *p_eng);
+void mac_set_interal_loopback(MAC_ENGINE *p_eng);
+
+void PrintIO_Line(MAC_ENGINE *p_eng, uint8_t option);
+void PrintIO_LineS(MAC_ENGINE *p_eng, uint8_t option);
+void FPri_End(MAC_ENGINE *eng, uint8_t option);
+void FPri_RegValue(MAC_ENGINE *eng, uint8_t option);
+
+#endif
diff -Naur uboot/oem/ami/standalone/nettest/mac.c uboot-new/oem/ami/standalone/nettest/mac.c
--- uboot/oem/ami/standalone/nettest/mac.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/mac.c	2020-11-20 04:00:27.000000000 -0500
@@ -0,0 +1,2356 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+//#define MAC_DEBUG_REGRW_MAC
+//#define MAC_DEBUG_REGRW_PHY
+//#define MAC_DEBUG_REGRW_SCU
+//#define MAC_DEBUG_REGRW_WDT
+//#define MAC_DEBUG_REGRW_SDR
+//#define MAC_DEBUG_REGRW_SMB
+//#define MAC_DEBUG_REGRW_TIMER
+//#define MAC_DEBUG_REGRW_GPIO
+//#define MAC_DEBUG_MEMRW_Dat
+//#define MAC_DEBUG_MEMRW_Des
+
+#define MAC_C
+
+#include "swfunc.h"
+
+#include "comminf.h"
+#include <command.h>
+#include <common.h>
+#include <malloc.h>
+#include "mem_io.h"
+// -------------------------------------------------------------
+const uint32_t ARP_org_data[16] = {
+    0xffffffff,
+    0x0000ffff, // SA:00-00-
+    0x12345678, // SA:78-56-34-12
+    0x01000608, // ARP(0x0806)
+    0x04060008,
+    0x00000100, // sender MAC Address: 00 00
+    0x12345678, // sender MAC Address: 12 34 56 78
+    0xeb00a8c0, // sender IP Address:  192.168.0.235 (C0.A8.0.EB)
+    0x00000000, // target MAC Address: 00 00 00 00
+    0xa8c00000, // target MAC Address: 00 00, target IP Address:192.168
+    0x00005c00, // target IP Address:  0.92 (C0.A8.0.5C)
+		//	0x00000100, // target IP Address:  0.1 (C0.A8.0.1)
+		//	0x0000de00, // target IP Address:  0.222 (C0.A8.0.DE)
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xc68e2bd5};
+
+//------------------------------------------------------------
+// Read Memory
+//------------------------------------------------------------
+uint32_t Read_Mem_Dat_NCSI_DD(uint32_t addr)
+{
+#ifdef MAC_DEBUG_MEMRW_Dat
+	printf("[MEMRd-Dat] %08x = %08x\n", addr, SWAP_4B_LEDN_MEM( readl(addr) ) );
+#endif
+	return ( SWAP_4B_LEDN_MEM( readl(addr) ) );
+}
+
+uint32_t Read_Mem_Des_NCSI_DD(uint32_t addr)
+{
+#ifdef MAC_DEBUG_MEMRW_Des
+	printf("[MEMRd-Des] %08x = %08x\n", addr,
+	       SWAP_4B_LEDN_MEM(readl(addr)));
+#endif
+	return (SWAP_4B_LEDN_MEM(readl(addr)));
+}
+
+uint32_t Read_Mem_Dat_DD(uint32_t addr)
+{
+#ifdef MAC_DEBUG_MEMRW_Dat
+	printf("[MEMRd-Dat] %08x = %08x\n", addr,
+	       SWAP_4B_LEDN_MEM(readl(addr)));
+#endif
+	return (SWAP_4B_LEDN_MEM(readl(addr)));
+}
+
+uint32_t Read_Mem_Des_DD(uint32_t addr)
+{
+#ifdef MAC_DEBUG_MEMRW_Des
+	printf("[MEMRd-Des] %08x = %08x\n", addr,
+	       SWAP_4B_LEDN_MEM(readl(addr)));
+#endif
+	return (SWAP_4B_LEDN_MEM(readl(addr)));
+}
+
+//------------------------------------------------------------
+// Read Register
+//------------------------------------------------------------
+uint32_t mac_reg_read(MAC_ENGINE *p_eng, uint32_t addr)
+{
+	return readl(p_eng->run.mac_base + addr);
+}
+
+//------------------------------------------------------------
+// Write Memory
+//------------------------------------------------------------
+void Write_Mem_Dat_NCSI_DD (uint32_t addr, uint32_t data) {
+#ifdef MAC_DEBUG_MEMRW_Dat
+	printf("[MEMWr-Dat] %08x = %08x\n", addr, SWAP_4B_LEDN_MEM( data ) );
+#endif
+	writel(data, addr);
+}
+void Write_Mem_Des_NCSI_DD (uint32_t addr, uint32_t data) {
+#ifdef MAC_DEBUG_MEMRW_Des
+	printf("[MEMWr-Des] %08x = %08x\n", addr, SWAP_4B_LEDN_MEM( data ) );
+#endif
+	writel(data, addr);
+}
+void Write_Mem_Dat_DD (uint32_t addr, uint32_t data) {
+#ifdef MAC_DEBUG_MEMRW_Dat
+	printf("[MEMWr-Dat] %08x = %08x\n", addr, SWAP_4B_LEDN_MEM( data ) );
+#endif
+	writel(data, addr);
+}
+void Write_Mem_Des_DD (uint32_t addr, uint32_t data) {
+#ifdef MAC_DEBUG_MEMRW_Des
+	printf("[MEMWr-Des] %08x = %08x\n", addr, SWAP_4B_LEDN_MEM( data ) );
+#endif
+	writel(data, addr);
+}
+
+//------------------------------------------------------------
+// Write Register
+//------------------------------------------------------------
+void mac_reg_write(MAC_ENGINE *p_eng, uint32_t addr, uint32_t data)
+{
+	writel(data, p_eng->run.mac_base + addr);
+}
+
+
+//------------------------------------------------------------
+// Others
+//------------------------------------------------------------
+void debug_pause (void) {
+#ifdef DbgPrn_Enable_Debug_pause
+	GET_CAHR();
+#endif
+}
+
+//------------------------------------------------------------
+void dump_mac_ROreg(MAC_ENGINE *p_eng) 
+{	
+	int i = 0xa0;
+
+	printf("\nMAC%d base 0x%08x", p_eng->run.mac_idx, p_eng->run.mac_base);
+	printf("\n%02x:", i);
+	for (i = 0xa0; i <= 0xc8; i += 4) {
+		printf("%08x ", mac_reg_read(p_eng, i));
+		if ((i & 0xf) == 0xc)
+			printf("\n%02x:", i + 4);
+	}
+	printf("\n");
+}
+
+//------------------------------------------------------------
+// IO delay
+//------------------------------------------------------------
+static void get_mac_1g_delay_1(uint32_t addr, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	int tx_d, rx_d;
+	mac_delay_1g_t reg;
+
+	reg.w = readl(addr);
+	tx_d = reg.b.tx_delay_1;
+	rx_d = reg.b.rx_delay_1;	
+#ifdef CONFIG_ASPEED_AST2600
+	if (reg.b.rx_clk_inv_1 == 1) {
+		rx_d = (-1) * rx_d;
+	}
+#endif
+	*p_tx_d = tx_d;
+	*p_rx_d = rx_d;
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+static void get_mac_1g_delay_2(uint32_t addr, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	int tx_d, rx_d;
+	mac_delay_1g_t reg;
+
+	reg.w = readl(addr);
+	tx_d = reg.b.tx_delay_2;
+	rx_d = reg.b.rx_delay_2;	
+#ifdef CONFIG_ASPEED_AST2600
+	if (reg.b.rx_clk_inv_2 == 1) {
+		rx_d = (-1) * rx_d;
+	}
+#endif
+	*p_tx_d = tx_d;
+	*p_rx_d = rx_d;
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+static void get_mac_100_10_delay_1(uint32_t addr, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	int tx_d, rx_d;
+	mac_delay_100_10_t reg;
+
+	reg.w = readl(addr);
+	tx_d = reg.b.tx_delay_1;
+	rx_d = reg.b.rx_delay_1;	
+#ifdef CONFIG_ASPEED_AST2600
+	if (reg.b.rx_clk_inv_1 == 1) {
+		rx_d = (-1) * rx_d;
+	}
+#endif
+	*p_tx_d = tx_d;
+	*p_rx_d = rx_d;
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+static void get_mac_100_10_delay_2(uint32_t addr, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	int tx_d, rx_d;
+	mac_delay_100_10_t reg;
+
+	reg.w = readl(addr);
+	tx_d = reg.b.tx_delay_2;
+	rx_d = reg.b.rx_delay_2;	
+#ifdef CONFIG_ASPEED_AST2600
+	if (reg.b.rx_clk_inv_2 == 1) {
+		rx_d = (-1) * rx_d;
+	}
+#endif
+	*p_tx_d = tx_d;
+	*p_rx_d = rx_d;
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+static void get_mac_rmii_delay_1(uint32_t addr, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	mac_delay_1g_t reg;
+	
+	reg.w = readl(addr);
+	*p_rx_d = reg.b.rx_delay_1;
+	*p_tx_d = reg.b.rmii_tx_data_at_falling_1;
+
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       *p_rx_d, *p_tx_d);
+}
+static void get_mac_rmii_delay_2(uint32_t addr, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	mac_delay_1g_t reg;
+	
+	reg.w = readl(addr);
+	*p_rx_d = reg.b.rx_delay_2;
+	*p_tx_d = reg.b.rmii_tx_data_at_falling_2;
+
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       *p_rx_d, *p_tx_d);
+}
+
+static 
+void get_mac1_1g_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_1g_delay_1(p_eng->io.mac12_1g_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac1_100m_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_100_10_delay_1(p_eng->io.mac12_100m_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac1_10m_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_100_10_delay_1(p_eng->io.mac12_10m_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac2_1g_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_1g_delay_2(p_eng->io.mac12_1g_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac2_100m_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_100_10_delay_2(p_eng->io.mac12_100m_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac2_10m_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_100_10_delay_2(p_eng->io.mac12_10m_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac3_1g_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_1g_delay_1(p_eng->io.mac34_1g_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac3_100m_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_100_10_delay_1(p_eng->io.mac34_100m_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac3_10m_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_100_10_delay_1(p_eng->io.mac34_10m_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac4_1g_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_1g_delay_2(p_eng->io.mac34_1g_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac4_100m_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_100_10_delay_2(p_eng->io.mac34_100m_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac4_10m_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_100_10_delay_2(p_eng->io.mac34_10m_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac1_rmii_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_rmii_delay_1(p_eng->io.mac12_1g_delay.addr, p_rx_d, p_tx_d);	
+}
+static
+void get_mac2_rmii_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_rmii_delay_2(p_eng->io.mac12_1g_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac3_rmii_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_rmii_delay_1(p_eng->io.mac34_1g_delay.addr, p_rx_d, p_tx_d);
+}
+static
+void get_mac4_rmii_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	get_mac_rmii_delay_2(p_eng->io.mac34_1g_delay.addr, p_rx_d, p_tx_d);
+}
+#if !defined(CONFIG_ASPEED_AST2600)
+static
+void get_dummy_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	debug("%s\n", __func__);
+}
+#endif
+
+/**
+ * @brief function pointer table to get current delay setting
+ * 
+ * get_delay_func_tbl[rmii/rgmii][mac_idx][speed_idx 1g/100m/10m]
+*/
+typedef void (*pfn_get_delay) (MAC_ENGINE *, int32_t *, int32_t *);
+pfn_get_delay get_delay_func_tbl[2][4][3] = {
+	{
+		{get_mac1_rmii_delay, get_mac1_rmii_delay, get_mac1_rmii_delay},
+		{get_mac2_rmii_delay, get_mac2_rmii_delay, get_mac2_rmii_delay},
+#if defined(CONFIG_ASPEED_AST2600)
+		{get_mac3_rmii_delay, get_mac3_rmii_delay, get_mac3_rmii_delay},
+		{get_mac4_rmii_delay, get_mac4_rmii_delay, get_mac4_rmii_delay},
+#else
+		{get_dummy_delay, get_dummy_delay, get_dummy_delay},
+		{get_dummy_delay, get_dummy_delay, get_dummy_delay},
+#endif		
+	},
+	{
+		{get_mac1_1g_delay, get_mac1_100m_delay, get_mac1_10m_delay},
+		{get_mac2_1g_delay, get_mac2_100m_delay, get_mac2_10m_delay},
+#if defined(CONFIG_ASPEED_AST2600)		
+		{get_mac3_1g_delay, get_mac3_100m_delay, get_mac3_10m_delay},
+		{get_mac4_1g_delay, get_mac4_100m_delay, get_mac4_10m_delay},
+#else
+		{get_dummy_delay, get_dummy_delay, get_dummy_delay},
+		{get_dummy_delay, get_dummy_delay, get_dummy_delay},
+#endif		
+	}
+};
+void mac_get_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+#if 1
+	uint32_t rgmii = (uint32_t)p_eng->run.is_rgmii;
+	uint32_t mac_idx = p_eng->run.mac_idx;
+	uint32_t speed_idx = p_eng->run.speed_idx;
+
+	get_delay_func_tbl[rgmii][mac_idx][speed_idx] (p_eng, p_rx_d, p_tx_d);
+#else
+	/* for test */
+	uint32_t rgmii;
+	uint32_t mac_idx;
+	uint32_t speed_idx;
+	for (rgmii = 0; rgmii < 2; rgmii++)
+		for (mac_idx = 0; mac_idx < 4; mac_idx++)
+			for (speed_idx = 0; speed_idx < 3; speed_idx++)
+				get_delay_func_tbl[rgmii][mac_idx][speed_idx](
+				    p_eng, p_rx_d, p_tx_d);
+#endif	
+}
+
+void mac_get_max_available_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	uint32_t rgmii = (uint32_t)p_eng->run.is_rgmii;
+	uint32_t mac_idx = p_eng->run.mac_idx;
+	int32_t tx_max, rx_max;
+
+	if (rgmii) {
+		if (mac_idx > 1) {
+			tx_max = p_eng->io.mac34_1g_delay.tx_max;
+			rx_max = p_eng->io.mac34_1g_delay.rx_max;
+		} else {
+			tx_max = p_eng->io.mac12_1g_delay.tx_max;
+			rx_max = p_eng->io.mac12_1g_delay.rx_max;
+		}
+	} else {
+		if (mac_idx > 1) {
+			tx_max = p_eng->io.mac34_1g_delay.rmii_tx_max;
+			rx_max = p_eng->io.mac34_1g_delay.rmii_rx_max;
+		} else {
+			tx_max = p_eng->io.mac12_1g_delay.rmii_tx_max;
+			rx_max = p_eng->io.mac12_1g_delay.rmii_rx_max;
+		}
+	}
+	*p_tx_d = tx_max;
+	*p_rx_d = rx_max;
+}
+
+void mac_get_min_available_delay(MAC_ENGINE *p_eng, int32_t *p_rx_d, int32_t *p_tx_d)
+{
+	uint32_t rgmii = (uint32_t)p_eng->run.is_rgmii;
+	uint32_t mac_idx = p_eng->run.mac_idx;
+	int32_t tx_min, rx_min;
+
+	if (rgmii) {
+		if (mac_idx > 1) {
+			tx_min = p_eng->io.mac34_1g_delay.tx_min;
+			rx_min = p_eng->io.mac34_1g_delay.rx_min;
+		} else {
+			tx_min = p_eng->io.mac12_1g_delay.tx_min;
+			rx_min = p_eng->io.mac12_1g_delay.rx_min;
+		}
+	} else {
+		if (mac_idx > 1) {
+			tx_min = p_eng->io.mac34_1g_delay.rmii_tx_min;
+			rx_min = p_eng->io.mac34_1g_delay.rmii_rx_min;
+		} else {
+			tx_min = p_eng->io.mac12_1g_delay.rmii_tx_min;
+			rx_min = p_eng->io.mac12_1g_delay.rmii_rx_min;
+		}
+	}
+	*p_tx_d = tx_min;
+	*p_rx_d = rx_min;
+}
+
+static void set_mac_1g_delay_1(uint32_t addr, int32_t rx_d, int32_t tx_d)
+{
+	mac_delay_1g_t reg;
+
+	reg.w = readl(addr);
+#ifdef CONFIG_ASPEED_AST2600
+	if (rx_d < 0) {
+		reg.b.rx_clk_inv_1 = 1;
+		rx_d = abs(rx_d);
+	}
+#endif
+	reg.b.rx_delay_1 = rx_d;
+	reg.b.tx_delay_1 = tx_d;
+	writel(reg.w, addr);
+
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+static void set_mac_1g_delay_2(uint32_t addr, int32_t rx_d, int32_t tx_d)
+{
+	mac_delay_1g_t reg;
+
+	reg.w = readl(addr);
+#ifdef CONFIG_ASPEED_AST2600
+	if (rx_d < 0) {
+		reg.b.rx_clk_inv_2 = 1;
+		rx_d = abs(rx_d);
+	}
+#endif
+	reg.b.rx_delay_2 = rx_d;
+	reg.b.tx_delay_2 = tx_d;
+	writel(reg.w, addr);
+
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+static void set_mac_100_10_delay_1(uint32_t addr, int32_t rx_d, int32_t tx_d)
+{
+	mac_delay_100_10_t reg;
+
+	reg.w = readl(addr);
+#ifdef CONFIG_ASPEED_AST2600
+	if (rx_d < 0) {
+		reg.b.rx_clk_inv_1 = 1;
+		rx_d = abs(rx_d);
+	}
+#endif
+	reg.b.rx_delay_1 = rx_d;
+	reg.b.tx_delay_1 = tx_d;
+	writel(reg.w, addr);
+
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+static void set_mac_100_10_delay_2(uint32_t addr, int32_t rx_d, int32_t tx_d)
+{
+	mac_delay_100_10_t reg;
+
+	reg.w = readl(addr);
+#ifdef CONFIG_ASPEED_AST2600
+	if (rx_d < 0) {
+		reg.b.rx_clk_inv_2 = 1;
+		rx_d = abs(rx_d);
+	}
+#endif
+	reg.b.rx_delay_2 = rx_d;
+	reg.b.tx_delay_2 = tx_d;
+	writel(reg.w, addr);
+
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+static void set_mac_rmii_delay_1(uint32_t addr, int32_t rx_d, int32_t tx_d)
+{
+	mac_delay_1g_t reg;
+
+	reg.w = readl(addr);
+	reg.b.rmii_tx_data_at_falling_1 = tx_d;
+	reg.b.rx_delay_1 = rx_d;
+	writel(reg.w, addr);
+
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+static void set_mac_rmii_delay_2(uint32_t addr, int32_t rx_d, int32_t tx_d)
+{
+	mac_delay_1g_t reg;
+
+	reg.w = readl(addr);
+	reg.b.rmii_tx_data_at_falling_2 = tx_d;
+	reg.b.rx_delay_2 = rx_d;
+	writel(reg.w, addr);
+
+	debug("%s:[%08x] %08x, rx_d=%d, tx_d=%d\n", __func__, addr, reg.w,
+	       rx_d, tx_d);
+}
+
+
+static void set_mac1_1g_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_1g_delay_1(p_eng->io.mac12_1g_delay.addr, rx_d, tx_d);
+}
+static void set_mac1_100m_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_100_10_delay_1(p_eng->io.mac12_100m_delay.addr, rx_d, tx_d);
+}
+static void set_mac1_10m_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_100_10_delay_1(p_eng->io.mac12_10m_delay.addr, rx_d, tx_d);
+}
+static void set_mac2_1g_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_1g_delay_2(p_eng->io.mac12_1g_delay.addr, rx_d, tx_d);
+}
+static void set_mac2_100m_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_100_10_delay_2(p_eng->io.mac12_100m_delay.addr, rx_d, tx_d);
+}
+static void set_mac2_10m_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_100_10_delay_2(p_eng->io.mac12_10m_delay.addr, rx_d, tx_d);
+}
+static void set_mac3_1g_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_1g_delay_1(p_eng->io.mac34_1g_delay.addr, rx_d, tx_d);
+}
+static void set_mac3_100m_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_100_10_delay_1(p_eng->io.mac34_100m_delay.addr, rx_d, tx_d);
+}
+static void set_mac3_10m_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_100_10_delay_1(p_eng->io.mac34_10m_delay.addr, rx_d, tx_d);
+}
+static void set_mac4_1g_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_1g_delay_2(p_eng->io.mac34_1g_delay.addr, rx_d, tx_d);
+}
+static void set_mac4_100m_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_100_10_delay_2(p_eng->io.mac34_100m_delay.addr, rx_d, tx_d);
+}
+static void set_mac4_10m_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_100_10_delay_2(p_eng->io.mac34_10m_delay.addr, rx_d, tx_d);
+}
+static void set_mac1_rmii_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_rmii_delay_1(p_eng->io.mac12_1g_delay.addr, rx_d, tx_d);
+}
+static void set_mac2_rmii_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_rmii_delay_2(p_eng->io.mac12_1g_delay.addr, rx_d, tx_d);
+}
+
+static void set_mac3_rmii_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_rmii_delay_1(p_eng->io.mac34_1g_delay.addr, rx_d, tx_d);
+}
+
+static void set_mac4_rmii_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	set_mac_rmii_delay_2(p_eng->io.mac34_1g_delay.addr, rx_d, tx_d);
+}
+
+void set_dummy_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	printf("%s: %d, %d\n", __func__, rx_d, tx_d);
+}
+
+/**
+ * @brief function pointer table for delay setting
+ * 
+ * set_delay_func_tbl[rmii/rgmii][mac_idx][speed_idx 1g/100m/10m]
+*/
+typedef void (*pfn_set_delay) (MAC_ENGINE *, int32_t, int32_t);
+pfn_set_delay set_delay_func_tbl[2][4][3] = {
+	{
+		{set_mac1_rmii_delay, set_mac1_rmii_delay, set_mac1_rmii_delay},
+		{set_mac2_rmii_delay, set_mac2_rmii_delay, set_mac2_rmii_delay},
+#if defined(CONFIG_ASPEED_AST2600)
+		{set_mac3_rmii_delay, set_mac3_rmii_delay, set_mac3_rmii_delay},
+		{set_mac4_rmii_delay, set_mac4_rmii_delay, set_mac4_rmii_delay},
+#else
+		{set_dummy_delay, set_dummy_delay, set_dummy_delay},
+		{set_dummy_delay, set_dummy_delay, set_dummy_delay},
+#endif		
+	},
+	{
+		{set_mac1_1g_delay, set_mac1_100m_delay, set_mac1_10m_delay},
+		{set_mac2_1g_delay, set_mac2_100m_delay, set_mac2_10m_delay},
+#if defined(CONFIG_ASPEED_AST2600)		
+		{set_mac3_1g_delay, set_mac3_100m_delay, set_mac3_10m_delay},
+		{set_mac4_1g_delay, set_mac4_100m_delay, set_mac4_10m_delay},
+#else
+		{set_dummy_delay, set_dummy_delay, set_dummy_delay},
+		{set_dummy_delay, set_dummy_delay, set_dummy_delay},
+#endif		
+	}
+};
+
+void mac_set_delay(MAC_ENGINE *p_eng, int32_t rx_d, int32_t tx_d)
+{
+	uint32_t rgmii = (uint32_t)p_eng->run.is_rgmii;
+	uint32_t mac_idx = p_eng->run.mac_idx;
+	uint32_t speed_idx = p_eng->run.speed_idx;	
+
+	set_delay_func_tbl[rgmii][mac_idx][speed_idx] (p_eng, rx_d, tx_d);
+}
+
+uint32_t mac_get_driving_strength(MAC_ENGINE *p_eng)
+{
+#ifdef CONFIG_ASPEED_AST2600
+	mac34_drv_t reg;
+	
+	reg.w = readl(p_eng->io.mac34_drv_reg.addr);
+	/* ast2600 : only MAC#3 & MAC#4 have driving strength setting */
+	if (p_eng->run.mac_idx == 2) {
+		return (reg.b.mac3_tx_drv);
+	} else if (p_eng->run.mac_idx == 3) {
+		return (reg.b.mac4_tx_drv);
+	} else {
+		return 0;
+	}
+#else
+	mac12_drv_t reg;
+
+	reg.w = readl(p_eng->io.mac12_drv_reg.addr);
+	
+	if (p_eng->run.mac_idx == 0) {
+		return (reg.b.mac1_tx_drv);
+	} else if (p_eng->run.mac_idx == 1) {
+		return (reg.b.mac2_tx_drv);
+	} else {
+		return 0;
+	}
+#endif		
+}
+void mac_set_driving_strength(MAC_ENGINE *p_eng, uint32_t strength)
+{
+#ifdef CONFIG_ASPEED_AST2600
+	mac34_drv_t reg;
+
+	if (strength > p_eng->io.mac34_drv_reg.drv_max) {
+		printf("invalid driving strength value\n");
+		return;
+	}
+
+	/**
+	 * read->modify->write for driving strength control register 
+	 * ast2600 : only MAC#3 & MAC#4 have driving strength setting
+	 */
+	reg.w = readl(p_eng->io.mac34_drv_reg.addr);
+
+	/* ast2600 : only MAC#3 & MAC#4 have driving strength setting */
+	if (p_eng->run.mac_idx == 2) {
+		reg.b.mac3_tx_drv = strength;
+	} else if (p_eng->run.mac_idx == 3) {
+		reg.b.mac4_tx_drv = strength;
+	}
+
+	writel(reg.w, p_eng->io.mac34_drv_reg.addr);
+#else
+	mac12_drv_t reg;
+
+	if (strength > p_eng->io.mac12_drv_reg.drv_max) {
+		printf("invalid driving strength value\n");
+		return;
+	}
+
+	/* read->modify->write for driving strength control register */
+	reg.w = readl(p_eng->io.mac12_drv_reg.addr);
+	if (p_eng->run.is_rgmii) {
+		if (p_eng->run.mac_idx == 0) {
+			reg.b.mac1_rgmii_tx_drv =
+			    strength;
+		} else if (p_eng->run.mac_idx == 2) {
+			reg.b.mac2_rgmii_tx_drv =
+			    strength;
+		}
+	} else {
+		if (p_eng->run.mac_idx == 0) {
+			reg.b.mac1_rmii_tx_drv =
+			    strength;
+		} else if (p_eng->run.mac_idx == 1) {
+			reg.b.mac2_rmii_tx_drv =
+			    strength;
+		}
+	}
+	writel(reg.w, p_eng->io.mac12_drv_reg.addr);
+#endif
+}
+
+void mac_set_rmii_50m_output_enable(MAC_ENGINE *p_eng)
+{
+	uint32_t addr;
+	mac_delay_1g_t value;
+
+	if (p_eng->run.mac_idx > 1) {
+		addr = p_eng->io.mac34_1g_delay.addr;
+	} else {
+		addr = p_eng->io.mac12_1g_delay.addr;
+	}
+
+	value.w = readl(addr);
+	if (p_eng->run.mac_idx & BIT(0)) {
+		value.b.rmii_50m_oe_2 = 1;
+	} else {
+		value.b.rmii_50m_oe_1 = 1;
+	}
+	writel(value.w, addr);
+}
+
+//------------------------------------------------------------
+int mac_set_scan_boundary(MAC_ENGINE *p_eng)
+{
+	int32_t rx_cur, tx_cur;
+	int32_t rx_min, rx_max, tx_min, tx_max;
+	int32_t rx_scaling, tx_scaling;
+
+	nt_log_func_name();
+
+	/* get current delay setting */
+	mac_get_delay(p_eng, &rx_cur, &tx_cur);
+	
+	/* get physical boundaries */
+	mac_get_max_available_delay(p_eng, &rx_max, &tx_max);
+	mac_get_min_available_delay(p_eng, &rx_min, &tx_min);
+
+	if ((p_eng->run.is_rgmii) && (p_eng->arg.ctrl.b.inv_rgmii_rxclk)) {
+		rx_max = (rx_max > 0) ? 0 : rx_max;
+	} else {
+		rx_min = (rx_min < 0) ? 0 : rx_min;
+	}
+
+	if (p_eng->run.TM_IOTiming) {
+		if (p_eng->arg.ctrl.b.full_range) {
+			tx_scaling = 0;
+			rx_scaling = 0;
+		} else {
+			/* down-scaling to save test time */
+			tx_scaling = TX_DELAY_SCALING;
+			rx_scaling = RX_DELAY_SCALING;
+		}
+		p_eng->io.rx_delay_scan.step = 1;
+		p_eng->io.tx_delay_scan.step = 1;
+		p_eng->io.rx_delay_scan.begin = rx_min >> rx_scaling;
+		p_eng->io.rx_delay_scan.end = rx_max >> rx_scaling;
+		p_eng->io.tx_delay_scan.begin = tx_min >> tx_scaling;
+		p_eng->io.tx_delay_scan.end = tx_max >> tx_scaling;
+	} else if (p_eng->run.delay_margin) {
+		p_eng->io.rx_delay_scan.step = 1;
+		p_eng->io.tx_delay_scan.step = 1;
+		p_eng->io.rx_delay_scan.begin = rx_cur - p_eng->run.delay_margin;
+		p_eng->io.rx_delay_scan.end = rx_cur + p_eng->run.delay_margin;
+		p_eng->io.tx_delay_scan.begin = tx_cur - p_eng->run.delay_margin;
+		p_eng->io.tx_delay_scan.end = tx_cur + p_eng->run.delay_margin;
+	} else {
+		p_eng->io.rx_delay_scan.step = 1;
+		p_eng->io.tx_delay_scan.step = 1;
+		p_eng->io.rx_delay_scan.begin = 0;
+		p_eng->io.rx_delay_scan.end = 0;
+		p_eng->io.tx_delay_scan.begin = 0;
+		p_eng->io.tx_delay_scan.end = 0;
+	}
+
+	/* backup current setting as the original for plotting result */
+	p_eng->io.rx_delay_scan.orig = rx_cur;
+	p_eng->io.tx_delay_scan.orig = tx_cur;
+
+	/* check if setting is legal or not */
+	if (p_eng->io.rx_delay_scan.begin < rx_min)
+		p_eng->io.rx_delay_scan.begin = rx_min;
+
+	if (p_eng->io.tx_delay_scan.begin < tx_min)
+		p_eng->io.tx_delay_scan.begin = tx_min;
+
+	if (p_eng->io.rx_delay_scan.end > rx_max)
+		p_eng->io.rx_delay_scan.end = rx_max;
+
+	if (p_eng->io.tx_delay_scan.end > tx_max)
+		p_eng->io.tx_delay_scan.end = tx_max;
+
+	if (p_eng->io.rx_delay_scan.begin > p_eng->io.rx_delay_scan.end)
+		p_eng->io.rx_delay_scan.begin = p_eng->io.rx_delay_scan.end;
+
+	if (p_eng->io.tx_delay_scan.begin > p_eng->io.tx_delay_scan.end)
+		p_eng->io.tx_delay_scan.begin = p_eng->io.tx_delay_scan.end;
+
+	if (p_eng->run.IO_MrgChk) {
+		if ((p_eng->io.rx_delay_scan.orig <
+		     p_eng->io.rx_delay_scan.begin) ||
+		    (p_eng->io.rx_delay_scan.orig >
+		     p_eng->io.rx_delay_scan.end)) {
+			printf("Warning: current delay is not in the "
+			       "scan-range\n");
+			printf("RX delay scan range:%d ~ %d, curr:%d\n",
+			       p_eng->io.rx_delay_scan.begin,
+			       p_eng->io.rx_delay_scan.end,
+			       p_eng->io.rx_delay_scan.orig);
+			printf("TX delay scan range:%d ~ %d, curr:%d\n",
+			       p_eng->io.tx_delay_scan.begin,
+			       p_eng->io.tx_delay_scan.end,
+			       p_eng->io.tx_delay_scan.orig);
+		}
+	}
+
+	return (0);
+}
+
+//------------------------------------------------------------
+// MAC
+//------------------------------------------------------------
+void mac_set_addr(MAC_ENGINE *p_eng)
+{
+	nt_log_func_name();	
+	
+	uint32_t madr = p_eng->reg.mac_madr;
+	uint32_t ladr = p_eng->reg.mac_ladr;
+
+	if (((madr == 0x0000) && (ladr == 0x00000000)) ||
+	    ((madr == 0xffff) && (ladr == 0xffffffff))) {
+		/* FIXME: shall use random gen */    
+		madr = 0x0000000a;
+		ladr = 0xf7837dd4;
+	}
+
+	p_eng->inf.SA[0] = (madr >> 8) & 0xff; // MSB
+	p_eng->inf.SA[1] = (madr >> 0) & 0xff;
+	p_eng->inf.SA[2] = (ladr >> 24) & 0xff;
+	p_eng->inf.SA[3] = (ladr >> 16) & 0xff;
+	p_eng->inf.SA[4] = (ladr >> 8) & 0xff;
+	p_eng->inf.SA[5] = (ladr >> 0) & 0xff; // LSB	
+
+	printf("mac address: ");
+	for (int i = 0; i < 6; i++) {
+		printf("%02x:", p_eng->inf.SA[i]);
+	}
+	printf("\n");
+}
+
+void mac_set_interal_loopback(MAC_ENGINE *p_eng)
+{
+	uint32_t reg = mac_reg_read(p_eng, 0x40);
+	mac_reg_write(p_eng, 0x40, reg | BIT(30)); 
+}
+
+//------------------------------------------------------------
+void init_mac (MAC_ENGINE *eng) 
+{
+	nt_log_func_name();
+
+	mac_cr_t maccr;	
+
+#ifdef Enable_MAC_SWRst
+	maccr.w = 0;
+	maccr.b.sw_rst = 1;
+	mac_reg_write(eng, 0x50, maccr.w);
+
+	do {
+		DELAY(Delay_MACRst);
+		maccr.w = mac_reg_read(eng, 0x50);
+	} while(maccr.b.sw_rst);
+#endif
+
+	mac_reg_write(eng, 0x20, eng->run.tdes_base - ASPEED_DRAM_BASE);
+	mac_reg_write(eng, 0x24, eng->run.rdes_base - ASPEED_DRAM_BASE);
+
+	mac_reg_write(eng, 0x08, eng->reg.mac_madr);
+	mac_reg_write(eng, 0x0c, eng->reg.mac_ladr);
+
+#ifdef MAC_030_def
+	mac_reg_write( eng, 0x30, MAC_030_def );//Int Thr/Cnt
+#endif
+#ifdef MAC_034_def
+	mac_reg_write( eng, 0x34, MAC_034_def );//Poll Cnt
+#endif
+#ifdef MAC_038_def
+	mac_reg_write( eng, 0x38, MAC_038_def );
+#endif
+#ifdef MAC_048_def
+	mac_reg_write( eng, 0x48, MAC_048_def );
+#endif
+#ifdef MAC_058_def
+	mac_reg_write( eng, 0x58, MAC_058_def );
+#endif
+
+	if ( eng->arg.run_mode == MODE_NCSI )
+		mac_reg_write( eng, 0x4c, NCSI_RxDMA_PakSize );
+	else
+		mac_reg_write( eng, 0x4c, DMA_PakSize );
+
+	maccr.b.txdma_en = 1;
+	maccr.b.rxdma_en = 1;
+	maccr.b.txmac_en = 1;
+	maccr.b.rxmac_en = 1;
+	maccr.b.fulldup = 1;
+	maccr.b.crc_apd = 1;
+
+	if (eng->run.speed_sel[0]) {
+		maccr.b.gmac_mode = 1;
+	} else if (eng->run.speed_sel[1]) {
+		maccr.b.speed_100 = 1;
+	}
+
+	if (eng->arg.run_mode == MODE_NCSI) {
+		maccr.b.rx_broadpkt_en = 1;
+		maccr.b.speed_100 = 1;
+	}
+	else {
+		maccr.b.rx_alladr = 1;
+#ifdef Enable_Runt
+		maccr.b.rx_runt = 1;
+#endif
+	}
+	mac_reg_write(eng, 0x50, maccr.w);
+	DELAY(Delay_MACRst);
+} // End void init_mac (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+// Basic
+//------------------------------------------------------------
+void FPri_RegValue (MAC_ENGINE *eng, uint8_t option) 
+{
+	nt_log_func_name();
+
+	PRINTF( option, "[SRAM] Date:%08x\n", SRAM_RD( 0x88 ) );
+	PRINTF( option, "[SRAM]  80:%08x %08x %08x %08x\n", SRAM_RD( 0x80 ), SRAM_RD( 0x84 ), SRAM_RD( 0x88 ), SRAM_RD( 0x8c ) );
+	
+	PRINTF( option, "[SCU]  a0:%08x  a4:%08x  b8:%08x  bc:%08x\n", SCU_RD( 0x0a0 ), SCU_RD( 0x0a4 ), SCU_RD( 0x0b8 ), SCU_RD( 0x0bc ));
+
+	PRINTF( option, "[SCU] 13c:%08x 140:%08x 144:%08x 1dc:%08x\n", SCU_RD( 0x13c ), SCU_RD( 0x140 ), SCU_RD( 0x144 ), SCU_RD( 0x1dc ) );
+	PRINTF( option, "[WDT]  0c:%08x  2c:%08x  4c:%08x\n", eng->reg.WDT_00c, eng->reg.WDT_02c, eng->reg.WDT_04c );
+	PRINTF( option, "[MAC]  A0|%08x %08x %08x %08x\n", mac_reg_read( eng, 0xa0 ), mac_reg_read( eng, 0xa4 ), mac_reg_read( eng, 0xa8 ), mac_reg_read( eng, 0xac ) );
+	PRINTF( option, "[MAC]  B0|%08x %08x %08x %08x\n", mac_reg_read( eng, 0xb0 ), mac_reg_read( eng, 0xb4 ), mac_reg_read( eng, 0xb8 ), mac_reg_read( eng, 0xbc ) );
+	PRINTF( option, "[MAC]  C0|%08x %08x %08x\n",       mac_reg_read( eng, 0xc0 ), mac_reg_read( eng, 0xc4 ), mac_reg_read( eng, 0xc8 ) );
+
+} // End void FPri_RegValue (MAC_ENGINE *eng, uint8_t *fp)
+
+//------------------------------------------------------------
+void FPri_End (MAC_ENGINE *eng, uint8_t option) 
+{
+	nt_log_func_name();
+	if ((0 == eng->run.is_rgmii) && (eng->phy.RMIICK_IOMode != 0) &&
+	    eng->run.IO_MrgChk && eng->flg.all_fail) {
+		if ( eng->arg.ctrl.b.rmii_phy_in == 0 ) {
+			PRINTF( option, "\n\n\n\n\n\n[Info] The PHY's RMII reference clock pin is setting to the OUTPUT mode now.\n" );
+			PRINTF( option, "       Maybe you can run the INPUT mode command \"mactest  %d %d %d %d %d %d %d\".\n\n\n\n", eng->arg.mac_idx, eng->arg.run_speed, (eng->arg.ctrl.w | 0x80), eng->arg.loop_max, eng->arg.test_mode, eng->arg.phy_addr, eng->arg.delay_scan_range );
+		}
+		else {
+			PRINTF( option, "\n\n\n\n\n\n[Info] The PHY's RMII reference clock pin is setting to the INPUT mode now.\n" );
+			PRINTF( option, "       Maybe you can run the OUTPUT mode command \"mactest  %d %d %d %d %d %d %d\".\n\n\n\n", eng->arg.mac_idx, eng->arg.run_speed, (eng->arg.ctrl.w & 0x7f), eng->arg.loop_max, eng->arg.test_mode, eng->arg.phy_addr, eng->arg.delay_scan_range );
+		}
+	}
+
+	if (!eng->run.TM_RxDataEn) {
+	} else if (eng->flg.error) {
+		PRINTF(option, "                    \n----> fail !!!\n");
+	}
+
+	//------------------------------
+	//[Warning] PHY Address
+	//------------------------------
+	if ( eng->arg.run_mode == MODE_DEDICATED ) {
+		if ( eng->arg.phy_addr != eng->phy.Adr )
+			PRINTF( option, "\n[Warning] PHY Address change from %d to %d !!!\n", eng->arg.phy_addr, eng->phy.Adr );
+	}
+
+	/* [Warning] IO Strength */
+	if (eng->io.init_done) {
+#ifdef CONFIG_ASPEED_AST2600
+		if ((eng->io.mac34_drv_reg.value.b.mac3_tx_drv != 0x3) ||
+		    (eng->io.mac34_drv_reg.value.b.mac4_tx_drv != 0x3)) {
+			PRINTF(option,
+			       "\n[Warning] [%08x] bit[3:0] 0x%02x is not the recommended value "
+			       "0xf.\n",
+			       eng->io.mac34_drv_reg.addr,
+			       eng->io.mac34_drv_reg.value.w & 0xf);
+		}
+#else
+		if (eng->io.mac12_drv_reg.value.w) {
+			PRINTF(option,
+			       "\n[Warning] [%08X] 0x%08x is not the recommended value "
+			       "0.\n",
+			       eng->io.mac12_drv_reg.addr,
+			       eng->io.mac12_drv_reg.value.w);
+		}
+#endif
+	}
+
+	//------------------------------
+	//[Warning] IO Timing
+	//------------------------------
+	if ( eng->arg.run_mode == MODE_NCSI ) {
+		PRINTF( option, "\n[Arg] %d %d %d %d %d %d %d {%d}\n", eng->arg.mac_idx, eng->arg.GPackageTolNum, eng->arg.GChannelTolNum, eng->arg.test_mode, eng->arg.delay_scan_range, eng->arg.ctrl.w, eng->arg.GARPNumCnt, TIME_OUT_NCSI );
+
+		switch ( eng->ncsi_cap.PCI_DID_VID ) {
+			case PCI_DID_VID_Intel_82574L             : { PRINTF( option, "[NC]%08x %08x: Intel 82574L       \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82575_10d6         : { PRINTF( option, "[NC]%08x %08x: Intel 82575        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82575_10a7         : { PRINTF( option, "[NC]%08x %08x: Intel 82575        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82575_10a9         : { PRINTF( option, "[NC]%08x %08x: Intel 82575        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82576_10c9         : { PRINTF( option, "[NC]%08x %08x: Intel 82576        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82576_10e6         : { PRINTF( option, "[NC]%08x %08x: Intel 82576        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82576_10e7         : { PRINTF( option, "[NC]%08x %08x: Intel 82576        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82576_10e8         : { PRINTF( option, "[NC]%08x %08x: Intel 82576        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82576_1518         : { PRINTF( option, "[NC]%08x %08x: Intel 82576        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82576_1526         : { PRINTF( option, "[NC]%08x %08x: Intel 82576        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82576_150a         : { PRINTF( option, "[NC]%08x %08x: Intel 82576        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82576_150d         : { PRINTF( option, "[NC]%08x %08x: Intel 82576        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82599_10fb         : { PRINTF( option, "[NC]%08x %08x: Intel 82599        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_82599_1557         : { PRINTF( option, "[NC]%08x %08x: Intel 82599        \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_I210_1533          : { PRINTF( option, "[NC]%08x %08x: Intel I210         \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_I210_1537          : { PRINTF( option, "[NC]%08x %08x: Intel I210         \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_I350_1521          : { PRINTF( option, "[NC]%08x %08x: Intel I350         \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_I350_1523          : { PRINTF( option, "[NC]%08x %08x: Intel I350         \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_X540               : { PRINTF( option, "[NC]%08x %08x: Intel X540         \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_X550               : { PRINTF( option, "[NC]%08x %08x: Intel X550         \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_Broadwell_DE       : { PRINTF( option, "[NC]%08x %08x: Intel Broadwell-DE \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Intel_X722_37d0          : { PRINTF( option, "[NC]%08x %08x: Intel X722         \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Broadcom_BCM5718         : { PRINTF( option, "[NC]%08x %08x: Broadcom BCM5718   \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Broadcom_BCM5719         : { PRINTF( option, "[NC]%08x %08x: Broadcom BCM5719   \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Broadcom_BCM5720         : { PRINTF( option, "[NC]%08x %08x: Broadcom BCM5720   \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Broadcom_BCM5725         : { PRINTF( option, "[NC]%08x %08x: Broadcom BCM5725   \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Broadcom_BCM57810S       : { PRINTF( option, "[NC]%08x %08x: Broadcom BCM57810S \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Broadcom_Cumulus         : { PRINTF( option, "[NC]%08x %08x: Broadcom Cumulus   \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Broadcom_BCM57302        : { PRINTF( option, "[NC]%08x %08x: Broadcom BCM57302  \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Broadcom_BCM957452       : { PRINTF( option, "[NC]%08x %08x: Broadcom BCM957452 \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Mellanox_ConnectX_3_1003 : { PRINTF( option, "[NC]%08x %08x: Mellanox ConnectX-3\n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Mellanox_ConnectX_3_1007 : { PRINTF( option, "[NC]%08x %08x: Mellanox ConnectX-3\n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			case PCI_DID_VID_Mellanox_ConnectX_4      : { PRINTF( option, "[NC]%08x %08x: Mellanox ConnectX-4\n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			default:
+			switch ( eng->ncsi_cap.manufacturer_id ) {
+				case ManufacturerID_Intel    : { PRINTF( option, "[NC]%08x %08x: Intel              \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+				case ManufacturerID_Broadcom : { PRINTF( option, "[NC]%08x %08x: Broadcom           \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+				case ManufacturerID_Mellanox : { PRINTF( option, "[NC]%08x %08x: Mellanox           \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+				case ManufacturerID_Mellanox1: { PRINTF( option, "[NC]%08x %08x: Mellanox           \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+				case ManufacturerID_Emulex   : { PRINTF( option, "[NC]%08x %08x: Emulex             \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+				default                      : { PRINTF( option, "[NC]%08x %08x                     \n", eng->ncsi_cap.manufacturer_id, eng->ncsi_cap.PCI_DID_VID ); break; }
+			} // End switch ( eng->ncsi_cap.manufacturer_id )
+		} // End switch ( eng->ncsi_cap.PCI_DID_VID )
+	}
+	else {
+		PRINTF(option, "[PHY] @addr %d: id = %04x_%04x (%s)\n",
+		       eng->phy.Adr, eng->phy.id1, eng->phy.id2,
+		       eng->phy.phy_name);
+	} // End if ( eng->arg.run_mode == MODE_NCSI )	
+} // End void FPri_End (MAC_ENGINE *eng, uint8_t option)
+
+//------------------------------------------------------------
+void FPri_ErrFlag (MAC_ENGINE *eng, uint8_t option) 
+{
+	nt_log_func_name();
+	if ( eng->flg.print_en ) {
+		if ( eng->flg.warn ) {
+			if ( eng->flg.warn & Wrn_Flag_IOMarginOUF ) {
+				PRINTF(option, "[Warning] IO timing testing "
+					       "range out of boundary\n");
+
+				if (0 == eng->run.is_rgmii) {
+					PRINTF( option, "      (reg:%d,%d) %dx1(%d~%d,%d)\n", eng->io.Dly_in_reg_idx,
+											      eng->io.Dly_out_reg_idx,
+											      eng->run.delay_margin,
+											      eng->io.Dly_in_min,
+											      eng->io.Dly_in_max,
+											      eng->io.Dly_out_min );
+				}
+				else {
+					PRINTF( option, "      (reg:%d,%d) %dx%d(%d~%d,%d~%d)\n", eng->io.Dly_in_reg_idx,
+												  eng->io.Dly_out_reg_idx,
+												  eng->run.delay_margin,
+												  eng->run.delay_margin,
+												  eng->io.Dly_in_min,
+												  eng->io.Dly_in_max,
+												  eng->io.Dly_out_min,
+												  eng->io.Dly_out_max );
+				}
+			} // End if ( eng->flg.warn & Wrn_Flag_IOMarginOUF )
+			if ( eng->flg.warn & Wrn_Flag_RxErFloatting ) {
+				PRINTF( option, "[Warning] NCSI RXER pin may be floatting to the MAC !!!\n" );
+				PRINTF( option, "          Please contact with the ASPEED Inc. for more help.\n" );
+			} // End if ( eng->flg.warn & Wrn_Flag_RxErFloatting )
+		} // End if ( eng->flg.warn )
+
+		if ( eng->flg.error ) {
+			PRINTF( option, "\n\n" );
+//PRINTF( option, "error: %x\n\n", eng->flg.error );
+
+			if ( eng->flg.error & Err_Flag_PHY_Type                ) { PRINTF( option, "[Err] Unidentifiable PHY                                     \n" ); }
+			if ( eng->flg.error & Err_Flag_MALLOC_FrmSize          ) { PRINTF( option, "[Err] Malloc fail at frame size buffer                       \n" ); }
+			if ( eng->flg.error & Err_Flag_MALLOC_LastWP           ) { PRINTF( option, "[Err] Malloc fail at last WP buffer                          \n" ); }
+			if ( eng->flg.error & Err_Flag_Check_Buf_Data          ) { PRINTF( option, "[Err] Received data mismatch                                 \n" ); }
+			if ( eng->flg.error & Err_Flag_NCSI_Check_TxOwnTimeOut ) { PRINTF( option, "[Err] Time out of checking Tx owner bit in NCSI packet       \n" ); }
+			if ( eng->flg.error & Err_Flag_NCSI_Check_RxOwnTimeOut ) { PRINTF( option, "[Err] Time out of checking Rx owner bit in NCSI packet       \n" ); }
+			if ( eng->flg.error & Err_Flag_NCSI_Check_ARPOwnTimeOut) { PRINTF( option, "[Err] Time out of checking ARP owner bit in NCSI packet      \n" ); }
+			if ( eng->flg.error & Err_Flag_NCSI_No_PHY             ) { PRINTF( option, "[Err] Can not find NCSI PHY                                  \n" ); }
+			if ( eng->flg.error & Err_Flag_NCSI_Channel_Num        ) { PRINTF( option, "[Err] NCSI Channel Number Mismatch                           \n" ); }
+			if ( eng->flg.error & Err_Flag_NCSI_Package_Num        ) { PRINTF( option, "[Err] NCSI Package Number Mismatch                           \n" ); }
+			if ( eng->flg.error & Err_Flag_PHY_TimeOut_RW          ) { PRINTF( option, "[Err] Time out of read/write PHY register                    \n" ); }
+			if ( eng->flg.error & Err_Flag_PHY_TimeOut_Rst         ) { PRINTF( option, "[Err] Time out of reset PHY register                         \n" ); }
+			if ( eng->flg.error & Err_Flag_RXBUF_UNAVA             ) { PRINTF( option, "[Err] MAC00h[2]:Receiving buffer unavailable                 \n" ); }
+			if ( eng->flg.error & Err_Flag_RPKT_LOST               ) { PRINTF( option, "[Err] MAC00h[3]:Received packet lost due to RX FIFO full     \n" ); }
+			if ( eng->flg.error & Err_Flag_NPTXBUF_UNAVA           ) { PRINTF( option, "[Err] MAC00h[6]:Normal priority transmit buffer unavailable  \n" ); }
+			if ( eng->flg.error & Err_Flag_TPKT_LOST               ) { PRINTF( option, "[Err] MAC00h[7]:Packets transmitted to Ethernet lost         \n" ); }
+			if ( eng->flg.error & Err_Flag_DMABufNum               ) { PRINTF( option, "[Err] DMA Buffer is not enough                               \n" ); }
+			if ( eng->flg.error & Err_Flag_IOMargin                ) { PRINTF( option, "[Err] IO timing margin is not enough                         \n" ); }
+
+			if ( eng->flg.error & Err_Flag_MHCLK_Ratio             ) {
+				PRINTF( option, "[Err] Error setting of MAC AHB bus clock (SCU08[18:16])      \n" );
+				if ( eng->env.at_least_1g_valid )
+					{ PRINTF( option, "      SCU08[18:16] == 0x%01x is not the suggestion value 2.\n", eng->env.MHCLK_Ratio ); }
+				else
+					{ PRINTF( option, "      SCU08[18:16] == 0x%01x is not the suggestion value 4.\n", eng->env.MHCLK_Ratio ); }
+			} // End if ( eng->flg.error & Err_Flag_MHCLK_Ratio             )
+
+			if ( eng->flg.error & Err_Flag_IOMarginOUF ) {
+				PRINTF( option, "[Err] IO timing testing range out of boundary\n");
+				if (0 == eng->run.is_rgmii) {
+					PRINTF( option, "      (reg:%d,%d) %dx1(%d~%d,%d)\n", eng->io.Dly_in_reg_idx,
+											      eng->io.Dly_out_reg_idx,
+											      eng->run.delay_margin,
+											      eng->io.Dly_in_min,
+											      eng->io.Dly_in_max,
+											      eng->io.Dly_out_min );
+				}
+				else {
+					PRINTF( option, "      (reg:%d,%d) %dx%d(%d~%d,%d~%d)\n", eng->io.Dly_in_reg_idx,
+												  eng->io.Dly_out_reg_idx,
+												  eng->run.delay_margin,
+												  eng->run.delay_margin,
+												  eng->io.Dly_in_min,
+												  eng->io.Dly_in_max,
+												  eng->io.Dly_out_min,
+												  eng->io.Dly_out_max );
+				}
+			} // End if ( eng->flg.error & Err_Flag_IOMarginOUF )
+
+			if ( eng->flg.error & Err_Flag_Check_Des ) {
+				PRINTF( option, "[Err] Descriptor error\n");
+				if ( eng->flg.desc & Des_Flag_TxOwnTimeOut ) { PRINTF( option, "[Des] Time out of checking Tx owner bit\n" ); }
+				if ( eng->flg.desc & Des_Flag_RxOwnTimeOut ) { PRINTF( option, "[Des] Time out of checking Rx owner bit\n" ); }
+				if ( eng->flg.desc & Des_Flag_FrameLen     ) { PRINTF( option, "[Des] Frame length mismatch            \n" ); }
+				if ( eng->flg.desc & Des_Flag_RxErr        ) { PRINTF( option, "[Des] Input signal RxErr               \n" ); }
+				if ( eng->flg.desc & Des_Flag_CRC          ) { PRINTF( option, "[Des] CRC error of frame               \n" ); }
+				if ( eng->flg.desc & Des_Flag_FTL          ) { PRINTF( option, "[Des] Frame too long                   \n" ); }
+				if ( eng->flg.desc & Des_Flag_Runt         ) { PRINTF( option, "[Des] Runt packet                      \n" ); }
+				if ( eng->flg.desc & Des_Flag_OddNibble    ) { PRINTF( option, "[Des] Nibble bit happen                \n" ); }
+				if ( eng->flg.desc & Des_Flag_RxFIFOFull   ) { PRINTF( option, "[Des] Rx FIFO full                     \n" ); }
+			} // End if ( eng->flg.error & Err_Flag_Check_Des )
+
+			if ( eng->flg.error & Err_Flag_MACMode ) {
+				PRINTF( option, "[Err] MAC interface mode mismatch\n" );
+				for (int i = 0; i < 4; i++) {
+					if (eng->env.is_1g_valid[i]) {
+						PRINTF(option,
+						       "[MAC%d] is RGMII\n", i);
+					} else {
+						PRINTF(option,
+						       "[MAC%d] RMII\n", i);
+					}
+				}
+			} // End if ( eng->flg.error & Err_Flag_MACMode )
+
+			if ( eng->arg.run_mode == MODE_NCSI ) {
+				if ( eng->flg.error & ERR_FLAG_NCSI_LINKFAIL ) {
+					PRINTF( option, "[Err] NCSI packet retry number over flows when find channel\n" );
+
+					if ( eng->flg.ncsi & NCSI_Flag_Get_Version_ID                  ) { PRINTF( option, "[NCSI] Time out when Get Version ID                  \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Get_Capabilities                ) { PRINTF( option, "[NCSI] Time out when Get Capabilities                \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Select_Active_Package           ) { PRINTF( option, "[NCSI] Time out when Select Active Package           \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Enable_Set_MAC_Address          ) { PRINTF( option, "[NCSI] Time out when Enable Set MAC Address          \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Enable_Broadcast_Filter         ) { PRINTF( option, "[NCSI] Time out when Enable Broadcast Filter         \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Enable_Network_TX               ) { PRINTF( option, "[NCSI] Time out when Enable Network TX               \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Enable_Channel                  ) { PRINTF( option, "[NCSI] Time out when Enable Channel                  \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Disable_Network_TX              ) { PRINTF( option, "[NCSI] Time out when Disable Network TX              \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Disable_Channel                 ) { PRINTF( option, "[NCSI] Time out when Disable Channel                 \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Select_Package                  ) { PRINTF( option, "[NCSI] Time out when Select Package                  \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Deselect_Package                ) { PRINTF( option, "[NCSI] Time out when Deselect Package                \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Set_Link                        ) { PRINTF( option, "[NCSI] Time out when Set Link                        \n" ); }
+					if ( eng->flg.ncsi & NCSI_Flag_Get_Controller_Packet_Statistics) { PRINTF( option, "[NCSI] Time out when Get Controller Packet Statistics\n" ); }
+				}
+
+				if ( eng->flg.error & Err_Flag_NCSI_Channel_Num ) { PRINTF( option, "[NCSI] Channel number expected: %d, real: %d\n", eng->arg.GChannelTolNum, eng->dat.number_chl ); }
+				if ( eng->flg.error & Err_Flag_NCSI_Package_Num ) { PRINTF( option, "[NCSI] Peckage number expected: %d, real: %d\n", eng->arg.GPackageTolNum, eng->dat.number_pak ); }
+			} // End if ( eng->arg.run_mode == MODE_NCSI )
+		} // End if ( eng->flg.error )
+	} // End if ( eng->flg.print_en )
+} // End void FPri_ErrFlag (MAC_ENGINE *eng, uint8_t option)
+
+//------------------------------------------------------------
+
+//------------------------------------------------------------
+int FindErr (MAC_ENGINE *p_eng, int value) 
+{
+	p_eng->flg.error = p_eng->flg.error | value;
+
+	if (DBG_PRINT_ERR_FLAG)
+		printf("flags: error = %08x\n", p_eng->flg.error);
+
+	return (1);
+}
+
+//------------------------------------------------------------
+int FindErr_Des (MAC_ENGINE *p_eng, int value) 
+{
+	p_eng->flg.error = p_eng->flg.error | Err_Flag_Check_Des;
+	p_eng->flg.desc = p_eng->flg.desc | value;
+	if (DBG_PRINT_ERR_FLAG)
+		printf("flags: error = %08x, desc = %08x\n", p_eng->flg.error, p_eng->flg.desc);
+
+	return (1);
+}
+
+//------------------------------------------------------------
+// Get and Check status of Interrupt
+//------------------------------------------------------------
+int check_int (MAC_ENGINE *eng, char *type ) 
+{
+	nt_log_func_name();
+
+	uint32_t mac_00;
+
+	mac_00 = mac_reg_read(eng, 0x00);
+#ifdef CheckRxbufUNAVA
+	if (mac_00 & BIT(2)) {
+		PRINTF( FP_LOG, "[%sIntStatus] Receiving buffer unavailable               : %08x [loop[%d]:%d]\n", type, mac_00, eng->run.loop_of_cnt, eng->run.loop_cnt );
+		FindErr( eng, Err_Flag_RXBUF_UNAVA );
+	}
+#endif
+
+#ifdef CheckRPktLost
+	if (mac_00 & BIT(3)) {
+		PRINTF( FP_LOG, "[%sIntStatus] Received packet lost due to RX FIFO full   : %08x [loop[%d]:%d]\n", type, mac_00, eng->run.loop_of_cnt, eng->run.loop_cnt );
+		FindErr( eng, Err_Flag_RPKT_LOST );
+	}
+#endif
+
+#ifdef CheckNPTxbufUNAVA
+	if (mac_00 & BIT(6) ) {
+		PRINTF( FP_LOG, "[%sIntStatus] Normal priority transmit buffer unavailable: %08x [loop[%d]:%d]\n", type, mac_00, eng->run.loop_of_cnt, eng->run.loop_cnt );
+		FindErr( eng, Err_Flag_NPTXBUF_UNAVA );
+	}
+#endif
+
+#ifdef CheckTPktLost
+	if (mac_00 & BIT(7)) {
+		PRINTF( FP_LOG, "[%sIntStatus] Packets transmitted to Ethernet lost       : %08x [loop[%d]:%d]\n", type, mac_00, eng->run.loop_of_cnt, eng->run.loop_cnt );
+		FindErr( eng, Err_Flag_TPKT_LOST );
+	}
+#endif
+
+	if ( eng->flg.error )
+		return(1);
+	else
+		return(0);
+} // End int check_int (MAC_ENGINE *eng, char *type)
+
+
+//------------------------------------------------------------
+// Buffer
+//------------------------------------------------------------
+void setup_framesize (MAC_ENGINE *eng) 
+{
+	int32_t       des_num;
+
+	nt_log_func_name();
+
+	//------------------------------
+	// Fill Frame Size out descriptor area
+	//------------------------------
+	if (0) {
+		for ( des_num = 0; des_num < eng->dat.Des_Num; des_num++ ) {
+			if ( RAND_SIZE_SIMPLE )
+				switch( rand() % 5 ) {
+					case 0 : eng->dat.FRAME_LEN[ des_num ] = 0x4e ; break;
+					case 1 : eng->dat.FRAME_LEN[ des_num ] = 0x4ba; break;
+					default: eng->dat.FRAME_LEN[ des_num ] = 0x5ea; break;
+				}
+			else
+//				eng->dat.FRAME_LEN[ des_num ] = ( rand() + RAND_SIZE_MIN ) % ( RAND_SIZE_MAX + 1 );
+				eng->dat.FRAME_LEN[ des_num ] = RAND_SIZE_MIN + ( rand() % ( RAND_SIZE_MAX - RAND_SIZE_MIN + 1 ) );
+
+			if ( DbgPrn_FRAME_LEN )
+				PRINTF( FP_LOG, "[setup_framesize] FRAME_LEN_Cur:%08x[Des:%d][loop[%d]:%d]\n", eng->dat.FRAME_LEN[ des_num ], des_num, eng->run.loop_of_cnt, eng->run.loop_cnt );
+		}
+	}
+	else {
+		for ( des_num = 0; des_num < eng->dat.Des_Num; des_num++ ) {
+#ifdef SelectSimpleLength
+			if ( des_num % FRAME_SELH_PERD )
+				eng->dat.FRAME_LEN[ des_num ] = FRAME_LENH;
+			else
+				eng->dat.FRAME_LEN[ des_num ] = FRAME_LENL;
+#else
+			if ( eng->run.tm_tx_only ) {
+				if ( eng->run.TM_IEEE )
+					eng->dat.FRAME_LEN[ des_num ] = 1514;
+				else  
+					eng->dat.FRAME_LEN[ des_num ] = 60;  
+			}
+			else {
+  #ifdef SelectLengthInc
+				eng->dat.FRAME_LEN[ des_num ] = 1514 - ( des_num % 1455 );
+  #else
+				if ( des_num % FRAME_SELH_PERD )
+					eng->dat.FRAME_LEN[ des_num ] = FRAME_LENH;
+				else
+					eng->dat.FRAME_LEN[ des_num ] = FRAME_LENL;
+  #endif
+			} // End if ( eng->run.tm_tx_only )
+#endif
+			if ( DbgPrn_FRAME_LEN )
+				PRINTF( FP_LOG, "[setup_framesize] FRAME_LEN_Cur:%08x[Des:%d][loop[%d]:%d]\n", eng->dat.FRAME_LEN[ des_num ], des_num, eng->run.loop_of_cnt, eng->run.loop_cnt );
+
+		} // End for (des_num = 0; des_num < eng->dat.Des_Num; des_num++)
+	} // End if ( ENABLE_RAND_SIZE )
+
+	// Calculate average of frame size
+#ifdef Enable_ShowBW
+	eng->dat.Total_frame_len = 0;
+
+	for ( des_num = 0; des_num < eng->dat.Des_Num; des_num++ )
+		eng->dat.Total_frame_len += eng->dat.FRAME_LEN[ des_num ];
+#endif
+
+	//------------------------------
+	// Write Plane
+	//------------------------------
+	switch( ZeroCopy_OFFSET & 0x3 ) {
+		case 0: eng->dat.wp_fir = 0xffffffff; break;
+		case 1: eng->dat.wp_fir = 0xffffff00; break;
+		case 2: eng->dat.wp_fir = 0xffff0000; break;
+		case 3: eng->dat.wp_fir = 0xff000000; break;
+	}
+
+	for ( des_num = 0; des_num < eng->dat.Des_Num; des_num++ )
+		switch( ( ZeroCopy_OFFSET + eng->dat.FRAME_LEN[ des_num ] - 1 ) & 0x3 ) {
+			case 0: eng->dat.wp_lst[ des_num ] = 0x000000ff; break;
+			case 1: eng->dat.wp_lst[ des_num ] = 0x0000ffff; break;
+			case 2: eng->dat.wp_lst[ des_num ] = 0x00ffffff; break;
+			case 3: eng->dat.wp_lst[ des_num ] = 0xffffffff; break;
+		}
+} // End void setup_framesize (void)
+
+//------------------------------------------------------------
+void setup_arp(MAC_ENGINE *eng)
+{
+
+	nt_log_func_name();
+
+	memcpy(eng->dat.ARP_data, ARP_org_data, sizeof(ARP_org_data));
+
+	eng->dat.ARP_data[1] &= ~GENMASK(31, 16);
+	eng->dat.ARP_data[1] |= (eng->inf.SA[1] << 24) | (eng->inf.SA[0] << 16);
+	eng->dat.ARP_data[2] = (eng->inf.SA[5] << 24) | (eng->inf.SA[4] << 16) |
+			       (eng->inf.SA[3] << 8) | (eng->inf.SA[2]);
+	eng->dat.ARP_data[5] &= ~GENMASK(31, 16);
+	eng->dat.ARP_data[5] |= (eng->inf.SA[1] << 24) | (eng->inf.SA[0] << 16);
+	eng->dat.ARP_data[6] = (eng->inf.SA[5] << 24) | (eng->inf.SA[4] << 16) |
+			       (eng->inf.SA[3] << 8) | (eng->inf.SA[2]);
+}
+
+//------------------------------------------------------------
+void setup_buf (MAC_ENGINE *eng) 
+{
+	int32_t des_num_max;
+	int32_t des_num;
+	int i;
+	uint32_t adr;
+	uint32_t adr_srt;
+	uint32_t adr_end;
+	uint32_t Current_framelen;
+	uint32_t gdata = 0;
+#ifdef SelectSimpleDA	
+	int cnt;
+	uint32_t len;
+#endif	
+
+	nt_log_func_name();
+
+	// It need be multiple of 4
+	eng->dat.DMA_Base_Setup = DMA_BASE & 0xfffffffc;
+	adr_srt = eng->dat.DMA_Base_Setup;
+
+	if (eng->run.tm_tx_only) {
+		if (eng->run.TM_IEEE) {
+			for (des_num = 0; des_num < eng->dat.Des_Num; des_num++) {
+				if ( DbgPrn_BufAdr )
+					printf("[loop[%d]:%4d][des:%4d][setup_buf  ] %08x\n", eng->run.loop_of_cnt, eng->run.loop_cnt, des_num, adr_srt);
+				Write_Mem_Dat_DD(adr_srt, 0xffffffff);
+				Write_Mem_Dat_DD(adr_srt + 4,
+						 eng->dat.ARP_data[1]);
+				Write_Mem_Dat_DD(adr_srt + 8,
+						 eng->dat.ARP_data[2]);
+
+				for (adr = (adr_srt + 12);
+				     adr < (adr_srt + DMA_PakSize); adr += 4) {
+					switch (eng->arg.test_mode) {
+					case 4:
+						gdata = rand() | (rand() << 16);
+						break;
+					case 5:
+						gdata = eng->arg.user_def_val;
+						break;
+					}
+					Write_Mem_Dat_DD(adr, gdata);
+				}
+				adr_srt += DMA_PakSize;
+			}
+		} else {
+			printf("----->[ARP] 60 bytes\n");
+			for (i = 0; i < 16; i++)
+				printf("      [Tx%02d] %08x %08x\n", i, eng->dat.ARP_data[i], SWAP_4B( eng->dat.ARP_data[i] ) );
+
+			for ( des_num = 0; des_num < eng->dat.Des_Num; des_num++ ) {
+				if ( DbgPrn_BufAdr )
+					printf("[loop[%d]:%4d][des:%4d][setup_buf  ] %08x\n", eng->run.loop_of_cnt, eng->run.loop_cnt, des_num, adr_srt);
+
+				for (i = 0; i < 16; i++)
+					Write_Mem_Dat_DD( adr_srt + ( i << 2 ), eng->dat.ARP_data[i] );
+
+
+				adr_srt += DMA_PakSize;
+			} // End for (des_num = 0; des_num < eng->dat.Des_Num; des_num++)
+		} // End if ( eng->run.TM_IEEE )
+	} else {
+		if ( eng->arg.ctrl.b.single_packet )
+			des_num_max = 1;
+		else
+			des_num_max = eng->dat.Des_Num;
+
+		for (des_num = 0; des_num < des_num_max; des_num++) {
+			if (DbgPrn_BufAdr)
+				printf("[loop[%d]:%4d][des:%4d][setup_buf  ] %08x\n", eng->run.loop_of_cnt, eng->run.loop_cnt, des_num, adr_srt);
+  #ifdef SelectSimpleData
+    #ifdef SimpleData_Fix
+			switch( des_num % SimpleData_FixNum ) {
+				case  0 : gdata = SimpleData_FixVal00; break;
+				case  1 : gdata = SimpleData_FixVal01; break;
+				case  2 : gdata = SimpleData_FixVal02; break;
+				case  3 : gdata = SimpleData_FixVal03; break;
+				case  4 : gdata = SimpleData_FixVal04; break;
+				case  5 : gdata = SimpleData_FixVal05; break;
+				case  6 : gdata = SimpleData_FixVal06; break;
+				case  7 : gdata = SimpleData_FixVal07; break;
+				case  8 : gdata = SimpleData_FixVal08; break;
+				case  9 : gdata = SimpleData_FixVal09; break;
+				case 10 : gdata = SimpleData_FixVal10; break;
+				default : gdata = SimpleData_FixVal11; break;
+			}
+    #else
+			gdata   = 0x11111111 * ((des_num + SEED_START) % 256);
+    #endif
+  #else
+			gdata   = DATA_SEED( des_num + SEED_START );
+  #endif
+			Current_framelen = eng->dat.FRAME_LEN[ des_num ];
+
+			if ( DbgPrn_FRAME_LEN )
+				PRINTF( FP_LOG, "[setup_buf      ] Current_framelen:%08x[Des:%d][loop[%d]:%d]\n", Current_framelen, des_num, eng->run.loop_of_cnt, eng->run.loop_cnt );
+#ifdef SelectSimpleDA
+			cnt     = 0;
+			len     = ( ( ( Current_framelen - 14 ) & 0xff ) << 8) |
+			            ( ( Current_framelen - 14 ) >> 8 );
+#endif				    
+			adr_end = adr_srt + DMA_PakSize;
+			for ( adr = adr_srt; adr < adr_end; adr += 4 ) {
+  #ifdef SelectSimpleDA
+				cnt++;
+				if      ( cnt == 1 ) Write_Mem_Dat_DD( adr, SelectSimpleDA_Dat0 );
+				else if ( cnt == 2 ) Write_Mem_Dat_DD( adr, SelectSimpleDA_Dat1 );
+				else if ( cnt == 3 ) Write_Mem_Dat_DD( adr, SelectSimpleDA_Dat2 );
+				else if ( cnt == 4 ) Write_Mem_Dat_DD( adr, len | (len << 16)   );
+				else
+  #endif
+				                     Write_Mem_Dat_DD( adr, gdata );
+  #ifdef SelectSimpleData
+				gdata = gdata ^ SimpleData_XORVal;
+  #else
+				gdata += DATA_IncVal;
+  #endif
+			}
+			adr_srt += DMA_PakSize;
+		} // End for (des_num = 0; des_num < eng->dat.Des_Num; des_num++)
+	} // End if ( eng->run.tm_tx_only )
+} // End void setup_buf (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+// Check data of one packet
+//------------------------------------------------------------
+char check_Data (MAC_ENGINE *eng, uint32_t datbase, int32_t number) 
+{
+	int32_t       number_dat;
+	int        index;
+	uint32_t      rdata;
+	uint32_t      wp_lst_cur;
+	uint32_t      adr_las;
+	uint32_t      adr;
+	uint32_t      adr_srt;
+	uint32_t      adr_end;
+#ifdef SelectSimpleDA
+	int        cnt;
+	uint32_t      len;
+	uint32_t      gdata_bak;
+#endif
+	uint32_t      gdata;
+
+	uint32_t      wp;
+
+	nt_log_func_name();
+
+	if (eng->arg.ctrl.b.single_packet)
+		number_dat = 0;
+	else
+		number_dat = number;
+
+	wp_lst_cur             = eng->dat.wp_lst[ number ];
+	eng->dat.FRAME_LEN_Cur = eng->dat.FRAME_LEN[ number_dat ];
+
+	if ( DbgPrn_FRAME_LEN )
+		PRINTF( FP_LOG, "[check_Data     ] FRAME_LEN_Cur:%08x[Des:%d][loop[%d]:%d]\n", eng->dat.FRAME_LEN_Cur, number, eng->run.loop_of_cnt, eng->run.loop_cnt );
+
+	adr_srt = datbase;
+	adr_end = adr_srt + PktByteSize;
+
+#if defined(SelectSimpleData)
+    #ifdef SimpleData_Fix
+	switch( number_dat % SimpleData_FixNum ) {
+		case  0 : gdata = SimpleData_FixVal00; break;
+		case  1 : gdata = SimpleData_FixVal01; break;
+		case  2 : gdata = SimpleData_FixVal02; break;
+		case  3 : gdata = SimpleData_FixVal03; break;
+		case  4 : gdata = SimpleData_FixVal04; break;
+		case  5 : gdata = SimpleData_FixVal05; break;
+		case  6 : gdata = SimpleData_FixVal06; break;
+		case  7 : gdata = SimpleData_FixVal07; break;
+		case  8 : gdata = SimpleData_FixVal08; break;
+		case  9 : gdata = SimpleData_FixVal09; break;
+		case 10 : gdata = SimpleData_FixVal10; break;
+		default : gdata = SimpleData_FixVal11; break;
+	}
+    #else
+	gdata   = 0x11111111 * (( number_dat + SEED_START ) % 256 );
+    #endif
+#else
+	gdata   = DATA_SEED( number_dat + SEED_START );
+#endif
+
+//printf("check_buf: %08x - %08x [%08x]\n", adr_srt, adr_end, datbase);
+	wp      = eng->dat.wp_fir;
+	adr_las = adr_end - 4;
+#ifdef SelectSimpleDA
+	cnt     = 0;
+	len     = ((( eng->dat.FRAME_LEN_Cur-14 ) & 0xff ) << 8 ) |
+	          ( ( eng->dat.FRAME_LEN_Cur-14 )          >> 8 );
+#endif
+
+	if ( DbgPrn_Bufdat )
+		PRINTF( FP_LOG, " Inf:%08x ~ %08x(%08x) %08x [Des:%d][loop[%d]:%d]\n", adr_srt, adr_end, adr_las, gdata, number, eng->run.loop_of_cnt, eng->run.loop_cnt );
+
+	for ( adr = adr_srt; adr < adr_end; adr+=4 ) {
+#ifdef SelectSimpleDA
+		cnt++;
+		if      ( cnt == 1 ) { gdata_bak = gdata; gdata = SelectSimpleDA_Dat0; }
+		else if ( cnt == 2 ) { gdata_bak = gdata; gdata = SelectSimpleDA_Dat1; }
+		else if ( cnt == 3 ) { gdata_bak = gdata; gdata = SelectSimpleDA_Dat2; }
+		else if ( cnt == 4 ) { gdata_bak = gdata; gdata = len | (len << 16);   }
+#endif
+		rdata = Read_Mem_Dat_DD( adr );
+		if ( adr == adr_las )
+			wp = wp & wp_lst_cur;
+
+		if ( ( rdata & wp ) != ( gdata & wp ) ) {
+			PRINTF( FP_LOG, "\nError: Adr:%08x[%3d] (%08x) (%08x:%08x) [Des:%d][loop[%d]:%d]\n", adr, ( adr - adr_srt ) / 4, rdata, gdata, wp, number, eng->run.loop_of_cnt, eng->run.loop_cnt );
+			for ( index = 0; index < 6; index++ )
+				PRINTF( FP_LOG, "Rep  : Adr:%08x      (%08x) (%08x:%08x) [Des:%d][loop[%d]:%d]\n", adr, Read_Mem_Dat_DD( adr ), gdata, wp, number, eng->run.loop_of_cnt, eng->run.loop_cnt );
+
+			if (DbgPrn_DumpMACCnt)
+				dump_mac_ROreg(eng);
+
+			return( FindErr( eng, Err_Flag_Check_Buf_Data ) );
+		} // End if ( (rdata & wp) != (gdata & wp) )
+		if ( DbgPrn_BufdatDetail )
+			PRINTF( FP_LOG, " Adr:%08x[%3d] (%08x) (%08x:%08x) [Des:%d][loop[%d]:%d]\n", adr, ( adr - adr_srt ) / 4, rdata, gdata, wp, number, eng->run.loop_of_cnt, eng->run.loop_cnt );
+
+#ifdef SelectSimpleDA
+		if ( cnt <= 4 )
+			gdata = gdata_bak;
+#endif
+
+#if defined(SelectSimpleData)
+		gdata = gdata ^ SimpleData_XORVal;
+#else
+		gdata += DATA_IncVal;
+#endif
+
+		wp     = 0xffffffff;
+	}
+	return(0);
+} // End char check_Data (MAC_ENGINE *eng, uint32_t datbase, int32_t number)
+
+//------------------------------------------------------------
+char check_buf (MAC_ENGINE *eng, int loopcnt) 
+{
+	int32_t des_num;
+	uint32_t desadr;
+#ifdef CHECK_RX_DATA
+	uint32_t datbase;
+#endif
+	nt_log_func_name();
+
+	desadr = eng->run.rdes_base + (16 * eng->dat.Des_Num) - 4;
+	for (des_num = eng->dat.Des_Num - 1; des_num >= 0; des_num--) {
+#ifdef CHECK_RX_DATA
+		datbase = AT_BUF_MEMRW(Read_Mem_Des_DD(desadr) & 0xfffffffc);
+		if (check_Data(eng, datbase, des_num)) {
+			check_int(eng, "");
+			return (1);
+		}
+		if (check_int(eng, ""))
+			return 1;
+#endif
+		desadr -= 16;
+	}
+	if (check_int(eng, ""))
+		return (1);
+
+#if defined(Delay_CheckData_LoopNum) && defined(Delay_CheckData)
+	if ((loopcnt % Delay_CheckData_LoopNum) == 0)
+		DELAY(Delay_CheckData);
+#endif
+	return (0);
+} // End char check_buf (MAC_ENGINE *eng, int loopcnt)
+
+//------------------------------------------------------------
+// Descriptor
+//------------------------------------------------------------
+void setup_txdes (MAC_ENGINE *eng, uint32_t desadr, uint32_t bufbase) 
+{
+	uint32_t bufadr;
+	uint32_t bufadrgap;
+	uint32_t desval = 0;
+	int32_t des_num;
+
+	nt_log_func_name();
+
+	bufadr = bufbase;
+	if (eng->arg.ctrl.b.single_packet)
+		bufadrgap = 0;
+	else
+		bufadrgap = DMA_PakSize;
+
+	if (eng->run.TM_TxDataEn) {
+		for (des_num = 0; des_num < eng->dat.Des_Num; des_num++) {
+			eng->dat.FRAME_LEN_Cur = eng->dat.FRAME_LEN[des_num];
+			desval = TDES_IniVal;
+			Write_Mem_Des_DD(desadr + 0x04, 0);
+			Write_Mem_Des_DD(desadr + 0x08, 0);
+			Write_Mem_Des_DD(desadr + 0x0C, bufadr);
+			Write_Mem_Des_DD(desadr, desval);
+
+			if (DbgPrn_FRAME_LEN)
+				PRINTF(
+				    FP_LOG,
+				    "[setup_txdes    ] "
+				    "FRAME_LEN_Cur:%08x[Des:%d][loop[%d]:%d]\n",
+				    eng->dat.FRAME_LEN_Cur, des_num,
+				    eng->run.loop_of_cnt, eng->run.loop_cnt);
+
+			if (DbgPrn_BufAdr)
+				printf("[loop[%d]:%4d][des:%4d][setup_txdes] "
+				       "%08x [%08x]\n",
+				       eng->run.loop_of_cnt, eng->run.loop_cnt,
+				       des_num, desadr, bufadr);
+
+			desadr += 16;
+			bufadr += bufadrgap;
+		}
+		barrier();
+		Write_Mem_Des_DD(desadr - 0x10, desval | EOR_IniVal);
+	} else {
+		Write_Mem_Des_DD(desadr, 0);
+	}
+}
+
+//------------------------------------------------------------
+void setup_rxdes (MAC_ENGINE *eng, uint32_t desadr, uint32_t bufbase) 
+{
+	uint32_t      bufadr;
+	uint32_t      desval;
+	int32_t       des_num;
+
+	nt_log_func_name();
+
+	bufadr = bufbase;
+	desval = RDES_IniVal;
+	if ( eng->run.TM_RxDataEn ) {
+		for ( des_num = 0; des_num < eng->dat.Des_Num; des_num++ ) {
+			Write_Mem_Des_DD(desadr + 0x04, 0     );
+			Write_Mem_Des_DD(desadr + 0x08, 0     );
+			Write_Mem_Des_DD(desadr + 0x0C, bufadr);
+			Write_Mem_Des_DD(desadr + 0x00, desval);
+
+			if ( DbgPrn_BufAdr )
+				printf("[loop[%d]:%4d][des:%4d][setup_rxdes] %08x [%08x]\n", eng->run.loop_of_cnt, eng->run.loop_cnt, des_num, desadr, bufadr);
+
+			desadr += 16;
+			bufadr += DMA_PakSize;
+		}
+		barrier();
+		Write_Mem_Des_DD( desadr - 0x10, desval | EOR_IniVal );
+	}
+	else {
+		Write_Mem_Des_DD( desadr, 0x80000000 );
+	} // End if ( eng->run.TM_RxDataEn )
+} // End void setup_rxdes (uint32_t desadr, uint32_t bufbase)
+
+//------------------------------------------------------------
+// First setting TX and RX information
+//------------------------------------------------------------
+void setup_des (MAC_ENGINE *eng, uint32_t bufnum) 
+{
+	if (DbgPrn_BufAdr) {
+		printf("setup_des: %d\n", bufnum);
+		debug_pause();
+	}
+
+	eng->dat.DMA_Base_Tx =
+	    ZeroCopy_OFFSET + eng->dat.DMA_Base_Setup;
+	eng->dat.DMA_Base_Rx = ZeroCopy_OFFSET + GET_DMA_BASE(eng, 0);	
+
+	setup_txdes(eng, eng->run.tdes_base,
+		    AT_MEMRW_BUF(eng->dat.DMA_Base_Tx));
+	setup_rxdes(eng, eng->run.rdes_base,
+		    AT_MEMRW_BUF(eng->dat.DMA_Base_Rx));
+} // End void setup_des (uint32_t bufnum)
+
+//------------------------------------------------------------
+// Move buffer point of TX and RX descriptor to next DMA buffer
+//------------------------------------------------------------
+void setup_des_loop (MAC_ENGINE *eng, uint32_t bufnum) 
+{
+	int32_t des_num;
+	uint32_t H_rx_desadr;
+	uint32_t H_tx_desadr;
+	uint32_t H_tx_bufadr;
+	uint32_t H_rx_bufadr;
+
+	nt_log_func_name();
+
+	if (eng->run.TM_RxDataEn) {
+		H_rx_bufadr = AT_MEMRW_BUF(eng->dat.DMA_Base_Rx);
+		H_rx_desadr = eng->run.rdes_base;
+		for (des_num = 0; des_num < eng->dat.Des_Num - 1; des_num++) {
+			Write_Mem_Des_DD(H_rx_desadr + 0x0C, H_rx_bufadr);
+			Write_Mem_Des_DD(H_rx_desadr, RDES_IniVal);
+			if (DbgPrn_BufAdr)
+				printf("[loop[%d]:%4d][des:%4d][setup_rxdes] "
+				       "%08x [%08x]\n",
+				       eng->run.loop_of_cnt, eng->run.loop_cnt,
+				       des_num, H_rx_desadr, H_rx_bufadr);
+
+			H_rx_bufadr += DMA_PakSize;
+			H_rx_desadr += 16;
+		}
+		Write_Mem_Des_DD(H_rx_desadr + 0x0C, H_rx_bufadr);
+		Write_Mem_Des_DD(H_rx_desadr, RDES_IniVal | EOR_IniVal);
+		if (DbgPrn_BufAdr)
+			printf("[loop[%d]:%4d][des:%4d][setup_rxdes] %08x "
+			       "[%08x]\n",
+			       eng->run.loop_of_cnt, eng->run.loop_cnt, des_num,
+			       H_rx_desadr, H_rx_bufadr);
+	}
+
+	if (eng->run.TM_TxDataEn) {
+		H_tx_bufadr = AT_MEMRW_BUF(eng->dat.DMA_Base_Tx);
+		H_tx_desadr = eng->run.tdes_base;
+		for (des_num = 0; des_num < eng->dat.Des_Num - 1; des_num++) {
+			eng->dat.FRAME_LEN_Cur = eng->dat.FRAME_LEN[des_num];
+			Write_Mem_Des_DD(H_tx_desadr + 0x0C, H_tx_bufadr);
+			Write_Mem_Des_DD(H_tx_desadr, TDES_IniVal);
+			if (DbgPrn_BufAdr)
+				printf("[loop[%d]:%4d][des:%4d][setup_txdes] "
+				       "%08x [%08x]\n",
+				       eng->run.loop_of_cnt, eng->run.loop_cnt,
+				       des_num, H_tx_desadr, H_tx_bufadr);
+
+			H_tx_bufadr += DMA_PakSize;
+			H_tx_desadr += 16;
+		}
+		eng->dat.FRAME_LEN_Cur = eng->dat.FRAME_LEN[des_num];
+		Write_Mem_Des_DD(H_tx_desadr + 0x0C, H_tx_bufadr);
+		Write_Mem_Des_DD(H_tx_desadr, TDES_IniVal | EOR_IniVal);
+		if (DbgPrn_BufAdr)
+			printf("[loop[%d]:%4d][des:%4d][setup_txdes] %08x "
+			       "[%08x]\n",
+			       eng->run.loop_of_cnt, eng->run.loop_cnt, des_num,
+			       H_tx_desadr, H_tx_bufadr);
+	}
+} // End void setup_des_loop (uint32_t bufnum)
+
+//------------------------------------------------------------
+char check_des_header_Tx (MAC_ENGINE *eng, char *type, uint32_t adr, int32_t desnum) 
+{
+	int timeout = 0;
+
+	eng->dat.TxDes0DW = Read_Mem_Des_DD(adr);
+
+	while (HWOwnTx(eng->dat.TxDes0DW)) {
+		// we will run again, if transfer has not been completed.
+		if ((eng->run.tm_tx_only || eng->run.TM_RxDataEn) &&
+		    (++timeout > eng->run.timeout_th)) {
+			PRINTF(FP_LOG,
+			       "[%sTxDesOwn] Address %08x = %08x "
+			       "[Des:%d][loop[%d]:%d]\n",
+			       type, adr, eng->dat.TxDes0DW, desnum,
+			       eng->run.loop_of_cnt, eng->run.loop_cnt);
+			return (FindErr_Des(eng, Des_Flag_TxOwnTimeOut));
+		}
+
+#ifdef Delay_ChkTxOwn
+		DELAY(Delay_ChkTxOwn);
+#endif
+		eng->dat.TxDes0DW = Read_Mem_Des_DD(adr);
+	}
+
+	return(0);
+} // End char check_des_header_Tx (MAC_ENGINE *eng, char *type, uint32_t adr, int32_t desnum)
+
+//------------------------------------------------------------
+char check_des_header_Rx (MAC_ENGINE *eng, char *type, uint32_t adr, int32_t desnum) 
+{
+#ifdef CheckRxOwn
+	int timeout = 0;
+
+	eng->dat.RxDes0DW = Read_Mem_Des_DD(adr);
+
+	while (HWOwnRx(eng->dat.RxDes0DW)) {
+		// we will run again, if transfer has not been completed.
+		if (eng->run.TM_TxDataEn && (++timeout > eng->run.timeout_th)) {
+#if 0			
+			printf("[%sRxDesOwn] Address %08x = %08x "
+			       "[Des:%d][loop[%d]:%d]\n",
+			       type, adr, eng->dat.RxDes0DW, desnum,
+			       eng->run.loop_of_cnt, eng->run.loop_cnt);
+#endif
+			FindErr_Des(eng, Des_Flag_RxOwnTimeOut);
+			return (2);
+		}
+
+  #ifdef Delay_ChkRxOwn
+		DELAY(Delay_ChkRxOwn);
+  #endif
+		eng->dat.RxDes0DW = Read_Mem_Des_DD(adr);
+	};
+
+  #ifdef CheckRxLen
+	if ( DbgPrn_FRAME_LEN )
+		PRINTF( FP_LOG, "[%sRxDes          ] FRAME_LEN_Cur:%08x[Des:%d][loop[%d]:%d]\n", type, ( eng->dat.FRAME_LEN_Cur + 4 ), desnum, eng->run.loop_of_cnt, eng->run.loop_cnt );
+
+	if ( ( eng->dat.RxDes0DW & 0x3fff ) != ( eng->dat.FRAME_LEN_Cur + 4 ) ) {
+		eng->dat.RxDes3DW = Read_Mem_Des_DD( adr + 12 );
+		PRINTF( FP_LOG, "[%sRxDes] Error Frame Length %08x:%08x %08x(%4d/%4d) [Des:%d][loop[%d]:%d]\n",   type, adr, eng->dat.RxDes0DW, eng->dat.RxDes3DW, ( eng->dat.RxDes0DW & 0x3fff ), ( eng->dat.FRAME_LEN_Cur + 4 ), desnum, eng->run.loop_of_cnt, eng->run.loop_cnt );
+		FindErr_Des( eng, Des_Flag_FrameLen );
+	}
+  #endif // End CheckRxLen
+
+	if ( eng->dat.RxDes0DW & RXDES_EM_ALL ) {
+		eng->dat.RxDes3DW = Read_Mem_Des_DD( adr + 12 );
+  #ifdef CheckRxErr
+		if ( eng->dat.RxDes0DW & RXDES_EM_RXERR ) {
+			PRINTF( FP_LOG, "[%sRxDes] Error RxErr        %08x:%08x %08x            [Des:%d][loop[%d]:%d]\n", type, adr, eng->dat.RxDes0DW, eng->dat.RxDes3DW, desnum, eng->run.loop_of_cnt, eng->run.loop_cnt );
+			FindErr_Des( eng, Des_Flag_RxErr );
+		}
+  #endif // End CheckRxErr
+
+  #ifdef CheckCRC
+		if ( eng->dat.RxDes0DW & RXDES_EM_CRC ) {
+			PRINTF( FP_LOG, "[%sRxDes] Error CRC          %08x:%08x %08x            [Des:%d][loop[%d]:%d]\n", type, adr, eng->dat.RxDes0DW, eng->dat.RxDes3DW, desnum, eng->run.loop_of_cnt, eng->run.loop_cnt );
+			FindErr_Des( eng, Des_Flag_CRC );
+		}
+  #endif // End CheckCRC
+
+  #ifdef CheckFTL
+		if ( eng->dat.RxDes0DW & RXDES_EM_FTL ) {
+			PRINTF( FP_LOG, "[%sRxDes] Error FTL          %08x:%08x %08x            [Des:%d][loop[%d]:%d]\n", type, adr, eng->dat.RxDes0DW, eng->dat.RxDes3DW, desnum, eng->run.loop_of_cnt, eng->run.loop_cnt );
+			FindErr_Des( eng, Des_Flag_FTL );
+		}
+  #endif // End CheckFTL
+
+  #ifdef CheckRunt
+		if ( eng->dat.RxDes0DW & RXDES_EM_RUNT) {
+			PRINTF( FP_LOG, "[%sRxDes] Error Runt         %08x:%08x %08x            [Des:%d][loop[%d]:%d]\n", type, adr, eng->dat.RxDes0DW, eng->dat.RxDes3DW, desnum, eng->run.loop_of_cnt, eng->run.loop_cnt );
+			FindErr_Des( eng, Des_Flag_Runt );
+		}
+  #endif // End CheckRunt
+
+  #ifdef CheckOddNibble
+		if ( eng->dat.RxDes0DW & RXDES_EM_ODD_NB ) {
+			PRINTF( FP_LOG, "[%sRxDes] Odd Nibble         %08x:%08x %08x            [Des:%d][loop[%d]:%d]\n", type, adr, eng->dat.RxDes0DW, eng->dat.RxDes3DW, desnum, eng->run.loop_of_cnt, eng->run.loop_cnt );
+			FindErr_Des( eng, Des_Flag_OddNibble );
+		}
+  #endif // End CheckOddNibble
+
+  #ifdef CheckRxFIFOFull
+		if ( eng->dat.RxDes0DW & RXDES_EM_FIFO_FULL ) {
+			PRINTF( FP_LOG, "[%sRxDes] Error Rx FIFO Full %08x:%08x %08x            [Des:%d][loop[%d]:%d]\n", type, adr, eng->dat.RxDes0DW, eng->dat.RxDes3DW, desnum, eng->run.loop_of_cnt, eng->run.loop_cnt );
+			FindErr_Des( eng, Des_Flag_RxFIFOFull );
+		}
+  #endif // End CheckRxFIFOFull
+	}
+
+#endif // End CheckRxOwn
+
+	if ( eng->flg.error )
+		return(1);
+	else
+		return(0);
+} // End char check_des_header_Rx (MAC_ENGINE *eng, char *type, uint32_t adr, int32_t desnum)
+
+//------------------------------------------------------------
+char check_des (MAC_ENGINE *eng, uint32_t bufnum, int checkpoint) 
+{
+	int32_t       desnum;
+	int8_t       desnum_last;
+	uint32_t      H_rx_desadr;
+	uint32_t      H_tx_desadr;
+	uint32_t      H_tx_bufadr;
+	uint32_t      H_rx_bufadr;
+#ifdef Delay_DesGap
+	uint32_t      dly_cnt = 0;
+	uint32_t      dly_max = Delay_CntMaxIncVal;
+#endif
+	int ret;
+
+	nt_log_func_name();
+
+	/* Fire the engine to send and recvice */
+	mac_reg_write(eng, 0x1c, 0x00000001); // Rx Poll
+	mac_reg_write(eng, 0x18, 0x00000001); // Tx Poll
+
+#ifndef SelectSimpleDes
+	/* base of the descriptors */
+	H_tx_bufadr = AT_MEMRW_BUF(eng->dat.DMA_Base_Tx);
+	H_rx_bufadr = AT_MEMRW_BUF(eng->dat.DMA_Base_Rx);
+#endif
+	H_rx_desadr = eng->run.rdes_base;
+	H_tx_desadr = eng->run.tdes_base;
+
+#ifdef Delay_DES
+	DELAY(Delay_DES);
+#endif
+
+	for (desnum = 0; desnum < eng->dat.Des_Num; desnum++) {
+		desnum_last = (desnum == (eng->dat.Des_Num - 1)) ? 1 : 0;
+		if ( DbgPrn_BufAdr ) {
+			if ( checkpoint )
+				printf("[loop[%d]:%4d][des:%4d][check_des  ] %08x %08x [%08x %08x]\n", eng->run.loop_of_cnt, eng->run.loop_cnt, desnum, ( H_tx_desadr ), ( H_rx_desadr ), Read_Mem_Des_DD( H_tx_desadr + 12 ), Read_Mem_Des_DD( H_rx_desadr + 12 ) );
+			else
+				printf("[loop[%d]:%4d][des:%4d][check_des  ] %08x %08x [%08x %08x]->[%08x %08x]\n", eng->run.loop_of_cnt, eng->run.loop_cnt, desnum, ( H_tx_desadr ), ( H_rx_desadr ), Read_Mem_Des_DD( H_tx_desadr + 12 ), Read_Mem_Des_DD( H_rx_desadr + 12 ), H_tx_bufadr, H_rx_bufadr );
+		}
+
+		//[Delay]--------------------
+#ifdef Delay_DesGap
+//		if ( dly_cnt++ > 3 ) {
+		if ( dly_cnt > Delay_CntMax ) {
+//			switch ( rand() % 12 ) {
+//				case 1 : dly_max = 00000; break;
+//				case 3 : dly_max = 20000; break;
+//				case 5 : dly_max = 40000; break;
+//				case 7 : dly_max = 60000; break;
+//				defaule: dly_max = 70000; break;
+//			}
+//
+//			dly_max += ( rand() % 4 ) * 14321;
+//
+//			while (dly_cnt < dly_max) {
+//				dly_cnt++;
+//			}
+			DELAY( Delay_DesGap );
+			dly_cnt = 0;
+		}
+		else {
+			dly_cnt++;
+//			timeout = 0;
+//			while (timeout < 50000) {timeout++;};
+		}
+#endif // End Delay_DesGap
+
+		//[Check Owner Bit]--------------------
+		eng->dat.FRAME_LEN_Cur = eng->dat.FRAME_LEN[desnum];
+		if (DbgPrn_FRAME_LEN)
+			PRINTF(FP_LOG,
+			       "[check_des      ] "
+			       "FRAME_LEN_Cur:%08x[Des:%d][loop[%d]:%d]%d\n",
+			       eng->dat.FRAME_LEN_Cur, desnum,
+			       eng->run.loop_of_cnt, eng->run.loop_cnt,
+			       checkpoint);
+
+		// Check the description of Tx and Rx
+		if (eng->run.TM_TxDataEn) {
+			ret = check_des_header_Tx(eng, "", H_tx_desadr, desnum);
+			if (ret) {
+				eng->flg.n_desc_fail = desnum;
+				return ret;
+			}
+		}
+		if (eng->run.TM_RxDataEn) {
+			ret = check_des_header_Rx(eng, "", H_rx_desadr, desnum);
+			if (ret) {
+				eng->flg.n_desc_fail = desnum;
+				return ret;
+				
+			}
+		}
+
+#ifndef SelectSimpleDes
+		if (!checkpoint) {
+			// Setting buffer address to description of Tx and Rx on next stage
+			if ( eng->run.TM_RxDataEn ) {
+				Write_Mem_Des_DD( H_rx_desadr + 0x0C, H_rx_bufadr );
+				if ( desnum_last )
+					Write_Mem_Des_DD( H_rx_desadr, RDES_IniVal | EOR_IniVal );
+				else
+					Write_Mem_Des_DD( H_rx_desadr, RDES_IniVal );
+
+				readl(H_rx_desadr);
+				mac_reg_write(eng, 0x1c, 0x00000000); //Rx Poll
+				H_rx_bufadr += DMA_PakSize;
+			}
+			if ( eng->run.TM_TxDataEn ) {
+				Write_Mem_Des_DD( H_tx_desadr + 0x0C, H_tx_bufadr );
+				if ( desnum_last )
+					Write_Mem_Des_DD( H_tx_desadr, TDES_IniVal | EOR_IniVal );
+				else
+					Write_Mem_Des_DD( H_tx_desadr, TDES_IniVal );
+				
+				readl(H_tx_desadr);
+				mac_reg_write(eng, 0x18, 0x00000000); //Tx Poll
+				H_tx_bufadr += DMA_PakSize;
+			}
+		}
+#endif // End SelectSimpleDes
+
+		H_rx_desadr += 16;
+		H_tx_desadr += 16;
+	} // End for (desnum = 0; desnum < eng->dat.Des_Num; desnum++)
+
+	return(0);
+} // End char check_des (MAC_ENGINE *eng, uint32_t bufnum, int checkpoint)
+//#endif
+
+//------------------------------------------------------------
+// Print
+//-----------------------------------------------------------
+void PrintIO_Header (MAC_ENGINE *eng, uint8_t option) 
+{
+	int32_t rx_d, step, tmp;
+
+	if (eng->run.TM_IOStrength) {
+		if (eng->io.drv_upper_bond > 1) {
+#ifdef CONFIG_ASPEED_AST2600			
+			PRINTF(option, "<IO Strength register: [%08x] 0x%08x>",
+			       eng->io.mac34_drv_reg.addr,
+			       eng->io.mac34_drv_reg.value.w);
+#else
+			PRINTF(option, "<IO Strength register: [%08x] 0x%08x>",
+			       eng->io.mac12_drv_reg.addr,
+			       eng->io.mac12_drv_reg.value.w);
+#endif			       
+		}
+	}
+
+	if      ( eng->run.speed_sel[ 0 ] ) { PRINTF( option, "\n[1G  ]========================================>\n" ); }
+	else if ( eng->run.speed_sel[ 1 ] ) { PRINTF( option, "\n[100M]========================================>\n" ); }
+	else                                { PRINTF( option, "\n[10M ]========================================>\n" ); }
+
+	if ( !(option == FP_LOG) ) {
+		step = eng->io.rx_delay_scan.step;
+
+		PRINTF(option, "\n    ");
+		for (rx_d = eng->io.rx_delay_scan.begin; rx_d <= eng->io.rx_delay_scan.end; rx_d += step) {
+
+			if (rx_d < 0) {
+				PRINTF(option, "-" );
+			} else {
+				PRINTF(option, "+" );
+			}
+		}
+
+		PRINTF(option, "\n    ");
+		for (rx_d = eng->io.rx_delay_scan.begin; rx_d <= eng->io.rx_delay_scan.end; rx_d += step) {
+			tmp = (abs(rx_d) >> 4) & 0xf;
+			if (tmp == 0) {
+				PRINTF(option, "0" );
+			} else {
+				PRINTF(option, "%1x", tmp);
+			}
+		}
+
+		PRINTF(option, "\n    ");
+		for (rx_d = eng->io.rx_delay_scan.begin;
+		     rx_d <= eng->io.rx_delay_scan.end; rx_d += step) {
+			PRINTF(option, "%1x", (uint32_t)abs(rx_d) & 0xf);
+		}
+
+		PRINTF(option, "\n    ");
+		for (rx_d = eng->io.rx_delay_scan.begin; rx_d <= eng->io.rx_delay_scan.end; rx_d += step) {
+			if (eng->io.rx_delay_scan.orig == rx_d) {
+				PRINTF(option, "|" );
+			} else {
+				PRINTF(option, " " );
+			}
+		}
+		PRINTF( option, "\n");
+	}
+}
+
+//------------------------------------------------------------
+void PrintIO_LineS(MAC_ENGINE *p_eng, uint8_t option)
+{
+	if (p_eng->io.tx_delay_scan.orig == p_eng->io.Dly_out_selval) {
+		PRINTF( option, "%02x:-", p_eng->io.Dly_out_selval); 
+	} else {
+		PRINTF( option, "%02x: ", p_eng->io.Dly_out_selval);
+	}	
+} // End void PrintIO_LineS (MAC_ENGINE *eng, uint8_t option)
+
+//------------------------------------------------------------
+void PrintIO_Line(MAC_ENGINE *p_eng, uint8_t option) 
+{
+	if ((p_eng->io.Dly_in_selval == p_eng->io.rx_delay_scan.orig) && 
+	    (p_eng->io.Dly_out_selval == p_eng->io.tx_delay_scan.orig)) {
+		if (1 == p_eng->io.result) {
+			PRINTF(option, "X");
+		} else if (2 == p_eng->io.result) {
+			PRINTF(option, "*");
+		} else {
+			PRINTF(option, "O");
+		}
+	} else {
+		if (1 == p_eng->io.result) {
+			PRINTF(option, "x");
+		} else if (2 == p_eng->io.result) {
+			PRINTF(option, ".");
+		} else {
+			PRINTF(option, "o");
+		}
+	}	
+}
+
+//------------------------------------------------------------
+// main
+//------------------------------------------------------------
+
+//------------------------------------------------------------
+void TestingSetup (MAC_ENGINE *eng) 
+{
+	nt_log_func_name();
+
+	//[Setup]--------------------
+	setup_framesize( eng );
+	setup_buf( eng );
+}
+
+//------------------------------------------------------------
+// Return 1 ==> fail
+// Return 0 ==> PASS
+//------------------------------------------------------------
+char TestingLoop (MAC_ENGINE *eng, uint32_t loop_checknum) 
+{
+	char       checkprd;
+	char       looplast;
+	char       checken;
+	int ret;
+
+	nt_log_func_name();
+
+	if (DbgPrn_DumpMACCnt)
+		dump_mac_ROreg(eng);
+
+	//[Setup]--------------------
+	eng->run.loop_cnt = 0;
+	checkprd = 0;
+	checken  = 0;
+	looplast = 0;
+
+
+	setup_des(eng, 0);
+
+	if ( eng->run.TM_WaitStart ) {
+		printf("Press any key to start...\n");
+		GET_CAHR();
+	}
+
+
+	while ( ( eng->run.loop_cnt < eng->run.loop_max ) || eng->arg.loop_inf ) {
+		looplast = !eng->arg.loop_inf && ( eng->run.loop_cnt == eng->run.loop_max - 1 );
+
+#ifdef CheckRxBuf
+		if (!eng->run.tm_tx_only)
+			checkprd = ((eng->run.loop_cnt % loop_checknum) == (loop_checknum - 1));
+		checken = looplast | checkprd;
+#endif
+
+		if (DbgPrn_BufAdr) {
+			printf("for start ======> [%d]%d/%d(%d) looplast:%d "
+			       "checkprd:%d checken:%d\n",
+			       eng->run.loop_of_cnt, eng->run.loop_cnt,
+			       eng->run.loop_max, eng->arg.loop_inf,
+			       looplast, checkprd, checken);
+			debug_pause();
+		}
+
+
+		if (eng->run.TM_RxDataEn)
+			eng->dat.DMA_Base_Tx = eng->dat.DMA_Base_Rx;
+
+		eng->dat.DMA_Base_Rx =
+		    ZeroCopy_OFFSET + GET_DMA_BASE(eng, eng->run.loop_cnt + 1);
+		//[Check DES]--------------------
+		ret = check_des(eng, eng->run.loop_cnt, checken);
+		if (ret) {
+			//descriptor error
+			eng->dat.Des_Num = eng->flg.n_desc_fail + 1;
+#ifdef CheckRxBuf
+			if (checkprd)
+				check_buf(eng, loop_checknum);
+			else
+				check_buf(eng, (eng->run.loop_max % loop_checknum));
+			eng->dat.Des_Num = eng->dat.Des_Num_Org;
+#endif
+
+			if (DbgPrn_DumpMACCnt)
+				dump_mac_ROreg(eng);
+
+			return ret;
+		}
+
+		//[Check Buf]--------------------
+		if (eng->run.TM_RxDataEn && checken) {
+			if (checkprd) {
+#ifdef Enable_ShowBW  
+				printf("[run loop:%3d] BandWidth: %7.2f Mbps, %6.2f sec\n", loop_checknum, ((double)loop_checknum * (double)eng->dat.Total_frame_len * 8.0) / ((double)eng->timeused * 1000000.0), eng->timeused);
+				PRINTF( FP_LOG, "[run loop:%3d] BandWidth: %7.2f Mbps, %6.2f sec\n", loop_checknum, ((double)loop_checknum * (double)eng->dat.Total_frame_len * 8.0) / ((double)eng->timeused * 1000000.0), eng->timeused );  
+#endif
+
+#ifdef CheckRxBuf
+				if (check_buf(eng, loop_checknum))
+					return(1);
+#endif
+			} else {
+#ifdef Enable_ShowBW  
+				printf("[run loop:%3d] BandWidth: %7.2f Mbps, %6.2f sec\n", (eng->run.loop_max % loop_checknum), ((double)(eng->run.loop_max % loop_checknum) * (double)eng->dat.Total_frame_len * 8.0) / ((double)eng->timeused * 1000000.0), eng->timeused);
+				PRINTF( FP_LOG, "[run loop:%3d] BandWidth: %7.2f Mbps, %6.2f sec\n", (eng->run.loop_max % loop_checknum), ((double)(eng->run.loop_max % loop_checknum) * (double)eng->dat.Total_frame_len * 8.0) / ((double)eng->timeused * 1000000.0), eng->timeused );  
+#endif
+
+#ifdef CheckRxBuf
+				if (check_buf(eng, (eng->run.loop_max % loop_checknum)))
+					return(1);
+#endif
+			} // End if ( checkprd )
+
+#ifndef SelectSimpleDes
+			if (!looplast)
+				setup_des_loop(eng, eng->run.loop_cnt);
+#endif
+
+#ifdef Enable_ShowBW
+			timeold = clock();
+#endif
+		} // End if ( eng->run.TM_RxDataEn && checken )
+
+#ifdef SelectSimpleDes
+		if (!looplast)
+			setup_des_loop(eng, eng->run.loop_cnt);
+#endif
+
+		if ( eng->arg.loop_inf )
+			printf("===============> Loop[%d]: %d  \r", eng->run.loop_of_cnt, eng->run.loop_cnt);
+		else if ( eng->arg.test_mode == 0 ) {
+			if ( !( DbgPrn_BufAdr || eng->run.delay_margin ) )
+				printf(" [%d]%d                        \r", eng->run.loop_of_cnt, eng->run.loop_cnt);
+		}
+
+		if (DbgPrn_BufAdr) {
+			printf("for end   ======> [%d]%d/%d(%d)\n",
+			       eng->run.loop_of_cnt, eng->run.loop_cnt,
+			       eng->run.loop_max, eng->arg.loop_inf);
+			debug_pause();
+		}
+
+		if (eng->run.loop_cnt >= 0x7fffffff) {	
+			debug("loop counter wrapped around\n");
+			eng->run.loop_cnt = 0;
+			eng->run.loop_of_cnt++;
+		} else
+			eng->run.loop_cnt++;
+	} // End while ( ( eng->run.loop_cnt < eng->run.loop_max ) || eng->arg.loop_inf )
+
+	eng->flg.all_fail = 0;
+	return(0);
+} // End char TestingLoop (MAC_ENGINE *eng, uint32_t loop_checknum)
diff -Naur uboot/oem/ami/standalone/nettest/mac.h uboot-new/oem/ami/standalone/nettest/mac.h
--- uboot/oem/ami/standalone/nettest/mac.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/mac.h	2020-11-20 04:00:27.000000000 -0500
@@ -0,0 +1,92 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MAC_H
+#define MAC_H
+
+
+#include <common.h>
+#include <command.h>
+
+#include "ncsi.h"
+#include <asm/io.h>
+
+// --------------------------------------------------------------
+// Define
+// --------------------------------------------------------------
+//#define Enable_MAC_SWRst               //[off]
+#define   Enable_No_IOBoundary         //[ON]
+//#define Enable_Dual_Mode               //[off]
+
+//#define Enable_Runt
+//#define Enable_ShowBW
+
+#define TX_DELAY_SCALING			2
+#define RX_DELAY_SCALING			2
+
+//#define SelectSimpleBoundary                                    //[off] Using in debug
+//#define SelectSimpleData                                        //[off] Using in debug
+//#define SelectSimpleLength                       1514           //[off] 60(0x3c) ~ 1514(0x5ea); 1512(0x5e8)
+//#define SelectSimpleDA                                          //[off] Using in debug
+//#define SelectSimpleDes                                         //[off]
+//#define SelectLengthInc                                         //[off] Using in debug
+
+#define   SimpleData_Fix                                        //[ON] Using in debug
+#define     SimpleData_FixNum                    12
+#define     SimpleData_FixVal00                  0x00000000     //[0]no SelectSimpleDA: (60: 0412 8908)(1512: e20d e9da)
+#define     SimpleData_FixVal01                  0xffffffff     //[0]no SelectSimpleDA: (60: f48c f14d)(1512: af05 260c)
+#define     SimpleData_FixVal02                  0x55555555     //[0]no SelectSimpleDA: (60: 5467 5ecb)(1512: d90a 5368)
+#define     SimpleData_FixVal03                  0xaaaaaaaa     //[0]no SelectSimpleDA: (60: a4f9 268e)(1512: 9402 9cbe)
+#define     SimpleData_FixVal04                  0x5a5a5a5a     //[1]no SelectSimpleDA: (60: 7f01 e22d)(1512: 4fd3 8012)
+#define     SimpleData_FixVal05                  0xc3c3c3c3     //[1]no SelectSimpleDA: (60: 5916 02d5)(1512: 99f1 6127)
+#define     SimpleData_FixVal06                  0x96969696     //[1]no SelectSimpleDA: (60: 0963 d516)(1512: a2f6 db95)
+#define     SimpleData_FixVal07                  0xf0f0f0f0     //[1]no SelectSimpleDA: (60: dfea 4dab)(1512: 39dc f576)
+#define     SimpleData_FixVal08                  0x5555aaaa     //[2]no SelectSimpleDA: (60: b61b 5777)(1512: 4652 ddb0)
+#define     SimpleData_FixVal09                  0xffff0000     //[2]no SelectSimpleDA: (60: 16f0 f8f1)(1512: 305d a8d4)
+#define     SimpleData_FixVal10                  0x5a5aa5a5     //[2]no SelectSimpleDA: (60: 9d7d eb91)(1512: d08b 0eca)
+#define     SimpleData_FixVal11                  0xc3c33c3c     //[2]no SelectSimpleDA: (60: bb6a 0b69)(1512: 06a9 efff)
+
+#define   SimpleData_XORVal                      0x00000000
+//#define   SimpleData_XORVal                    0xffffffff
+
+#define   SelectSimpleDA_Dat0                    0x67052301
+#define   SelectSimpleDA_Dat1                    0xe0cda089
+#define   SelectSimpleDA_Dat2                    0x98badcfe
+
+#define   SelectWOLDA_DatH                       0x206a
+#define   SelectWOLDA_DatL                       0x8a374d9b
+
+/* MByte per second to move data */
+#define MOVE_DATA_MB_SEC			800
+
+//---------------------------------------------------------
+// Frame size
+//---------------------------------------------------------
+#define ENABLE_RAND_SIZE                         0
+#define   RAND_SIZE_SED                          0xffccd
+#define   RAND_SIZE_SIMPLE                       0
+#define   RAND_SIZE_MIN                          60
+#define   RAND_SIZE_MAX                          1514
+
+#define FRAME_SELH_PERD                          7
+  #ifdef SelectSimpleLength
+//    #define FRAME_LENH                           ( SelectSimpleLength + 1 )
+//    #define FRAME_LENL                           ( SelectSimpleLength     )
+    #define FRAME_LENH                           SelectSimpleLength
+    #define FRAME_LENL                           SelectSimpleLength
+  #else
+//    #define FRAME_LENH                           1514           //max:1514
+//    #define FRAME_LENL                           1513           //max:1514
+    #define FRAME_LENH                           1514           //max:1514
+    #define FRAME_LENL                           1514           //max:1514
+  #endif
+
+#endif // MAC_H
diff -Naur uboot/oem/ami/standalone/nettest/mactest.c uboot-new/oem/ami/standalone/nettest/mactest.c
--- uboot/oem/ami/standalone/nettest/mactest.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/mactest.c	2021-01-06 11:48:30.000000000 -0500
@@ -0,0 +1,1502 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define MACTEST_C
+
+#include "swfunc.h"
+#include "comminf.h"
+#include <command.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <post.h>
+#include "mem_io.h"
+
+#include "phy_api.h"
+#include "mac_api.h"
+
+#define ARGV_MAC_IDX		1
+#define ARGV_MDIO_IDX		2
+#define ARGV_SPEED		3
+#define ARGV_CTRL		4
+#define ARGV_LOOP		5
+#define ARGV_TEST_MODE		6
+#define ARGV_PHY_ADDR		7
+#define ARGV_TIMING_MARGIN	8
+
+
+uint8_t __attribute__ ((aligned (1024*1024))) tdes_buf[TDES_SIZE];
+uint8_t __attribute__ ((aligned (1024*1024))) rdes_buf[RDES_SIZE];
+uint8_t __attribute__ ((aligned (1024*1024))) dma_buf[DMA_BUF_SIZE];
+
+struct mac_ctrl_desc {
+	uint32_t base_reset_assert;
+	uint32_t bit_reset_assert;
+	uint32_t base_reset_deassert;
+	uint32_t bit_reset_deassert;
+
+	uint32_t base_clk_stop;
+	uint32_t bit_clk_stop;
+	uint32_t base_clk_start;
+	uint32_t bit_clk_start;
+};
+
+static const uint32_t timeout_th_tbl[3] = {
+    TIME_OUT_Des_1G, TIME_OUT_Des_100M, TIME_OUT_Des_10M};
+#if defined(CONFIG_ASPEED_AST2600)
+const uint32_t mac_base_lookup_tbl[4] = {MAC1_BASE, MAC2_BASE, MAC3_BASE,
+					 MAC4_BASE};
+const uint32_t mdio_base_lookup_tbl[4] = {MDIO0_BASE, MDIO1_BASE, MDIO2_BASE,
+					 MDIO3_BASE};
+const struct mac_ctrl_desc mac_ctrl_lookup_tbl[4] = {
+	{
+		.base_reset_assert = 0x40, .bit_reset_assert = BIT(11),
+		.base_reset_deassert = 0x44,.bit_reset_deassert = BIT(11),
+		.base_clk_stop = 0x80, .bit_clk_stop = BIT(20),
+		.base_clk_start = 0x84, .bit_clk_start = BIT(20),
+	},
+	{
+		.base_reset_assert = 0x40, .bit_reset_assert = BIT(12),
+		.base_reset_deassert = 0x44,.bit_reset_deassert = BIT(12),
+		.base_clk_stop = 0x80, .bit_clk_stop = BIT(21),
+		.base_clk_start = 0x84,.bit_clk_start = BIT(21),
+	},
+	{
+		.base_reset_assert = 0x50, .bit_reset_assert = BIT(20),
+		.base_reset_deassert = 0x54,.bit_reset_deassert = BIT(20),
+		.base_clk_stop = 0x90, .bit_clk_stop = BIT(20),
+		.base_clk_start = 0x94, .bit_clk_start = BIT(20),
+	},
+	{
+		.base_reset_assert = 0x50, .bit_reset_assert = BIT(21),
+		.base_reset_deassert = 0x54,.bit_reset_deassert = BIT(21),
+		.base_clk_stop = 0x90, .bit_clk_stop = BIT(21),
+		.base_clk_start = 0x94,.bit_clk_start = BIT(21),
+	}
+};
+#else
+const uint32_t mac_base_lookup_tbl[2] = {MAC1_BASE, MAC2_BASE};
+const uint32_t mdio_base_lookup_tbl[2] = {MDIO0_BASE, MDIO1_BASE};
+const struct mac_ctrl_desc mac_ctrl_lookup_tbl[2] = {
+	{
+		.base_reset_assert = 0x04, .bit_reset_assert = 11,
+		.base_reset_deassert = 0x04,.bit_reset_deassert = 11,
+		.base_clk_stop = 0x0c, .bit_clk_stop = 20,
+		.base_clk_start = 0x0c, .bit_clk_start = 20,
+	},
+	{
+		.base_reset_assert = 0x04, .bit_reset_assert = 12,
+		.base_reset_deassert = 0x04,.bit_reset_deassert = 12,
+		.base_clk_stop = 0x0c, .bit_clk_stop = 21,
+		.base_clk_start = 0x0c,.bit_clk_start = 21,
+	}
+};
+#endif
+
+void Print_Header(MAC_ENGINE *p_eng, uint8_t option)
+{
+	if (p_eng->run.speed_sel[0]) {
+		PRINTF(option, " 1G   ");
+	} else if (p_eng->run.speed_sel[1]) {
+		PRINTF(option, " 100M ");
+	} else {
+		PRINTF(option, " 10M  ");
+	}
+
+	switch (p_eng->arg.test_mode) {
+	case 0: 
+		PRINTF(option, "TX/RX delay margin check\n");
+		break;
+	case 1:
+		PRINTF(option, "TX/RX delay scan\n");
+		break;
+	case 2:
+		PRINTF(option, "TX/RX delay and IO driving scan\n");
+		break;
+	case 3:
+		PRINTF(option, "TX frame - ARP\n");
+		break;
+	case 4:
+		PRINTF(option, "TX frame - random\n");
+		break;
+	case 5:
+		PRINTF(option, "TX frame - 0x%08x\n", p_eng->arg.user_def_val);
+		break;
+	}
+}
+
+static void print_arg_test_mode(MAC_ENGINE *p_eng) 
+{
+	uint8_t item[32] = "test_mode[dec]";
+
+	if (p_eng->arg.run_mode == MODE_NCSI) {
+		printf("%20s| 0: NCSI configuration with    "
+		       "Disable_Channel request\n", item);
+		printf("%20s| (default:%3d)\n", "", DEF_GTESTMODE);
+		printf("%20s| 1: TX/RX delay scan\n", "");
+		printf("%20s| 2: TX/RX delay and IO driving scan\n", "");
+		printf("%20s| 3: NCSI configuration without "
+		       "Disable_Channel request\n", "");
+	} else {
+		printf("%20s| (default:%3d)\n", item, DEF_GTESTMODE);
+		printf("%20s| 0: TX/RX delay margin check\n", "");
+		printf("%20s| 1: TX/RX delay scan\n", "");
+		printf("%20s| 2: TX/RX delay and IO driving scan\n", "");
+		printf("%20s| 3: TX frame - ARP\n", "");
+		printf("%20s| 4: TX frame - random\n", "");
+		printf("%20s| 5: TX frame - user defined (default:0x%8x)\n", "",
+		       DEF_GUSER_DEF_PACKET_VAL);
+	}	
+}
+
+static void print_arg_phy_addr(MAC_ENGINE *p_eng)
+{
+	uint8_t item[32] = "phy_addr[dec]";
+
+	printf("%20s| 0~31: PHY Address (default:%d)\n", item, DEF_GPHY_ADR);
+}
+
+static void print_arg_ieee_select(MAC_ENGINE *p_eng) 
+{
+	uint8_t item[32] = "IEEE packet select";
+
+	printf("%20s| 0/1/2 (default:0)  only for test_mode 3,4,5)\n", item);
+}
+
+static void print_arg_delay_scan_range(MAC_ENGINE *p_eng) 
+{
+	uint8_t item[32] = "TX/RX delay margin";
+
+	printf("%20s| 1/2/3/... (default:%d) only for test_mode 0\n", item,
+	       DEF_GIOTIMINGBUND);
+	printf("%20s| check range = (orig - margin) ~ (orig + margin)\n", "");
+}
+
+static void print_arg_channel_num(MAC_ENGINE *p_eng) 
+{
+	uint8_t item[32] = "channel_num[dec]";
+
+	printf("%20s| 1~32: Total Number of NCSI Channel (default:%d)\n", item,
+	       DEF_GCHANNEL2NUM);
+}
+
+static void print_arg_package_num(MAC_ENGINE *p_eng) 
+{
+	uint8_t item[32] = "package_num[dec]";
+
+	printf("%20s| 1~ 8: Total Number of NCSI Package (default:%d)\n", item,
+	       DEF_GPACKAGE2NUM);
+}
+
+static void print_arg_loop(MAC_ENGINE *p_eng)
+{
+	uint8_t item[32] = "loop_max[dec]";
+
+	printf("%20s| 1G  :  (default:%3d)\n", item, DEF_GLOOP_MAX * 20);
+	printf("%20s| 100M:  (default:%3d)\n", "", DEF_GLOOP_MAX * 2);
+	printf("%20s| 10M :  (default:%3d)\n", "", DEF_GLOOP_MAX);
+}
+
+static void print_arg_ctrl(MAC_ENGINE *p_eng)
+{
+	uint8_t item[32] = "ctrl[hex]";
+
+	printf("%20s| default  : 0x%03x\n", item, DEF_GCTRL);
+	printf("%20s| bit0     : skip PHY init/deinit\n", "");
+	printf("%20s| bit1     : skip PHY deinit\n", "");
+	printf("%20s| bit2     : skip PHY ID check\n", "");
+	printf("%20s| bit3     : reserved\n", "");
+	printf("%20s| bit4     : PHY internal loopback\n", "");
+	printf("%20s| bit5     : MAC internal loopback\n", "");	
+	printf("%20s| bit7~6   : reserved\n", "");
+	printf("%20s| bit8     : RMII 50MHz Output enable\n", "");
+	printf("%20s| bit9     : RMII REFCLK pin input enable\n", "");
+	printf("%20s| bit10    : inverse RGMII RXCLK\n", "");
+	printf("%20s| bit11    : reserved\n", "");
+	printf("%20s| bit12    : TX single packet for each test point\n", "");
+	printf("%20s| bit13    : full range scan\n", "");
+	printf("%20s| bit15~14 : reserved\n", "");
+	printf("%20s| bit16    : NCSI verbose log\n", "");
+	printf("%20s| bit17    : NCSI skip RX error\n", "");
+	printf("%20s| bit31~18 : reserved\n", "");
+}
+
+static void print_arg_speed(MAC_ENGINE *p_eng) 
+{
+	uint8_t item[32] = "speed[hex]";
+
+	printf("%20s| bit[0]->1G  bit[1]->100M  bit[2]->10M "
+	       "(default:0x%02lx)\n",
+	       item, DEF_GSPEED);
+}
+
+static void print_arg_mdio_idx(MAC_ENGINE *p_eng) 
+{
+	uint8_t item[32] = "mdio_idx[dec]";
+
+	printf("%20s| 0->MDIO1 1->MDIO2", item);
+	
+	if (p_eng->env.mac_num > 2) {
+		printf(" 2->MDIO3 3->MDIO4");
+	}
+	printf("\n");
+}
+
+static void print_arg_mac_idx(MAC_ENGINE *p_eng) 
+{
+	uint8_t item[32] = "mac_idx[dec]";
+
+	printf("%20s| 0->MAC1 1->MAC2", item);
+	
+	if (p_eng->env.mac_num > 2) {
+		printf(" 2->MAC3 3->MAC4");
+	}
+	printf("\n");
+}
+static void print_legend(void)
+{
+	printf("Legend:\n");
+	printf("    o : OK\n");	
+	printf("    x : CRC error\n");
+	printf("    . : packet not found\n");
+	printf("    System default setting\n");
+	printf("    O : OK\n");	
+	printf("    X : CRC error\n");
+	printf("    * : packet not found\n");
+}
+static void print_usage(MAC_ENGINE *p_eng)
+{
+	if (MODE_DEDICATED == p_eng->arg.run_mode) {
+		printf("mactest <mac_idx> <mdio_idx> <speed> <ctrl> <loop_max> <test "
+		       "mode> <phy addr> <margin / IEEE select> <user data>\n");
+		print_arg_mac_idx(p_eng);
+		print_arg_mdio_idx(p_eng);
+		print_arg_speed(p_eng);
+		print_arg_ctrl(p_eng);
+		print_arg_loop(p_eng);
+		print_arg_test_mode(p_eng);
+		print_arg_phy_addr(p_eng);
+		print_arg_delay_scan_range(p_eng);
+		print_arg_ieee_select(p_eng);
+	} else if (MODE_NCSI == p_eng->arg.run_mode) {
+		printf("ncsitest <idx> <packet num> <channel num> <test mode> "
+		       "<margin> <ctrl>\n");
+		print_arg_mac_idx(p_eng);
+		print_arg_package_num(p_eng);
+		print_arg_channel_num(p_eng);
+		print_arg_test_mode(p_eng);
+		print_arg_delay_scan_range(p_eng);
+		print_arg_ctrl(p_eng);
+	} else {
+		printf("unknown run mode\n");
+	}
+}
+
+static void push_reg(MAC_ENGINE *p_eng)
+{
+	/* SCU delay settings */
+	p_eng->io.mac12_1g_delay.value.w = readl(p_eng->io.mac12_1g_delay.addr);
+	p_eng->io.mac12_100m_delay.value.w = readl(p_eng->io.mac12_100m_delay.addr);
+	p_eng->io.mac12_10m_delay.value.w = readl(p_eng->io.mac12_10m_delay.addr);
+		
+#ifdef CONFIG_ASPEED_AST2600
+	p_eng->io.mac34_1g_delay.value.w = readl(p_eng->io.mac34_1g_delay.addr);
+	p_eng->io.mac34_100m_delay.value.w = readl(p_eng->io.mac34_100m_delay.addr);
+	p_eng->io.mac34_10m_delay.value.w = readl(p_eng->io.mac34_10m_delay.addr);
+	
+	p_eng->io.mac34_drv_reg.value.w = readl(p_eng->io.mac34_drv_reg.addr);
+#else
+	p_eng->io.mac12_drv_reg.value.w = readl(p_eng->io.mac12_drv_reg.addr);
+#endif
+
+	/* MAC registers */
+	p_eng->reg.maccr.w = mac_reg_read(p_eng, 0x50);
+
+	p_eng->reg.mac_madr = mac_reg_read(p_eng, 0x08);
+	p_eng->reg.mac_ladr = mac_reg_read(p_eng, 0x0c);
+	p_eng->reg.mac_fear = mac_reg_read(p_eng, 0x40);
+}
+
+static void pop_reg(MAC_ENGINE *p_eng)
+{
+	/* SCU delay settings */
+	writel(p_eng->io.mac12_1g_delay.value.w, p_eng->io.mac12_1g_delay.addr);
+	writel(p_eng->io.mac12_100m_delay.value.w, p_eng->io.mac12_100m_delay.addr);
+	writel(p_eng->io.mac12_10m_delay.value.w, p_eng->io.mac12_10m_delay.addr);	
+
+#ifdef CONFIG_ASPEED_AST2600	
+	writel(p_eng->io.mac34_1g_delay.value.w, p_eng->io.mac34_1g_delay.addr);
+	writel(p_eng->io.mac34_100m_delay.value.w, p_eng->io.mac34_100m_delay.addr);
+	writel(p_eng->io.mac34_10m_delay.value.w, p_eng->io.mac34_10m_delay.addr);
+	
+	writel(p_eng->io.mac34_drv_reg.value.w, p_eng->io.mac34_drv_reg.addr);
+#else
+	writel(p_eng->io.mac12_drv_reg.value.w, p_eng->io.mac12_drv_reg.addr);
+#endif
+
+	/* MAC registers */
+	mac_reg_write(p_eng, 0x50, p_eng->reg.maccr.w);
+	mac_reg_write(p_eng, 0x08, p_eng->reg.mac_madr);
+	mac_reg_write(p_eng, 0x0c, p_eng->reg.mac_ladr);
+	mac_reg_write(p_eng, 0x40, p_eng->reg.mac_fear);
+}
+
+static void finish_close(MAC_ENGINE *p_eng) 
+{
+	nt_log_func_name();		
+	pop_reg(p_eng);
+}
+
+char finish_check(MAC_ENGINE *p_eng, int value) 
+{
+	nt_log_func_name();
+
+	if (p_eng->arg.run_mode == MODE_DEDICATED) {
+		if (p_eng->dat.FRAME_LEN)
+			free(p_eng->dat.FRAME_LEN);
+
+		if (p_eng->dat.wp_lst)
+			free(p_eng->dat.wp_lst);
+	}
+
+	p_eng->flg.error = p_eng->flg.error | value;
+
+	if (DBG_PRINT_ERR_FLAG)
+		printf("flags: error = %08x\n", p_eng->flg.error);
+
+	if (!p_eng->run.tm_tx_only)
+		FPri_ErrFlag(p_eng, FP_LOG);
+
+	if (p_eng->run.TM_IOTiming)
+		FPri_ErrFlag(p_eng, FP_IO);
+
+	FPri_ErrFlag(p_eng, STD_OUT);
+
+	if (!p_eng->run.tm_tx_only)
+		FPri_End(p_eng, FP_LOG);
+
+	if (p_eng->run.TM_IOTiming)
+		FPri_End(p_eng, FP_IO);
+
+	FPri_End(p_eng, STD_OUT);
+
+	if (!p_eng->run.tm_tx_only)
+		FPri_RegValue(p_eng, FP_LOG);
+	if (p_eng->run.TM_IOTiming)
+		FPri_RegValue(p_eng, FP_IO);
+
+	finish_close(p_eng);
+
+	if (p_eng->flg.error) {
+		return (1);
+	} else {
+		return (0);
+	}
+}
+
+static uint32_t check_test_mode(MAC_ENGINE *p_eng)
+{
+	if (p_eng->arg.run_mode == MODE_NCSI ) {
+		switch (p_eng->arg.test_mode) {
+		case 0:
+			break;
+		case 1:
+			p_eng->run.TM_IOTiming = 1;
+			break;
+		case 2:
+			p_eng->run.TM_IOTiming = 1;
+			p_eng->run.TM_IOStrength = 1;
+			break;
+		case 3:
+			p_eng->run.TM_NCSI_DiSChannel = 0;
+			break;
+		default:
+			printf("Error test_mode!!!\n");
+			print_arg_test_mode(p_eng);
+			return (1);
+		}
+	} else {
+		switch (p_eng->arg.test_mode) {
+		case 0:
+			break;
+		case 1:
+			p_eng->run.TM_IOTiming = 1;
+			break;
+		case 2:
+			p_eng->run.TM_IOTiming = 1;
+			p_eng->run.TM_IOStrength = 1;
+			break;
+		case 3:
+			/* TX ARP frame */
+			p_eng->run.TM_RxDataEn = 0;
+			p_eng->run.tm_tx_only = 1;
+			p_eng->run.TM_IEEE = 0;
+			break;
+		case 4:
+		case 5:			
+			p_eng->run.TM_RxDataEn = 0;
+			p_eng->run.tm_tx_only = 1;
+			p_eng->run.TM_IEEE = 1;
+			break;
+		default:
+			printf("Error test_mode!!!\n");
+			print_arg_test_mode(p_eng);
+			return (1);
+		}
+	}
+
+	if (0 == p_eng->run.TM_IOStrength) {
+		p_eng->io.drv_upper_bond = 0;
+	}
+	return 0;
+}
+
+/**
+ * @brief enable/disable MAC
+ * @param[in] p_eng - MAC_ENGINE
+ * 
+ * AST2600 uses synchronous reset scheme, so the bits for reset assert and 
+ * deassert are the same
+ * e.g. MAC#1: SCU04[11] = 1 --> MAC#1 reset assert
+ *                       = 0 --> MAC#1 reset de-assert
+ * 
+ * AST2600 uses asynchronous reset scheme, so the bits for reset assert and 
+ * deassert are different
+ * e.g. MAC#1: SCU40[11] = 1 --> MAC#1 reset assert
+ *             SCU44[11] = 1 --> MAC#1 reset de-assert
+ * 
+ * The same design concept is also adopted on clock stop/start.
+ */
+void scu_disable_mac(MAC_ENGINE *p_eng) 
+{
+	uint32_t mac_idx = p_eng->run.mac_idx;
+	const struct mac_ctrl_desc *p_mac = &mac_ctrl_lookup_tbl[mac_idx];
+	uint32_t reg = 0;
+
+	debug("MAC%d:reset assert=0x%02x[%08x] deassert=0x%02x[%08x]\n",
+	      mac_idx, p_mac->base_reset_assert, p_mac->bit_reset_assert,
+	      p_mac->base_reset_deassert, p_mac->bit_reset_deassert);
+	debug("MAC%d:clock stop=0x%02x[%08x] start=0x%02x[%08x]\n", mac_idx,
+	      p_mac->base_clk_stop, p_mac->bit_clk_stop, p_mac->base_clk_start,
+	      p_mac->bit_clk_start);
+
+	reg = SCU_RD(p_mac->base_reset_assert);
+	debug("reset reg: 0x%08x\n", reg);
+	reg |= p_mac->bit_reset_assert;
+	debug("reset reg: 0x%08x\n", reg);
+	SCU_WR(reg, p_mac->base_reset_assert);
+	/* issue a dummy read to ensure command is in order */
+	reg = SCU_RD(p_mac->base_reset_assert);
+	
+	reg = SCU_RD(p_mac->base_clk_stop);
+	debug("clock reg: 0x%08x\n", reg);
+	reg |= p_mac->bit_clk_stop;
+	debug("clock reg: 0x%08x\n", reg);
+	SCU_WR(reg, p_mac->base_clk_stop);
+	/* issue a dummy read to ensure command is in order */
+	reg = SCU_RD(p_mac->base_clk_stop);
+}
+
+void scu_enable_mac(MAC_ENGINE *p_eng) 
+{
+	uint32_t mac_idx = p_eng->run.mac_idx;
+	const struct mac_ctrl_desc *p_mac = &mac_ctrl_lookup_tbl[mac_idx];
+	uint32_t reg = 0;
+
+	debug("MAC%d:reset assert=0x%02x[%08x] deassert=0x%02x[%08x]\n",
+	      mac_idx, p_mac->base_reset_assert, p_mac->bit_reset_assert,
+	      p_mac->base_reset_deassert, p_mac->bit_reset_deassert);
+	debug("MAC%d:clock stop=0x%02x[%08x] start=0x%02x[%08x]\n", mac_idx,
+	      p_mac->base_clk_stop, p_mac->bit_clk_stop, p_mac->base_clk_start,
+	      p_mac->bit_clk_start);
+
+#ifdef CONFIG_ASPEED_AST2600
+	reg = SCU_RD(p_mac->base_reset_deassert);
+	debug("reset reg: 0x%08x\n", reg);
+	reg |= p_mac->bit_reset_deassert;
+	debug("reset reg: 0x%08x\n", reg);
+	SCU_WR(reg, p_mac->base_reset_deassert);
+	/* issue a dummy read to ensure command is in order */
+	reg = SCU_RD(p_mac->base_reset_deassert);
+	
+	reg = SCU_RD(p_mac->base_clk_start);
+	debug("clock reg: 0x%08x\n", reg);
+	reg |= p_mac->bit_clk_start;
+	debug("clock reg: 0x%08x\n", reg);
+	SCU_WR(reg, p_mac->base_clk_start);
+	/* issue a dummy read to ensure command is in order */
+	reg = SCU_RD(p_mac->base_clk_start);
+#else
+	reg = SCU_RD(p_mac->base_reset_deassert);
+	reg &= ~p_mac->bit_reset_deassert;
+	SCU_WR(reg, p_mac->base_reset_deassert);
+	/* issue a dummy read to ensure command is in order */
+	reg = SCU_RD(p_mac->base_reset_deassert);
+	
+	reg = SCU_RD(p_mac->base_clk_start);
+	reg &= ~p_mac->bit_clk_start;
+	SCU_WR(reg, p_mac->base_clk_start);
+	/* issue a dummy read to ensure command is in order */
+	reg = SCU_RD(p_mac->base_clk_start);
+#endif
+}
+
+/**
+ * @brief setup mdc/mdio pinmix
+ * @todo push/pop pinmux registers
+*/
+void scu_set_pinmux(MAC_ENGINE *p_eng)
+{
+	uint32_t reg = 0;
+	nt_log_func_name();
+
+#ifdef CONFIG_ASPEED_AST2600
+	/* MDC/MDIO pinmux */
+	switch (p_eng->run.mdio_idx) {
+	case 0:
+		reg = SCU_RD(0x430) | GENMASK(17, 16);
+		SCU_WR(reg, 0x430);
+		break;
+	case 1:
+		reg = SCU_RD(0x470) & ~GENMASK(13, 12);
+		SCU_WR(reg, 0x470);
+		reg = SCU_RD(0x410) | GENMASK(13, 12);
+		SCU_WR(reg, 0x410);
+		break;
+	case 2:
+		reg = SCU_RD(0x470) & ~GENMASK(1, 0);
+		SCU_WR(reg, 0x470);
+		reg = SCU_RD(0x410) | GENMASK(1, 0);
+		SCU_WR(reg, 0x410);
+		break;
+	case 3:
+		reg = SCU_RD(0x470) & ~GENMASK(3, 2);
+		SCU_WR(reg, 0x470);
+		reg = SCU_RD(0x410) | GENMASK(3, 2);
+		SCU_WR(reg, 0x410);
+		break;
+	default:
+		printf("%s:undefined MDIO idx %d\n", __func__,
+		       p_eng->run.mdio_idx);
+	}
+
+	switch (p_eng->run.mac_idx) {
+	case 0:
+#ifdef CONFIG_FPGA_ASPEED
+		setbits_le32(SCU_BASE + 0x410, BIT(4));
+#else
+		setbits_le32(SCU_BASE + 0x400, GENMASK(11, 0));
+		setbits_le32(SCU_BASE + 0x410, BIT(4));
+		clrbits_le32(SCU_BASE + 0x470, BIT(4));
+#endif
+		break;
+	case 1:
+		setbits_le32(SCU_BASE + 0x400, GENMASK(23, 12));
+		setbits_le32(SCU_BASE + 0x410, BIT(5));
+		clrbits_le32(SCU_BASE + 0x470, BIT(5));
+		break;
+	case 2:
+		setbits_le32(SCU_BASE + 0x410, GENMASK(27, 16));
+		setbits_le32(SCU_BASE + 0x410, BIT(6));
+		clrbits_le32(SCU_BASE + 0x470, BIT(6));
+		break;
+	case 3:
+		clrbits_le32(SCU_BASE + 0x410, GENMASK(31, 28));
+		setbits_le32(SCU_BASE + 0x4b0, GENMASK(31, 28));
+		clrbits_le32(SCU_BASE + 0x474, GENMASK(7, 0));
+		clrbits_le32(SCU_BASE + 0x414, GENMASK(7, 0));
+		setbits_le32(SCU_BASE + 0x4b4, GENMASK(7, 0));
+		setbits_le32(SCU_BASE + 0x410, BIT(7));
+		clrbits_le32(SCU_BASE + 0x470, BIT(7));
+		break;
+
+	}
+
+	debug("SCU410: %08x %08x %08x %08x\n", SCU_RD(0x410), SCU_RD(0x414), SCU_RD(0x418), SCU_RD(0x41c));
+	debug("SCU430: %08x %08x %08x %08x\n", SCU_RD(0x430), SCU_RD(0x434), SCU_RD(0x438), SCU_RD(0x43c));
+	debug("SCU470: %08x %08x %08x %08x\n", SCU_RD(0x470), SCU_RD(0x474), SCU_RD(0x478), SCU_RD(0x47c));
+	debug("SCU4b0: %08x %08x %08x %08x\n", SCU_RD(0x4b0), SCU_RD(0x4b4), SCU_RD(0x4b8), SCU_RD(0x4bc));
+#else
+	/* MDC/MDIO pinmux */
+	if (p_eng->run.mdio_idx == 0) {
+		setbits_le32(SCU_BASE + 88, GENMASK(31, 30));
+	} else {
+		clrsetbits_le32(SCU_BASE + 90, BIT(6), BIT(2));
+	}
+
+	/* enable MAC#nLINK pin */
+	setbits_le32(SCU_BASE + 80, BIT(p_eng->run.mac_idx));
+#endif
+}
+
+static uint32_t check_mac_idx(MAC_ENGINE *p_eng)
+{
+	/* check if legal run_idx */
+	if (p_eng->arg.mac_idx > p_eng->env.mac_num - 1) {
+		printf("invalid run_idx = %d\n", p_eng->arg.mac_idx);	
+		return 1;
+	}
+	
+	return 0;
+}
+
+static void calc_loop_check_num(MAC_ENGINE *p_eng)
+{
+	nt_log_func_name();
+
+	if (p_eng->run.IO_MrgChk ||
+	    (p_eng->arg.run_speed == SET_1G_100M_10MBPS) ||
+	    (p_eng->arg.run_speed == SET_100M_10MBPS)) {
+		p_eng->run.LOOP_CheckNum = p_eng->run.loop_max;
+	} else {
+		switch (p_eng->arg.run_speed) {
+		case SET_1GBPS:
+			p_eng->run.CheckBuf_MBSize = MOVE_DATA_MB_SEC;
+			break;
+		case SET_100MBPS:
+			p_eng->run.CheckBuf_MBSize = (MOVE_DATA_MB_SEC >> 3);
+			break;
+		case SET_10MBPS:
+			p_eng->run.CheckBuf_MBSize = (MOVE_DATA_MB_SEC >> 6);
+			break;
+		}
+		p_eng->run.LOOP_CheckNum =
+		    (p_eng->run.CheckBuf_MBSize /
+		     (((p_eng->dat.Des_Num * DMA_PakSize) >> 20) + 1));
+	}
+}
+static uint32_t setup_interface(MAC_ENGINE *p_eng);
+static uint32_t setup_running(MAC_ENGINE *p_eng)
+{
+	uint32_t n_desp_min;
+	int i;
+
+	if (0 != check_mac_idx(p_eng)) {
+		return 1;
+	}
+	p_eng->run.mac_idx = p_eng->arg.mac_idx;
+	p_eng->run.mac_base = mac_base_lookup_tbl[p_eng->run.mac_idx];	
+	
+	p_eng->run.mdio_idx = p_eng->arg.mdio_idx;
+	p_eng->run.mdio_base = mdio_base_lookup_tbl[p_eng->run.mdio_idx];
+
+	p_eng->run.is_rgmii = p_eng->env.is_1g_valid[p_eng->run.mac_idx];
+
+	if (p_eng->arg.run_mode == MODE_NCSI) {
+#ifdef CONFIG_ASPEED_AST2600
+		/**
+		 * NCSI needs for 3.3V IO voltage but MAC#1 & MAC#2 only
+		 * support 1.8V. So NCSI can only runs on MAC#3 or MAC#4
+		 */
+		if (p_eng->run.mac_idx < 2) {
+			printf("\nNCSI must runs on MAC#3 or MAC#4\n");
+			return 1;
+		}
+
+		if (p_eng->run.is_rgmii) {
+			hw_strap2_t strap2;
+			
+			printf("\nNCSI must be RMII interface, force the strap value:\n");
+			printf("\nbefore: SCU510=%08x\n", SCU_RD(0x510));
+			strap2.w = 0;
+			if (p_eng->run.mac_idx == 2) {
+				strap2.b.mac3_interface = 1;
+			} else if (p_eng->run.mac_idx == 3) {
+				strap2.b.mac4_interface = 1;
+			}
+			SCU_WR(strap2.w, 0x514);
+			while (SCU_RD(0x510) & strap2.w);
+			printf("\nafter: SCU510=%08x\n", SCU_RD(0x510));
+			/* update interface setting */
+			setup_interface(p_eng);
+			p_eng->run.is_rgmii = p_eng->env.is_1g_valid[p_eng->run.mac_idx];
+		}
+#else
+		if (p_eng->run.is_rgmii) {
+			printf("\nNCSI must be RMII interface\n");
+			return 1;
+		}
+#endif
+	}
+
+	for (i = 0; i < 3; i++) {
+		if (p_eng->arg.run_speed & (1 << i))
+			p_eng->run.speed_cfg[i] = 1;
+	}
+
+	if (p_eng->arg.run_mode == MODE_NCSI) {
+		/*
+		 * [Arg]check GPackageTolNum
+		 * [Arg]check GChannelTolNum
+		 */
+		if ((p_eng->arg.GPackageTolNum < 1) ||
+		    (p_eng->arg.GPackageTolNum > 8)) {
+			print_arg_package_num(p_eng);
+			return (1);
+		}
+		if ((p_eng->arg.GChannelTolNum < 1) ||
+		    (p_eng->arg.GChannelTolNum > 32)) {
+			print_arg_channel_num(p_eng);
+			return (1);
+		}
+	} else {
+		/* [Arg]check ctrl */		
+		if (p_eng->arg.ctrl.w & 0xfffc0000) {
+			print_arg_ctrl(p_eng);
+			return (1);
+		}
+
+		if (p_eng->arg.phy_addr > 31) {
+			printf("Error phy_adr!!!\n");
+			print_arg_phy_addr(p_eng);
+			return (1);
+		}
+
+		if (0 == p_eng->arg.loop_max) {
+			switch (p_eng->arg.run_speed) {
+			case SET_1GBPS:
+				p_eng->arg.loop_max = DEF_GLOOP_MAX * 20;
+				break;
+			case SET_100MBPS:
+				p_eng->arg.loop_max = DEF_GLOOP_MAX * 2;
+				break;
+			case SET_10MBPS:
+				p_eng->arg.loop_max = DEF_GLOOP_MAX;
+				break;
+			case SET_1G_100M_10MBPS:
+				p_eng->arg.loop_max = DEF_GLOOP_MAX * 20;
+				break;
+			case SET_100M_10MBPS:
+				p_eng->arg.loop_max = DEF_GLOOP_MAX * 2;
+				break;
+			}
+		}		
+	}
+
+	if (0 != check_test_mode(p_eng)) {
+		return 1;
+	}
+
+	if (p_eng->run.tm_tx_only) {
+		p_eng->run.ieee_sel = p_eng->arg.ieee_sel;
+		p_eng->run.delay_margin = 0;
+	} else {
+		p_eng->run.ieee_sel = 0;			
+		p_eng->run.delay_margin = p_eng->arg.delay_scan_range;
+#if 0
+		if (p_eng->run.delay_margin == 0) {
+			printf("Error IO margin!!!\n");
+			print_arg_delay_scan_range(p_eng);
+			return(1);
+		}
+#endif								
+	}
+
+	if (!p_eng->env.is_1g_valid[p_eng->run.mac_idx])
+		p_eng->run.speed_cfg[ 0 ] = 0;
+	
+	p_eng->run.tdes_base = (uint32_t)(&tdes_buf[0]);
+	p_eng->run.rdes_base = (uint32_t)(&rdes_buf[0]);
+
+	if (p_eng->run.TM_IOTiming || p_eng->run.delay_margin)
+		p_eng->run.IO_MrgChk = 1;
+	else
+		p_eng->run.IO_MrgChk = 0;
+
+	p_eng->phy.Adr         = p_eng->arg.phy_addr;
+	p_eng->phy.loopback    = p_eng->arg.ctrl.b.phy_int_loopback;
+	p_eng->phy.default_phy = p_eng->run.TM_DefaultPHY;
+
+	p_eng->run.loop_max = p_eng->arg.loop_max;
+	calc_loop_check_num(p_eng);
+
+	//------------------------------------------------------------
+	// Descriptor Number
+	//------------------------------------------------------------
+	//------------------------------
+	// [Dat]setup Des_Num
+	// [Dat]setup DMABuf_Size
+	// [Dat]setup DMABuf_Num
+	//------------------------------
+	if (p_eng->arg.run_mode == MODE_DEDICATED) {
+		n_desp_min = p_eng->run.TM_IOTiming;
+
+		if (p_eng->arg.ctrl.b.skip_phy_id_check &&
+		    (p_eng->arg.test_mode == 0))
+			/* for SMSC's LAN9303 issue */
+			p_eng->dat.Des_Num = 114;
+		else {
+			switch (p_eng->arg.run_speed) {
+			case SET_1GBPS:
+				p_eng->dat.Des_Num =
+				    p_eng->run.delay_margin
+					? 100
+					: (n_desp_min) ? 512 : 4096;
+				break;
+			case SET_100MBPS:
+				p_eng->dat.Des_Num =
+				    p_eng->run.delay_margin
+					? 100
+					: (n_desp_min) ? 512 : 4096;
+				break;
+			case SET_10MBPS:
+				p_eng->dat.Des_Num =
+				    p_eng->run.delay_margin
+					? 100
+					: (n_desp_min) ? 100 : 830;
+				break;
+			case SET_1G_100M_10MBPS:
+				p_eng->dat.Des_Num =
+				    p_eng->run.delay_margin
+					? 100
+					: (n_desp_min) ? 100 : 830;
+				break;
+			case SET_100M_10MBPS:
+				p_eng->dat.Des_Num =
+				    p_eng->run.delay_margin
+					? 100
+					: (n_desp_min) ? 100 : 830;
+				break;
+			}
+		}
+		/* keep in order: Des_Num -> DMABuf_Size -> DMABuf_Num */
+		p_eng->dat.Des_Num_Org = p_eng->dat.Des_Num;
+		p_eng->dat.DMABuf_Size = DMA_BufSize;
+		p_eng->dat.DMABuf_Num = DMA_BufNum;
+
+		if (DbgPrn_Info) {
+			printf("CheckBuf_MBSize : %d\n",
+			       p_eng->run.CheckBuf_MBSize);
+			printf("LOOP_CheckNum   : %d\n",
+			       p_eng->run.LOOP_CheckNum);
+			printf("Des_Num         : %d\n", p_eng->dat.Des_Num);
+			printf("DMA_BufSize     : %d bytes\n",
+			       p_eng->dat.DMABuf_Size);
+			printf("DMA_BufNum      : %d\n", p_eng->dat.DMABuf_Num);
+			printf("DMA_PakSize     : %d\n", DMA_PakSize);
+			printf("\n");
+		}
+		if (2 > p_eng->dat.DMABuf_Num)
+			return (finish_check(p_eng, Err_Flag_DMABufNum));
+	}
+
+	return 0;
+}
+
+/**
+ * @brief setup environment according to HW strap registers
+*/
+static uint32_t setup_interface(MAC_ENGINE *p_eng)
+{
+#ifdef CONFIG_ASPEED_AST2600
+	hw_strap1_t strap1;
+	hw_strap2_t strap2;
+	
+	strap1.w = SCU_RD(0x500);
+	strap2.w = SCU_RD(0x510);
+
+	p_eng->env.is_1g_valid[0] = strap1.b.mac1_interface;
+	p_eng->env.is_1g_valid[1] = strap1.b.mac2_interface;
+	p_eng->env.is_1g_valid[2] = strap2.b.mac3_interface;
+	p_eng->env.is_1g_valid[3] = strap2.b.mac4_interface;
+	
+	p_eng->env.at_least_1g_valid =
+	    p_eng->env.is_1g_valid[0] | p_eng->env.is_1g_valid[1] |
+	    p_eng->env.is_1g_valid[2] | p_eng->env.is_1g_valid[3];
+#else
+	hw_strap1_t strap1;
+	strap1.w = SCU_RD(0x70);
+	p_eng->env.is_1g_valid[0] = strap1.b.mac1_interface;
+	p_eng->env.is_1g_valid[1] = strap1.b.mac2_interface;
+
+	p_eng->env.at_least_1g_valid =
+	    p_eng->env.is_1g_valid[0] | p_eng->env.is_1g_valid[1];
+#endif
+	return 0;
+}
+
+/**
+ * @brief setup chip compatibility accoriding to the chip ID register
+*/
+static uint32_t setup_chip_compatibility(MAC_ENGINE *p_eng)
+{
+	uint32_t reg_addr = 0;
+	uint32_t id, version = 0;
+	uint32_t is_valid = 0;
+
+	p_eng->env.ast2600 = 0;
+	p_eng->env.ast2500 = 0;
+
+#if defined(CONFIG_ASPEED_AST2600)
+	reg_addr = 0x04;
+#else
+	reg_addr = 0x7c;
+#endif
+	is_valid = 0;
+	id = (SCU_RD(reg_addr) & GENMASK(31, 24)) >> 24;
+	version = (SCU_RD(reg_addr) & GENMASK(23, 16)) >> 16;
+
+#if defined(CONFIG_FPGA_ASPEED) && defined(CONFIG_ASPEED_AST2600)
+	id = 0x5;
+#endif
+	if (id == 0x5) {
+		printf("chip: AST2600 A%d\n", version);
+		p_eng->env.ast2600 = 1;
+		p_eng->env.ast2500 = 1;
+		p_eng->env.mac_num = 4;
+		p_eng->env.is_new_mdio_reg[0] = 1;
+		p_eng->env.is_new_mdio_reg[1] = 1;
+		p_eng->env.is_new_mdio_reg[2] = 1;
+		p_eng->env.is_new_mdio_reg[3] = 1;
+		is_valid = 1;
+	} else if (id == 0x4) {
+		printf("chip: AST2500 A%d\n", version);
+		p_eng->env.ast2500 = 1;
+		p_eng->env.mac_num = 2;
+		p_eng->env.is_new_mdio_reg[0] = MAC1_RD(0x40) >> 31;
+		p_eng->env.is_new_mdio_reg[1] = MAC2_RD(0x40) >> 31;
+		is_valid = 1;
+	}
+
+	if (0 == is_valid) {
+		printf("unknown chip\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * @brief setup environment accoriding to the HW strap and chip ID
+*/
+static uint32_t setup_env(MAC_ENGINE *p_eng)
+{
+	if (0 != setup_chip_compatibility(p_eng)) {
+		return 1;
+	}
+	
+	setup_interface(p_eng);
+	return 0;
+}
+
+static uint32_t init_mac_engine(MAC_ENGINE *p_eng, uint32_t mode)
+{
+	memset(p_eng, 0, sizeof(MAC_ENGINE));
+
+	if (0 != setup_env(p_eng)) {
+		return 1;
+	}
+	
+	p_eng->arg.run_mode = mode;
+	p_eng->arg.delay_scan_range = DEF_GIOTIMINGBUND;
+	p_eng->arg.test_mode = DEF_GTESTMODE;
+
+	if (p_eng->arg.run_mode == MODE_NCSI ) {
+		p_eng->arg.GARPNumCnt = DEF_GARPNUMCNT;
+		p_eng->arg.GChannelTolNum = DEF_GCHANNEL2NUM;
+		p_eng->arg.GPackageTolNum = DEF_GPACKAGE2NUM;
+		p_eng->arg.ctrl.w = 0;
+		p_eng->arg.run_speed = SET_100MBPS;        // In NCSI mode, we set to 100M bps
+	} else {
+		p_eng->arg.user_def_val  = DEF_GUSER_DEF_PACKET_VAL;
+		p_eng->arg.phy_addr  = DEF_GPHY_ADR;
+		p_eng->arg.loop_inf = 0;
+		p_eng->arg.loop_max = 0;
+		p_eng->arg.ctrl.w = DEF_GCTRL;
+		p_eng->arg.run_speed = DEF_GSPEED;
+	}
+
+	p_eng->flg.print_en  = 1;	
+	
+	p_eng->run.TM_TxDataEn = 1;
+	p_eng->run.TM_RxDataEn = 1;
+	p_eng->run.TM_NCSI_DiSChannel = 1;
+
+	/* setup 
+	 * 1. delay control register
+	 * 2. driving strength control register and upper/lower bond
+	 * 3. MAC control register
+	 */
+#ifdef CONFIG_ASPEED_AST2600
+	p_eng->io.mac12_1g_delay.addr = SCU_BASE + 0x340;
+	p_eng->io.mac12_1g_delay.tx_min = 0;
+	p_eng->io.mac12_1g_delay.tx_max = 63;
+	p_eng->io.mac12_1g_delay.rx_min = -63;
+	p_eng->io.mac12_1g_delay.rx_max = 63;
+	p_eng->io.mac12_1g_delay.rmii_tx_min = 0;
+	p_eng->io.mac12_1g_delay.rmii_tx_max = 1;
+	p_eng->io.mac12_1g_delay.rmii_rx_min = 0;
+	p_eng->io.mac12_1g_delay.rmii_rx_max = 63;
+
+	p_eng->io.mac12_100m_delay.addr = SCU_BASE + 0x348;
+	p_eng->io.mac12_100m_delay.tx_min = 0;
+	p_eng->io.mac12_100m_delay.tx_max = 63;
+	p_eng->io.mac12_100m_delay.rx_min = -63;
+	p_eng->io.mac12_100m_delay.rx_max = 63;
+	p_eng->io.mac12_10m_delay.addr = SCU_BASE + 0x34c;
+	p_eng->io.mac12_10m_delay.tx_min = 0;
+	p_eng->io.mac12_10m_delay.tx_max = 63;
+	p_eng->io.mac12_10m_delay.rx_min = -63;
+	p_eng->io.mac12_10m_delay.rx_max = 63;
+
+	p_eng->io.mac34_1g_delay.addr = SCU_BASE + 0x350;
+	p_eng->io.mac34_1g_delay.tx_min = 0;
+	p_eng->io.mac34_1g_delay.tx_max = 63;
+	p_eng->io.mac34_1g_delay.rx_min = -63;
+	p_eng->io.mac34_1g_delay.rx_max = 63;
+	p_eng->io.mac34_1g_delay.rmii_tx_min = 0;
+	p_eng->io.mac34_1g_delay.rmii_tx_max = 1;
+	p_eng->io.mac34_1g_delay.rmii_rx_min = 0;
+	p_eng->io.mac34_1g_delay.rmii_rx_max = 63;
+	p_eng->io.mac34_100m_delay.addr = SCU_BASE + 0x358;
+	p_eng->io.mac34_100m_delay.tx_min = 0;
+	p_eng->io.mac34_100m_delay.tx_max = 63;
+	p_eng->io.mac34_100m_delay.rx_min = -63;
+	p_eng->io.mac34_100m_delay.rx_max = 63;
+	p_eng->io.mac34_10m_delay.addr = SCU_BASE + 0x35c;
+	p_eng->io.mac34_10m_delay.tx_min = 0;
+	p_eng->io.mac34_10m_delay.tx_max = 63;
+	p_eng->io.mac34_10m_delay.rx_min = -63;
+	p_eng->io.mac34_10m_delay.rx_max = 63;
+
+	p_eng->io.mac34_drv_reg.addr = SCU_BASE + 0x458;
+	p_eng->io.mac34_drv_reg.drv_max = 0x3;
+	p_eng->io.drv_upper_bond = 0x3;
+	p_eng->io.drv_lower_bond = 0;
+#else
+	p_eng->io.mac12_1g_delay.addr = SCU_BASE + 0x48;
+	p_eng->io.mac12_1g_delay.tx_min = 0;
+	p_eng->io.mac12_1g_delay.tx_max = 63;
+	p_eng->io.mac12_1g_delay.rx_min = 0;
+	p_eng->io.mac12_1g_delay.rx_max = 63;
+	p_eng->io.mac12_1g_delay.rmii_tx_min = 0;
+	p_eng->io.mac12_1g_delay.rmii_tx_max = 1;
+	p_eng->io.mac12_1g_delay.rmii_rx_min = 0;
+	p_eng->io.mac12_1g_delay.rmii_rx_max = 63;
+	p_eng->io.mac12_100m_delay.addr = SCU_BASE + 0xb8;
+	p_eng->io.mac12_100m_delay.tx_min = 0;
+	p_eng->io.mac12_100m_delay.tx_max = 63;
+	p_eng->io.mac12_100m_delay.rx_min = 0;
+	p_eng->io.mac12_100m_delay.rx_max = 63;
+	p_eng->io.mac12_10m_delay.addr = SCU_BASE + 0xbc;
+	p_eng->io.mac12_10m_delay.tx_min = 0;
+	p_eng->io.mac12_10m_delay.tx_max = 63;
+	p_eng->io.mac12_10m_delay.rx_min = 0;
+	p_eng->io.mac12_10m_delay.rx_max = 63;
+
+	p_eng->io.mac34_1g_delay.addr = 0;
+	p_eng->io.mac34_100m_delay.addr = 0;
+	p_eng->io.mac34_10m_delay.addr = 0;
+
+	p_eng->io.mac12_drv_reg.addr = SCU_BASE + 0x90;
+	p_eng->io.mac12_drv_reg.drv_max = 0x1;
+	p_eng->io.drv_upper_bond = 0x1;
+	p_eng->io.drv_lower_bond = 0;
+#endif
+	return 0;
+}
+
+static uint32_t parse_arg_dedicated(int argc, char *const argv[],
+				    MAC_ENGINE *p_eng) 
+{
+	switch (argc) {
+	case 10:
+		p_eng->arg.user_def_val = simple_strtol(argv[9], NULL, 16);
+	case 9:
+		p_eng->arg.delay_scan_range = simple_strtol(argv[8], NULL, 10);
+		p_eng->arg.ieee_sel = p_eng->arg.delay_scan_range;
+	case 8:
+		p_eng->arg.phy_addr = simple_strtol(argv[7], NULL, 10);
+	case 7:
+		p_eng->arg.test_mode = simple_strtol(argv[6], NULL, 16);
+		printf("test mode = %d\n", p_eng->arg.test_mode);
+	case 6:		
+		p_eng->arg.loop_max = simple_strtol(argv[5], NULL, 10);
+		if (p_eng->arg.loop_max == -1) {
+			p_eng->arg.loop_inf = 1;
+		}
+		printf("loop max=%d, loop_inf=%d\n", p_eng->arg.loop_max, p_eng->arg.loop_inf);
+	case 5:
+		p_eng->arg.ctrl.w = simple_strtol(argv[4], NULL, 16);
+		printf("ctrl=0x%05x\n", p_eng->arg.ctrl.w);
+	case 4:
+		p_eng->arg.run_speed = simple_strtol(argv[3], NULL, 16);
+		printf("speed=0x%1x\n", p_eng->arg.run_speed);
+	case 3:
+		p_eng->arg.mdio_idx = simple_strtol(argv[2], NULL, 10);
+		printf("mdio_idx=%d\n", p_eng->arg.mdio_idx);		
+	}
+
+	return 0;
+}
+
+static uint32_t parse_arg_ncsi(int argc, char *const argv[], MAC_ENGINE *p_eng) 
+{
+	switch (argc) {
+	case 8:
+		p_eng->arg.GARPNumCnt = simple_strtol(argv[7], NULL, 10);
+	case 7:
+		p_eng->arg.ctrl.w = simple_strtol(argv[6], NULL, 16);
+	case 6:
+		p_eng->arg.delay_scan_range = simple_strtol(argv[5], NULL, 10);		
+	case 5:
+		p_eng->arg.test_mode = simple_strtol(argv[4], NULL, 16);
+	case 4:
+		p_eng->arg.GChannelTolNum  = simple_strtol(argv[3], NULL, 10);
+	case 3:
+		p_eng->arg.GPackageTolNum  = simple_strtol(argv[2], NULL, 10);
+	}
+	return 0;
+}
+
+
+static void disable_wdt(MAC_ENGINE *p_eng)
+{
+	/* FIXME */
+	return;
+}
+
+static uint32_t setup_data(MAC_ENGINE *p_eng)
+{
+	if (p_eng->arg.run_mode == MODE_DEDICATED) {
+		if (p_eng->run.tm_tx_only)
+			setup_arp(p_eng);
+		
+		p_eng->dat.FRAME_LEN =
+		    (uint32_t *)malloc(p_eng->dat.Des_Num * sizeof(uint32_t));
+		p_eng->dat.wp_lst =
+		    (uint32_t *)malloc(p_eng->dat.Des_Num * sizeof(uint32_t));
+
+		if (!p_eng->dat.FRAME_LEN)
+			return (finish_check(p_eng, Err_Flag_MALLOC_FrmSize));
+		if (!p_eng->dat.wp_lst)
+			return (finish_check(p_eng, Err_Flag_MALLOC_LastWP));
+
+		TestingSetup(p_eng);
+	} else {
+		if (p_eng->arg.GARPNumCnt != 0)
+			setup_arp(p_eng);
+	}
+
+	p_eng->run.speed_idx = 0;
+	p_eng->io.drv_curr = mac_get_driving_strength(p_eng);
+	if (mac_set_scan_boundary(p_eng))
+		return (finish_check(p_eng, 0));
+
+	return 0;			
+}
+
+static uint32_t get_time_out_th(MAC_ENGINE *p_eng)
+{
+	uint32_t time_out = 0;	
+
+	time_out = timeout_th_tbl[p_eng->run.speed_idx];
+	if (p_eng->run.TM_WaitStart)
+		time_out = time_out * 10000;
+	
+	return time_out;		
+}
+uint32_t test_start(MAC_ENGINE *p_eng, PHY_ENGINE *p_phy_eng)
+{
+	uint32_t drv = 0, speed = 0;
+	int td = 0, rd = 0, tbegin = 0, rbegin = 0, tend = 0, rend = 0;
+	int tstep = 0, rstep = 0;
+
+	uint32_t wrn_flag_allspeed = 0;
+	uint32_t err_flag_allspeed = 0;
+	uint32_t des_flag_allspeed = 0;
+	uint32_t ncsi_flag_allspeed = 0;
+
+	memset(&p_eng->io.result_history[0][0], 0,
+	       sizeof(p_eng->io.result_history));
+
+	for (speed = 0; speed < 3; speed++) {
+		p_eng->flg.print_en = 1;
+		p_eng->run.speed_idx = speed;
+		mac_set_scan_boundary(p_eng);
+		if (0 == p_eng->run.speed_sel[speed]) {
+			continue;
+		}
+
+		p_eng->run.timeout_th = get_time_out_th(p_eng);
+		if (p_eng->arg.run_mode == MODE_DEDICATED) {
+			if ((p_eng->arg.run_speed == SET_1G_100M_10MBPS) ||
+			    (p_eng->arg.run_speed == SET_100M_10MBPS)) {
+				if (p_eng->run.speed_sel[0])
+					p_eng->run.loop_max =
+					    p_eng->arg.loop_max;
+				else if (p_eng->run.speed_sel[1])
+					p_eng->run.loop_max =
+					    p_eng->arg.loop_max / 100;
+				else
+					p_eng->run.loop_max =
+					    p_eng->arg.loop_max / 1000;
+
+				if (0 == p_eng->run.loop_max)
+					p_eng->run.loop_max = 1;
+
+				calc_loop_check_num(p_eng);
+			}
+			//------------------------------
+			// PHY Initial
+			//------------------------------
+			if (p_phy_eng->fp_set) {
+				init_phy(p_eng, p_phy_eng);
+			}
+
+			if (p_eng->flg.error)
+				return (finish_check(p_eng, 0));
+		}
+
+		//------------------------------
+		// [Start] The loop of different IO strength
+		//------------------------------
+		debug("drirving scan range: %d ~ %d\n",
+		       p_eng->io.drv_lower_bond, p_eng->io.drv_upper_bond);
+		for (drv = p_eng->io.drv_lower_bond;
+		     drv <= p_eng->io.drv_upper_bond; drv++) {
+			if (p_eng->run.IO_MrgChk) {
+				if (p_eng->run.TM_IOStrength) {
+					mac_set_driving_strength(p_eng, drv);
+					p_eng->io.drv_curr = mac_get_driving_strength(p_eng);
+				}
+
+				if (p_eng->run.delay_margin)
+					PrintIO_Header(p_eng, FP_LOG);
+				if (p_eng->run.TM_IOTiming)
+					PrintIO_Header(p_eng, FP_IO);
+				PrintIO_Header(p_eng, STD_OUT);
+			} else {
+				if (p_eng->arg.run_mode == MODE_DEDICATED) {
+					Print_Header(p_eng, STD_OUT);
+				}
+			} // End if (p_eng->run.IO_MrgChk)
+
+			//------------------------------
+			// [Start] The loop of different IO out delay
+			//------------------------------
+			tbegin = p_eng->io.tx_delay_scan.begin;
+			tend = p_eng->io.tx_delay_scan.end;
+			tstep = p_eng->io.tx_delay_scan.step;
+
+			rbegin = p_eng->io.rx_delay_scan.begin;
+			rend = p_eng->io.rx_delay_scan.end;
+			rstep = p_eng->io.rx_delay_scan.step;
+
+			for (td = tbegin; td <= tend; td += tstep) {
+				p_eng->io.Dly_out = td;
+				p_eng->io.Dly_out_selval = td;
+				if (p_eng->run.IO_MrgChk) {
+					PrintIO_LineS(p_eng, STD_OUT);
+				} // End if (p_eng->run.IO_MrgChk)
+
+				//------------------------------
+				// [Start] The loop of different IO in
+				// delay
+				//------------------------------
+				for (rd = rbegin; rd <= rend; rd += rstep) {
+					p_eng->io.Dly_in = rd;
+					if (p_eng->run.IO_MrgChk) {
+						p_eng->io.Dly_in_selval = rd;
+						scu_disable_mac(p_eng);
+						mac_set_delay(p_eng, rd, td);
+						scu_enable_mac(p_eng);
+					}
+					//------------------------------
+					// MAC Initial
+					//------------------------------
+					init_mac(p_eng);
+					if (p_eng->flg.error)
+						return (finish_check(p_eng, 0));
+
+					if (p_eng->arg.run_mode == MODE_NCSI) {
+						p_eng->io.result =
+						    phy_ncsi(p_eng);
+					} else {
+						p_eng->io.result = TestingLoop(
+						    p_eng,
+						    p_eng->run.LOOP_CheckNum);
+					}
+
+					p_eng->io.result_history[rd + 64][td] |=
+					    p_eng->io.result;
+
+					/* Display to Log file and monitor */
+					if (p_eng->run.IO_MrgChk) {
+						PrintIO_Line(p_eng, STD_OUT);
+
+						FPri_ErrFlag(p_eng, FP_LOG);
+
+						p_eng->flg.warn = 0;
+						p_eng->flg.error = 0;
+						p_eng->flg.desc = 0;
+						p_eng->flg.ncsi = 0;
+					}
+				}
+
+				if (p_eng->run.IO_MrgChk) {
+					if (p_eng->run.TM_IOTiming) {
+						PRINTF(FP_IO, "\n");
+					}
+					printf("\n");
+				}
+			}
+
+			if (!p_eng->run.tm_tx_only)
+				FPri_ErrFlag(p_eng, FP_LOG);
+			if (p_eng->run.TM_IOTiming)
+				FPri_ErrFlag(p_eng, FP_IO);
+
+			FPri_ErrFlag(p_eng, STD_OUT);
+
+			wrn_flag_allspeed |= p_eng->flg.warn;
+			err_flag_allspeed |= p_eng->flg.error;
+			des_flag_allspeed |= p_eng->flg.error;
+			ncsi_flag_allspeed |= p_eng->flg.error;
+			p_eng->flg.warn = 0;
+			p_eng->flg.error = 0;
+			p_eng->flg.desc = 0;
+			p_eng->flg.ncsi = 0;
+		}
+
+		if (p_eng->arg.run_mode == MODE_DEDICATED) {
+			if (p_phy_eng->fp_clr != 0)
+				recov_phy(p_eng, p_phy_eng);
+		}
+
+		p_eng->run.speed_sel[speed] = 0;
+		p_eng->flg.print_en = 0;
+	} // End for (speed = 0; speed < 3; speed++)
+
+	p_eng->flg.warn = wrn_flag_allspeed;
+	p_eng->flg.error = err_flag_allspeed;
+	p_eng->flg.desc = des_flag_allspeed;
+	p_eng->flg.ncsi = ncsi_flag_allspeed;
+
+	return (finish_check(p_eng, 0));
+}
+static uint32_t ring_clk(uint32_t reg_offset, uint32_t clk_sel)
+{
+	uint32_t freq;
+
+	SCU_WR(0, reg_offset);
+	SCU_WR((0xf << 2) | BIT(0), reg_offset);
+	udelay(1000);
+	SCU_WR((clk_sel << 2) | BIT(1) | BIT(0), reg_offset);
+	while ((SCU_RD(reg_offset) & BIT(6)) == 0);
+
+	freq = (SCU_RD(reg_offset) & GENMASK(29, 16)) >> 16;
+	SCU_WR(0, reg_offset);
+	return ((freq + 1) * 48828);
+}
+
+void dump_setting(MAC_ENGINE *p_eng)
+{
+	/* dump env */
+	printf("===================\n");
+	printf("ast2600 compatible = %d\n", p_eng->env.ast2600);
+	printf("ast2500 compatible = %d\n", p_eng->env.ast2500);
+	printf("valid MAC number = %d\n", p_eng->env.mac_num);
+	printf("use new MDIO register = %d %d %d %d\n",
+	       p_eng->env.is_new_mdio_reg[0],
+	       p_eng->env.is_new_mdio_reg[1],
+	       p_eng->env.is_new_mdio_reg[2],
+	       p_eng->env.is_new_mdio_reg[3]);
+	printf("1G compatible = %d %d %d %d\n",
+	       p_eng->env.is_1g_valid[0],
+	       p_eng->env.is_1g_valid[1],
+	       p_eng->env.is_1g_valid[2],
+	       p_eng->env.is_1g_valid[3]);	
+	printf("===================\n");
+
+
+	printf("RGMIICK of MAC1/2 = %d Hz\n", ring_clk(0x320, 0xf));
+	printf("RGMIICK of MAC3/4 = %d Hz\n", ring_clk(0x330, 0x9));
+	printf("EPLL              = %d Hz\n", ring_clk(0x320, 0x5) * 4);
+	printf("HCLK              = %d Hz\n", ring_clk(0x330, 0x1));
+
+}
+/**
+ * @brief nettest main function
+*/
+int main_function (int argc, char * const argv[], uint32_t mode)
+{
+	MAC_ENGINE mac_eng;
+	PHY_ENGINE phy_eng;
+	uint32_t ret;
+
+	ret = init_mac_engine(&mac_eng, mode);
+	if (ret) {
+		printf("init MAC engine fail\n");
+		return ret;
+	}
+	
+	if (argc <= 1) {
+		print_usage(&mac_eng);
+		return 1;
+	}
+
+	mac_eng.arg.mac_idx = simple_strtol(argv[1], NULL, 16);
+
+	/* default mdio_idx = mac_idx */
+	mac_eng.arg.mdio_idx = mac_eng.arg.mac_idx;
+	if (MODE_DEDICATED == mode)
+		parse_arg_dedicated(argc, argv, &mac_eng);
+	else		
+		parse_arg_ncsi(argc, argv, &mac_eng);
+
+	ret = setup_running(&mac_eng); 
+	if (ret)
+		return 1;
+
+	dump_setting(&mac_eng);
+
+	/* init PHY engine */
+	phy_eng.fp_set = NULL;
+	phy_eng.fp_clr = NULL;
+
+	if (mac_eng.arg.ctrl.b.rmii_50m_out && 0 == mac_eng.run.is_rgmii) {
+		mac_set_rmii_50m_output_enable(&mac_eng);
+	}
+
+	push_reg(&mac_eng);
+	disable_wdt(&mac_eng);
+
+	mac_set_addr(&mac_eng);
+	if (mac_eng.arg.ctrl.b.mac_int_loopback)
+		mac_set_interal_loopback(&mac_eng);
+
+	scu_set_pinmux(&mac_eng);
+
+	scu_disable_mac(&mac_eng);
+	scu_enable_mac(&mac_eng);
+	if (mac_eng.arg.run_mode == MODE_DEDICATED) {
+		if (1 == phy_find_addr(&mac_eng)) {
+			phy_select(&mac_eng, &phy_eng);		
+		}
+	}
+
+	/* Data Initial */
+	setup_data(&mac_eng);
+
+	mac_eng.flg.all_fail = 1;
+	mac_eng.io.init_done = 1;
+	for(int i = 0; i < 3; i++)
+		mac_eng.run.speed_sel[i] = mac_eng.run.speed_cfg[i];
+
+	//------------------------------
+	// [Start] The loop of different speed
+	//------------------------------
+	print_legend();
+	test_start(&mac_eng, &phy_eng);
+
+	return 0;
+}
diff -Naur uboot/oem/ami/standalone/nettest/Makefile uboot-new/oem/ami/standalone/nettest/Makefile
--- uboot/oem/ami/standalone/nettest/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/Makefile	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,82 @@
+#
+# (C) Copyright 2020
+# American Megatrends Inc
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+extra-y        := nettest
+#
+# Some versions of make do not handle trailing white spaces properly;
+# leading to build failures. The problem was found with GNU Make 3.80.
+# Using 'strip' as a workaround for the problem.
+#
+ELF := $(strip $(extra-y))
+
+extra-y += $(addsuffix .srec,$(extra-y)) $(addsuffix .bin,$(extra-y))
+clean-files  := *.srec *.bin
+
+COBJS	:= $(ELF:=.o) 
+
+LIB	= $(obj)/libstubs.o
+
+LIBOBJS-y += stdalone.o stress.o mactest.o mem_io.o mac.o ncsi.o phy.o stduboot.o
+LIBOBJS-y += stubs.o
+
+targets += $(patsubst $(obj)/%,%,$(LIB)) $(COBJS) $(LIBOBJS-y) 
+
+LIBOBJS	:= $(addprefix $(obj)/,$(LIBOBJS-y))
+ELF	:= $(addprefix $(obj)/,$(ELF))
+
+# We don't want gcc reordering functions if possible.  This ensures that an
+# application's entry point will be the first function in the application's
+# source file.
+ccflags-y += $(call cc-option,-fno-toplevel-reorder)
+
+LDFLAGS_STANDALONE	+= -Ttext $(CONFIG_STANDALONE_LOAD_ADDR)
+
+#########################################################################
+
+quiet_cmd_link_lib = LD      $@
+      cmd_link_lib = $(LD) $(ld_flags) -r -o $@ $(filter $(LIBOBJS), $^)
+
+$(LIB):	$(LIBOBJS) FORCE
+	$(call if_changed,link_lib)
+
+quiet_cmd_link_elf = LD      $@
+      cmd_link_elf = $(LD) $(LDFLAGS) $(LDFLAGS_STANDALONE) -g  \
+		     -o $@ -e $(SYM_PREFIX)$(@F) $< $(LIB) $(PLATFORM_LIBGCC)
+
+$(ELF): $(obj)/%: $(obj)/%.o $(LIB) FORCE
+	$(call if_changed,link_elf)
+
+$(obj)/%.srec: OBJCOPYFLAGS += -O srec
+$(obj)/%.srec: $(obj)/% FORCE
+	$(call if_changed,objcopy)
+
+$(obj)/%.bin: OBJCOPYFLAGS += -O binary
+$(obj)/%.bin: $(obj)/% FORCE
+	$(call if_changed,objcopy)
+
+# some files can only build in ARM or THUMB2, not THUMB1
+
+ifdef CONFIG_SYS_THUMB_BUILD
+ifndef CONFIG_HAS_THUMB2
+
+CFLAGS_stubs.o := -marm
+
+endif
+endif
diff -Naur uboot/oem/ami/standalone/nettest/mem_io.c uboot-new/oem/ami/standalone/nettest/mem_io.c
--- uboot/oem/ami/standalone/nettest/mem_io.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/mem_io.c	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,9 @@
+#include <asm/arch/platform.h>
+#include "mem_io.h"
+/*
+ * @fn SRAM_RD
+ */
+uint32_t SRAM_RD(uint32_t addr)
+{
+	return readl(ASPEED_SRAM_BASE + addr);
+}
diff -Naur uboot/oem/ami/standalone/nettest/mem_io.h uboot-new/oem/ami/standalone/nettest/mem_io.h
--- uboot/oem/ami/standalone/nettest/mem_io.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/mem_io.h	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,78 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MEM_IO_H
+#define MEM_IO_H
+
+//#include "io.h"
+#include <asm/io.h>
+
+#define MAC1_BASE	0x1e660000
+#define MAC2_BASE	0x1e680000
+#define MDIO0_BASE	(MAC1_BASE + 0x60)
+#define MDIO1_BASE	(MAC2_BASE + 0x60)
+#define SCU_BASE        0x1e6e2000
+
+#ifdef CONFIG_ASPEED_AST2600
+#define MAC3_BASE	0x1e670000
+#define MAC4_BASE	0x1e690000
+
+#define PMI_BASE	0x1e650000
+#undef MDIO0_BASE
+#undef MDIO1_BASE
+#define MDIO0_BASE	(PMI_BASE + 0x00)
+#define MDIO1_BASE	(PMI_BASE + 0x08)
+#define MDIO2_BASE	(PMI_BASE + 0x10)
+#define MDIO3_BASE	(PMI_BASE + 0x18)
+#endif
+
+#define GPIO_BASE	0x1e780000
+
+/* macros for register access */
+#define SCU_RD(offset)          readl(SCU_BASE + offset)
+#define SCU_WR(value, offset)   writel(value, SCU_BASE + offset)
+
+#define MAC1_RD(offset)		readl(MAC1_BASE + offset)
+#define MAC1_WR(value, offset)	writel(value, MAC1_BASE + offset)
+#define MAC2_RD(offset)		readl(MAC2_BASE + offset)
+#define MAC2_WR(value, offset)	writel(value, MAC2_BASE + offset)
+#ifdef CONFIG_ASPEED_AST2600
+#define MAC3_RD(offset)		readl(MAC3_BASE + offset)
+#define MAC3_WR(value, offset)	writel(value, MAC3_BASE + offset)
+#define MAC4_RD(offset)		readl(MAC4_BASE + offset)
+#define MAC4_WR(value, offset)	writel(value, MAC4_BASE + offset)
+#endif
+
+#define GPIO_RD(offset)		readl(GPIO_BASE + offset)
+#define GPIO_WR(value, offset)	writel(value, GPIO_BASE + offset)
+/* typedef for register access */
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t reserved_0 : 6;	/* bit[5:0] */
+		uint32_t mac1_interface : 1;	/* bit[6] */
+		uint32_t mac2_interface : 1;	/* bit[7] */
+		uint32_t reserved_1 : 24;	/* bit[31:8] */
+	}b;
+} hw_strap1_t;
+
+typedef union {
+	uint32_t w;
+	struct {
+		uint32_t mac3_interface : 1;	/* bit[0] */
+		uint32_t mac4_interface : 1;	/* bit[1] */		
+		uint32_t reserved_0 : 30;	/* bit[31:2] */
+	}b;
+} hw_strap2_t;
+
+uint32_t SRAM_RD(uint32_t addr);
+
+#endif
diff -Naur uboot/oem/ami/standalone/nettest/ncsi.c uboot-new/oem/ami/standalone/nettest/ncsi.c
--- uboot/oem/ami/standalone/nettest/ncsi.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/ncsi.c	2020-11-20 04:00:27.000000000 -0500
@@ -0,0 +1,988 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define NCSI_C
+
+#include "swfunc.h"
+
+#include "comminf.h"
+//#include "io.h"
+#include "ncsi.h"
+#include <command.h>
+#include <common.h>
+#include "mac_api.h"
+
+//------------------------------------------------------------
+int ncsi_set_error_flag(MAC_ENGINE *eng, int eflag)
+{
+	eng->flg.ncsi = eng->flg.ncsi | eflag;
+	eng->flg.error = eng->flg.error | ERR_FLAG_NCSI_LINKFAIL;
+	if (DBG_PRINT_ERR_FLAG)
+		printf("\nflags: error = %08x, ncsi = %08x\n",
+		       eng->flg.error, eng->flg.ncsi);
+
+	return (1);
+}
+
+//------------------------------------------------------------
+// PHY IC(NC-SI)
+//------------------------------------------------------------
+void ncsi_reqdump(MAC_ENGINE *eng, NCSI_Command_Packet *in)
+{
+	int     i;
+	PRINTF( FP_LOG, "[NCSI-Request] DA             : %02x %02x %02x %02x %02x %02x\n", in->DA[ 0 ], in->DA[ 1 ], in->DA[ 2 ], in->DA[ 3 ], in->DA[ 4 ] , in->DA[ 5 ]);
+	PRINTF( FP_LOG, "[NCSI-Request] SA             : %02x %02x %02x %02x %02x %02x\n", in->SA[ 0 ], in->SA[ 1 ], in->SA[ 2 ], in->SA[ 3 ], in->SA[ 4 ] , in->SA[ 5 ]);
+	PRINTF( FP_LOG, "[NCSI-Request] EtherType      : %04x\n", SWAP_2B_BEDN( in->EtherType )             );//DMTF NC-SI
+	PRINTF( FP_LOG, "[NCSI-Request] MC_ID          : %02x\n", in->MC_ID                                 );//Management Controller should set this field to 0x00
+	PRINTF( FP_LOG, "[NCSI-Request] Header_Revision: %02x\n", in->Header_Revision                       );//For NC-SI 1.0 spec, this field has to set 0x01
+//	PRINTF( FP_LOG, "[NCSI-Request] Reserved_1     : %02x\n", in->Reserved_1                            ); //Reserved has to set to 0x00
+	PRINTF( FP_LOG, "[NCSI-Request] IID            : %02x\n", in->IID                                   );//Instance ID
+	PRINTF( FP_LOG, "[NCSI-Request] Command        : %02x\n", in->Command                               );
+	PRINTF( FP_LOG, "[NCSI-Request] ChID           : %02x\n", in->ChID                                  );
+	PRINTF( FP_LOG, "[NCSI-Request] Payload_Length : %04x\n", SWAP_2B_BEDN( in->Payload_Length )        );//Payload Length = 12 bits, 4 bits are reserved
+//	PRINTF( FP_LOG, "[NCSI-Request] Reserved_2     : %04x\n", in->Reserved_2                            );
+//	PRINTF( FP_LOG, "[NCSI-Request] Reserved_3     : %04x\n", in->Reserved_3                            );
+//	PRINTF( FP_LOG, "[NCSI-Request] Reserved_4     : %04x\n", in->Reserved_4                            );
+//	PRINTF( FP_LOG, "[NCSI-Request] Reserved_5     : %04x\n", in->Reserved_5                            );
+	PRINTF( FP_LOG, "[NCSI-Request] Response_Code  : %04x\n", SWAP_2B_BEDN( in->Response_Code )         );
+	PRINTF( FP_LOG, "[NCSI-Request] Reason_Code    : %04x\n", SWAP_2B_BEDN( in->Reason_Code )           );
+	for ( i = 0; i < SWAP_2B_BEDN( in->Payload_Length ); i++ ) {
+		switch ( i % 4 ) {
+			case 0	: PRINTF( FP_LOG, "[NCSI-Request] Payload_Data   : %02x", in->Payload_Data[ i ]); break;
+			case 3	: PRINTF( FP_LOG, " %02x\n", in->Payload_Data[ i ]); break;
+			default	: PRINTF( FP_LOG, " %02x", in->Payload_Data[ i ]); break;
+		}
+	}
+	if ( ( i % 4 ) != 3 )
+		PRINTF( FP_LOG, "\n");
+}
+void ncsi_respdump (MAC_ENGINE *eng, NCSI_Response_Packet *in) {
+	int     i;
+//	PRINTF( FP_LOG, "[NCSI-Respond] DA             : %02x %02x %02x %02x %02x %02x\n", in->DA[ 5 ], in->DA[ 4 ], in->DA[ 3 ], in->DA[ 2 ], in->DA[ 1] , in->DA[ 0 ]);
+//	PRINTF( FP_LOG, "[NCSI-Respond] SA             : %02x %02x %02x %02x %02x %02x\n", in->SA[ 5 ], in->SA[ 4 ], in->SA[ 3 ], in->SA[ 2 ], in->SA[ 1] , in->SA[ 0 ]);
+	PRINTF( FP_LOG, "[NCSI-Respond] DA             : %02x %02x %02x %02x %02x %02x\n", in->DA[ 0 ], in->DA[ 1 ], in->DA[ 2 ], in->DA[ 3 ], in->DA[ 4 ] , in->DA[ 5 ]);
+	PRINTF( FP_LOG, "[NCSI-Respond] SA             : %02x %02x %02x %02x %02x %02x\n", in->SA[ 0 ], in->SA[ 1 ], in->SA[ 2 ], in->SA[ 3 ], in->SA[ 4 ] , in->SA[ 5 ]);
+	PRINTF( FP_LOG, "[NCSI-Respond] EtherType      : %04x\n", SWAP_2B_BEDN( in->EtherType )             );//DMTF NC-SI
+	PRINTF( FP_LOG, "[NCSI-Respond] MC_ID          : %02x\n", in->MC_ID                                 );//Management Controller should set this field to 0x00
+	PRINTF( FP_LOG, "[NCSI-Respond] Header_Revision: %02x\n", in->Header_Revision                       );//For NC-SI 1.0 spec, this field has to set 0x01
+//	PRINTF( FP_LOG, "[NCSI-Respond] Reserved_1     : %02x\n", in->Reserved_1                            ); //Reserved has to set to 0x00
+	PRINTF( FP_LOG, "[NCSI-Respond] IID            : %02x\n", in->IID                                   );//Instance ID
+	PRINTF( FP_LOG, "[NCSI-Respond] Command        : %02x\n", in->Command                               );
+	PRINTF( FP_LOG, "[NCSI-Respond] ChID           : %02x\n", in->ChID                                  );
+	PRINTF( FP_LOG, "[NCSI-Respond] Payload_Length : %04x\n", SWAP_2B_BEDN( in->Payload_Length )        );//Payload Length = 12 bits, 4 bits are reserved
+//	PRINTF( FP_LOG, "[NCSI-Respond] Reserved_2     : %04x\n", in->Reserved_2                            );
+//	PRINTF( FP_LOG, "[NCSI-Respond] Reserved_3     : %04x\n", in->Reserved_3                            );
+//	PRINTF( FP_LOG, "[NCSI-Respond] Reserved_4     : %04x\n", in->Reserved_4                            );
+//	PRINTF( FP_LOG, "[NCSI-Respond] Reserved_5     : %04x\n", in->Reserved_5                            );
+	PRINTF( FP_LOG, "[NCSI-Respond] Response_Code  : %04x\n", SWAP_2B_BEDN( in->Response_Code )         );
+	PRINTF( FP_LOG, "[NCSI-Respond] Reason_Code    : %04x\n", SWAP_2B_BEDN( in->Reason_Code )           );
+	for ( i = 0; i < SWAP_2B_BEDN( in->Payload_Length ); i++ ) {
+		switch ( i % 4 ) {
+			case 0	: PRINTF( FP_LOG, "[NCSI-Respond] Payload_Data   : %02x", in->Payload_Data[ i ]); break;
+			case 3	: PRINTF( FP_LOG, " %02x\n", in->Payload_Data[ i ]); break;
+			default	: PRINTF( FP_LOG, " %02x", in->Payload_Data[ i ]); break;
+		}
+	}
+	if ( ( i % 4 ) != 3 )
+		PRINTF( FP_LOG, "\n");
+}
+
+//------------------------------------------------------------
+void NCSI_PrintCommandStr (MAC_ENGINE *eng, unsigned char command, unsigned iid) {
+	switch ( command & 0x80 ) {
+		case 0x80   : sprintf(eng->dat.NCSI_CommandStr, "IID:%3d [%02x:Respond]", iid, command); break;
+		default     : sprintf(eng->dat.NCSI_CommandStr, "IID:%3d [%02x:Request]", iid, command); break;
+	}
+	switch ( command & 0x7f ) {
+		case 0x00   : sprintf(eng->dat.NCSI_CommandStr, "%s[CLEAR_INITIAL_STATE                ]", eng->dat.NCSI_CommandStr); break;
+		case 0x01   : sprintf(eng->dat.NCSI_CommandStr, "%s[SELECT_PACKAGE                     ]", eng->dat.NCSI_CommandStr); break;
+		case 0x02   : sprintf(eng->dat.NCSI_CommandStr, "%s[DESELECT_PACKAGE                   ]", eng->dat.NCSI_CommandStr); break;
+		case 0x03   : sprintf(eng->dat.NCSI_CommandStr, "%s[ENABLE_CHANNEL                     ]", eng->dat.NCSI_CommandStr); break;
+		case 0x04   : sprintf(eng->dat.NCSI_CommandStr, "%s[DISABLE_CHANNEL                    ]", eng->dat.NCSI_CommandStr); break;
+		case 0x05   : sprintf(eng->dat.NCSI_CommandStr, "%s[RESET_CHANNEL                      ]", eng->dat.NCSI_CommandStr); break;
+		case 0x06   : sprintf(eng->dat.NCSI_CommandStr, "%s[ENABLE_CHANNEL_NETWORK_TX          ]", eng->dat.NCSI_CommandStr); break;
+		case 0x07   : sprintf(eng->dat.NCSI_CommandStr, "%s[DISABLE_CHANNEL_NETWORK_TX         ]", eng->dat.NCSI_CommandStr); break;
+		case 0x08   : sprintf(eng->dat.NCSI_CommandStr, "%s[AEN_ENABLE                         ]", eng->dat.NCSI_CommandStr); break;
+		case 0x09   : sprintf(eng->dat.NCSI_CommandStr, "%s[SET_LINK                           ]", eng->dat.NCSI_CommandStr); break;
+		case 0x0A   : sprintf(eng->dat.NCSI_CommandStr, "%s[GET_LINK_STATUS                    ]", eng->dat.NCSI_CommandStr); break;
+		case 0x0B   : sprintf(eng->dat.NCSI_CommandStr, "%s[SET_VLAN_FILTER                    ]", eng->dat.NCSI_CommandStr); break;
+		case 0x0C   : sprintf(eng->dat.NCSI_CommandStr, "%s[ENABLE_VLAN                        ]", eng->dat.NCSI_CommandStr); break;
+		case 0x0D   : sprintf(eng->dat.NCSI_CommandStr, "%s[DISABLE_VLAN                       ]", eng->dat.NCSI_CommandStr); break;
+		case 0x0E   : sprintf(eng->dat.NCSI_CommandStr, "%s[SET_MAC_ADDRESS                    ]", eng->dat.NCSI_CommandStr); break;
+		case 0x10   : sprintf(eng->dat.NCSI_CommandStr, "%s[ENABLE_BROADCAST_FILTERING         ]", eng->dat.NCSI_CommandStr); break;
+		case 0x11   : sprintf(eng->dat.NCSI_CommandStr, "%s[DISABLE_BROADCAST_FILTERING        ]", eng->dat.NCSI_CommandStr); break;
+		case 0x12   : sprintf(eng->dat.NCSI_CommandStr, "%s[ENABLE_GLOBAL_MULTICAST_FILTERING  ]", eng->dat.NCSI_CommandStr); break;
+		case 0x13   : sprintf(eng->dat.NCSI_CommandStr, "%s[DISABLE_GLOBAL_MULTICAST_FILTERING ]", eng->dat.NCSI_CommandStr); break;
+		case 0x14   : sprintf(eng->dat.NCSI_CommandStr, "%s[SET_NCSI_FLOW_CONTROL              ]", eng->dat.NCSI_CommandStr); break;
+		case 0x15   : sprintf(eng->dat.NCSI_CommandStr, "%s[GET_VERSION_ID                     ]", eng->dat.NCSI_CommandStr); break;
+		case 0x16   : sprintf(eng->dat.NCSI_CommandStr, "%s[GET_CAPABILITIES                   ]", eng->dat.NCSI_CommandStr); break;
+		case 0x17   : sprintf(eng->dat.NCSI_CommandStr, "%s[GET_PARAMETERS                     ]", eng->dat.NCSI_CommandStr); break;
+		case 0x18   : sprintf(eng->dat.NCSI_CommandStr, "%s[GET_CONTROLLER_PACKET_STATISTICS   ]", eng->dat.NCSI_CommandStr); break;
+		case 0x19   : sprintf(eng->dat.NCSI_CommandStr, "%s[GET_NCSI_STATISTICS                ]", eng->dat.NCSI_CommandStr); break;
+		case 0x1A   : sprintf(eng->dat.NCSI_CommandStr, "%s[GET_NCSI_PASS_THROUGH_STATISTICS   ]", eng->dat.NCSI_CommandStr); break;
+		case 0x50   : sprintf(eng->dat.NCSI_CommandStr, "%s[OEM_COMMAND                        ]", eng->dat.NCSI_CommandStr); break;
+		default     : sprintf(eng->dat.NCSI_CommandStr, "%s Not Support Command", eng->dat.NCSI_CommandStr); break ;
+	}
+} // End void NCSI_PrintCommandStr (MAC_ENGINE *eng, unsigned char command, unsigned iid)
+
+//------------------------------------------------------------
+void NCSI_PrintCommandType (MAC_ENGINE *eng, unsigned char command, unsigned iid) {
+	NCSI_PrintCommandStr( eng, command, iid );
+	printf("[NCSI-commd]%s\n", eng->dat.NCSI_CommandStr);
+}
+
+//------------------------------------------------------------
+void NCSI_PrintCommandType2File (MAC_ENGINE *eng, unsigned char command, unsigned iid) {
+	NCSI_PrintCommandStr( eng, command, iid );
+	PRINTF( FP_LOG, "[NCSI-commd]%s\n", eng->dat.NCSI_CommandStr );
+}
+
+//------------------------------------------------------------
+void NCSI_Struct_Initialize_SLT (MAC_ENGINE *eng)
+{
+	int i;
+	uint32_t NCSI_RxDatBase;
+
+	eng->run.NCSI_RxTimeOutScale = 1;
+
+	for (i = 0; i < 6; i++) {
+		eng->ncsi_req.DA[i] = 0xFF;
+		eng->ncsi_req.SA[i] = eng->inf.SA[i];
+	}
+
+	/* EtherType = 0x88F8 (DMTF DSP0222 NC-SI spec)
+	ethernet frame header format, table 8 */
+	eng->ncsi_req.EtherType = SWAP_2B_BEDN(0x88F8);
+
+	eng->ncsi_req.MC_ID           = 0;
+	eng->ncsi_req.Header_Revision = 0x01;
+	eng->ncsi_req.Reserved_1      = 0;
+	eng->ncsi_req.IID             = 0;
+//	eng->ncsi_req.Command         = 0;
+//	eng->ncsi_req.ChID            = 0;
+//	eng->ncsi_req.Payload_Length  = 0;
+
+	eng->ncsi_req.Response_Code   = 0;
+	eng->ncsi_req.Reason_Code     = 0;
+	eng->ncsi_req.Reserved_2      = 0;
+	eng->ncsi_req.Reserved_3      = 0;
+
+	eng->dat.NCSI_TxByteBUF = (unsigned char *) &eng->dat.NCSI_TxDWBUF[0];
+	eng->dat.NCSI_RxByteBUF = (unsigned char *) &eng->dat.NCSI_RxDWBUF[0];
+
+	eng->run.ncsi_tdes_base = eng->run.tdes_base;//base for read/write
+	Write_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base + 0x04, 0                        );
+	Write_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base + 0x08, 0                        );
+	Write_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base + 0x0C, DMA_BASE - ASPEED_DRAM_BASE);
+
+	eng->run.ncsi_rdes_base = eng->run.rdes_base;//base for read/write
+	NCSI_RxDatBase = AT_MEMRW_BUF( NCSI_RxDMA_BASE );//base of the descriptor
+
+	for (i = 0; i < NCSI_RxDESNum - 1; i++) {
+		Write_Mem_Des_NCSI_DD( ( eng->run.ncsi_rdes_base        ), 0x00000000     );
+		Write_Mem_Des_NCSI_DD( ( eng->run.ncsi_rdes_base + 0x04 ), 0x00000000     );
+		Write_Mem_Des_NCSI_DD( ( eng->run.ncsi_rdes_base + 0x08 ), 0x00000000     );
+		Write_Mem_Des_NCSI_DD( ( eng->run.ncsi_rdes_base + 0x0C ), NCSI_RxDatBase );
+		eng->run.ncsi_rdes_base += 16;
+		NCSI_RxDatBase += NCSI_RxDMA_PakSize;
+	}
+	Write_Mem_Des_NCSI_DD( ( eng->run.ncsi_rdes_base        ), EOR_IniVal     );
+	Write_Mem_Des_NCSI_DD( ( eng->run.ncsi_rdes_base + 0x04 ), 0x00000000     );
+	Write_Mem_Des_NCSI_DD( ( eng->run.ncsi_rdes_base + 0x08 ), 0x00000000     );
+//	Write_Mem_Des_NCSI_DD( ( eng->run.ncsi_rdes_base + 0x0C ), (NCSI_RxDatBase + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+	Write_Mem_Des_NCSI_DD( ( eng->run.ncsi_rdes_base + 0x0C ), NCSI_RxDatBase ); // 20130730
+
+	eng->run.ncsi_rdes_base = eng->run.rdes_base;//base for read/write
+}
+
+//------------------------------------------------------------
+void Calculate_Checksum_NCSI (MAC_ENGINE *eng, unsigned char *buffer_base, int Length) {
+	uint32_t      CheckSum = 0;
+	uint32_t      Data;
+	uint32_t      Data1;
+	int        i;
+
+	// Calculate checksum is from byte 14 of ethernet Haeder and Control packet header
+	// Page 50, NC-SI spec. ver. 1.0.0 form DMTF
+	for (i = 14; i < Length; i += 2 ) {
+		Data      = buffer_base[i];
+		Data1     = buffer_base[i + 1];
+		CheckSum += ((Data << 8) + Data1);
+	}
+	eng->dat.Payload_Checksum_NCSI = SWAP_4B_BEDN(~(CheckSum) + 1); //2's complement
+}
+
+/**
+ * @brief	check error mask in RX descriptor
+ * @param	rx_desc0	RX descript[0]
+*/
+static int check_rx_desc_err(MAC_ENGINE *p_eng, uint32_t rx_desc0)
+{
+	uint8_t prefix[8] = "[RxDes]";
+
+	if (rx_desc0 & RXDES_EM_ALL) {
+#ifdef CheckRxErr
+		if (rx_desc0 & RXDES_EM_RXERR) {
+			PRINTF(STD_OUT, "%s Error RxErr        %08x\n", prefix,
+			       rx_desc0);
+			p_eng->dat.NCSI_RxEr = 1;
+		}
+#endif
+
+#ifdef CheckCRC
+		if (rx_desc0 & RXDES_EM_CRC) {
+			PRINTF(STD_OUT, "%s Error CRC          %08x\n", prefix,
+			       rx_desc0);
+			FindErr_Des(p_eng, Des_Flag_CRC);
+		}
+#endif
+
+#ifdef CheckFTL
+		if (rx_desc0 & RXDES_EM_FTL) {
+			PRINTF(STD_OUT, "%s Error FTL          %08x\n", prefix,
+			       rx_desc0);
+			FindErr_Des(p_eng, Des_Flag_FTL);
+		}
+#endif
+
+#ifdef CheckRunt
+		if (rx_desc0 & RXDES_EM_RUNT) {
+			PRINTF(STD_OUT, "%s Error Runt         %08x\n", prefix,
+			       rx_desc0);
+			FindErr_Des(p_eng, Des_Flag_Runt);
+		}
+#endif
+
+#ifdef CheckOddNibble
+		if (rx_desc0 & RXDES_EM_ODD_NB) {
+			PRINTF(STD_OUT, "%s Odd Nibble         %08x\n", prefix,
+			       rx_desc0);
+			FindErr_Des(p_eng, Des_Flag_OddNibble);
+		}
+#endif
+
+#ifdef CheckRxFIFOFull
+		if (rx_desc0 & RXDES_EM_FIFO_FULL) {
+			PRINTF(STD_OUT, "%s Error Rx FIFO Full %08x\n", prefix,
+			       rx_desc0);
+			FindErr_Des(p_eng, Des_Flag_RxFIFOFull);
+		}
+#endif
+	}
+
+	return 0;
+}
+
+//------------------------------------------------------------
+// return 0: it is PASS
+// return 1: it is FAIL
+//------------------------------------------------------------
+char NCSI_Rx_SLT (MAC_ENGINE *eng) {
+	int        timeout = 0;
+	int        bytesize;
+	int        dwsize;
+	int        i;
+	int        retry   = 0;
+	char       ret     = 1;
+
+	uint32_t      NCSI_RxDatBase;
+	uint32_t      NCSI_RxDesDat;
+	uint32_t      NCSI_RxData;
+	uint32_t      NCSI_BufData;
+
+	do {
+		mac_reg_write( eng, 0x1C, 0x00000000 );//Rx Poll
+
+		timeout = 0;
+		do {
+			NCSI_RxDesDat = Read_Mem_Des_NCSI_DD( eng->run.ncsi_rdes_base );
+			if ( ++timeout > TIME_OUT_NCSI * eng->run.NCSI_RxTimeOutScale ) {
+				PRINTF( FP_LOG, "[RxDes] DesOwn timeout     %08x\n", NCSI_RxDesDat );
+				return( FindErr( eng, Err_Flag_NCSI_Check_RxOwnTimeOut ) );
+			}
+		} while( HWOwnRx( NCSI_RxDesDat ) );
+
+		check_rx_desc_err(eng, NCSI_RxDesDat);
+
+		// Get point of RX DMA buffer
+		NCSI_RxDatBase = AT_BUF_MEMRW( Read_Mem_Des_NCSI_DD( eng->run.ncsi_rdes_base + 0x0C ) );//base for read/write
+		NCSI_RxData    = SWAP_4B_LEDN_NCSI( SWAP_4B_LEDN( Read_Mem_Dat_NCSI_DD( NCSI_RxDatBase + 0x0C ) ) );
+
+		// Get RX valid data in offset 00h of RXDS#0
+#ifdef NCSI_Skip_RxCRCData
+		bytesize  = (NCSI_RxDesDat & 0x3fff) - 4;
+#else
+		bytesize  = (NCSI_RxDesDat & 0x3fff);
+#endif
+		// Fill up to multiple of 4
+		if ( ( bytesize % 4 ) != 0 )
+			dwsize = ( bytesize >> 2 ) + 1;
+		else
+			dwsize = bytesize >> 2;
+
+		if ( eng->arg.ctrl.b.print_ncsi ) {
+#ifdef NCSI_Skip_RxCRCData
+			PRINTF( FP_LOG ,"----->[Rx] %d bytes(%xh) [Remove CRC data]\n", bytesize, bytesize );
+#else
+			PRINTF( FP_LOG ,"----->[Rx] %d bytes(%xh)\n", bytesize, bytesize );
+#endif
+			for (i = 0; i < dwsize - 1; i++) {
+				NCSI_BufData = SWAP_4B_LEDN_NCSI( Read_Mem_Dat_NCSI_DD( NCSI_RxDatBase + ( i << 2 ) ) );
+				PRINTF( FP_LOG ,"      [Rx]%02d:%08x %08x\n", i, NCSI_BufData, SWAP_4B( NCSI_BufData ) );
+			}
+
+			i = ( dwsize - 1 );
+			NCSI_BufData = SWAP_4B_LEDN_NCSI( Read_Mem_Dat_NCSI_DD( NCSI_RxDatBase + ( i << 2 ) ) );
+			switch ( bytesize % 4 ) {
+				case 0  : PRINTF( FP_LOG ,"      [Rx]%02d:%08x %08x\n",                          i, NCSI_BufData & SWAP_4B_LEDN_NCSI( 0xffffffff ), SWAP_4B( NCSI_BufData ) & SWAP_4B_BEDN_NCSI( 0xffffffff ) ); break;
+				case 3  : PRINTF( FP_LOG ,"      [Rx]%02d:%08x %08x [%08x %08x][%08x %08x]\n", i, NCSI_BufData & SWAP_4B_LEDN_NCSI( 0x00ffffff ), SWAP_4B( NCSI_BufData ) & SWAP_4B_BEDN_NCSI( 0x00ffffff ), NCSI_BufData, SWAP_4B( NCSI_BufData ), SWAP_4B_LEDN_NCSI( 0x00ffffff ), SWAP_4B_BEDN_NCSI( 0x00ffffff ) ); break;
+				case 2  : PRINTF( FP_LOG ,"      [Rx]%02d:%08x %08x [%08x %08x][%08x %08x]\n", i, NCSI_BufData & SWAP_4B_LEDN_NCSI( 0x0000ffff ), SWAP_4B( NCSI_BufData ) & SWAP_4B_BEDN_NCSI( 0x0000ffff ), NCSI_BufData, SWAP_4B( NCSI_BufData ), SWAP_4B_LEDN_NCSI( 0x0000ffff ), SWAP_4B_BEDN_NCSI( 0x0000ffff ) ); break;
+				case 1  : PRINTF( FP_LOG ,"      [Rx]%02d:%08x %08x [%08x %08x][%08x %08x]\n", i, NCSI_BufData & SWAP_4B_LEDN_NCSI( 0x000000ff ), SWAP_4B( NCSI_BufData ) & SWAP_4B_BEDN_NCSI( 0x000000ff ), NCSI_BufData, SWAP_4B( NCSI_BufData ), SWAP_4B_LEDN_NCSI( 0x000000ff ), SWAP_4B_BEDN_NCSI( 0x000000ff ) ); break;
+				default : PRINTF( FP_LOG ,"      [Rx]%02d:error", i ); break;
+			}
+		}
+
+		// EtherType field of the response packet should be 0x88F8
+//
+		if ( ( NCSI_RxData & 0xffff ) == 0xf888 ) {
+			for (i = 0; i < dwsize; i++)
+				eng->dat.NCSI_RxDWBUF[i] = SWAP_4B_LEDN_NCSI( Read_Mem_Dat_NCSI_DD( NCSI_RxDatBase + ( i << 2 ) ) );
+
+			memcpy ( &eng->ncsi_rsp, eng->dat.NCSI_RxByteBUF, bytesize );
+
+			if ( eng->arg.ctrl.b.print_ncsi )
+				PRINTF( FP_LOG ,"[Frm-NCSI][Rx IID:%2d]\n", eng->ncsi_rsp.IID );
+
+			if ( ( eng->ncsi_rsp.IID == 0x0 ) && ( eng->ncsi_rsp.Command == 0xff ) ) { // AEN Packet
+				if ( eng->arg.ctrl.b.print_ncsi )
+					PRINTF( FP_LOG ,"[Frm-NCSI][AEN Packet]Type:%2d\n", SWAP_2B_BEDN( eng->ncsi_rsp.Reason_Code ) & 0xff );
+			}
+			else {
+				ret = 0;
+			}
+		}
+		else {
+			if ( eng->arg.ctrl.b.print_ncsi )
+				PRINTF( FP_LOG, "[Frm-Skip] Not NCSI Response: [%08x & %08x = %08x]!=[%08x]\n", NCSI_RxData, 0xffff, NCSI_RxData & 0xffff, 0xf888 );
+		} // End if ( ( NCSI_RxData & 0xffff ) == 0xf888 )
+
+		if ( HWEOR( NCSI_RxDesDat ) ) {
+			// it is last the descriptor in the receive Ring
+			Write_Mem_Des_NCSI_DD( eng->run.ncsi_rdes_base     , EOR_IniVal    );
+			eng->run.ncsi_rdes_base = eng->run.rdes_base;//base for read/write
+		}
+		else {
+			Write_Mem_Des_NCSI_DD( eng->run.ncsi_rdes_base     , 0x00000000    );
+			eng->run.ncsi_rdes_base += 16;
+		}
+
+		if ( ret == 0 )
+			break;
+		retry++;
+	} while ( retry < NCSI_RxDESNum );
+
+	if ( ( ret == 0 ) && eng->arg.ctrl.b.print_ncsi ) {
+#ifdef Print_DetailFrame
+		ncsi_respdump ( eng, &eng->ncsi_rsp );
+#else
+		PRINTF( FP_LOG, "[NCSI-Respond] ETyp:%04x MC_ID:%02x HeadVer:%02x IID:%02x Comm:%02x ChlID:%02x PayLen:%04x ResCd:%02x ReaCd:%02x\n",
+		SWAP_2B_BEDN( eng->ncsi_rsp.EtherType ),
+		eng->ncsi_rsp.MC_ID,
+		eng->ncsi_rsp.Header_Revision,
+		eng->ncsi_rsp.IID,
+		eng->ncsi_rsp.Command,
+		eng->ncsi_rsp.ChID,
+		SWAP_2B_BEDN( eng->ncsi_rsp.Payload_Length ),
+		SWAP_2B_BEDN( eng->ncsi_rsp.Response_Code ),
+		SWAP_2B_BEDN( eng->ncsi_rsp.Reason_Code ));
+#endif
+
+		NCSI_PrintCommandType2File( eng, eng->ncsi_rsp.Command, eng->ncsi_rsp.IID );
+	}
+
+	return( ret );
+} // End char NCSI_Rx_SLT (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+char NCSI_Tx (MAC_ENGINE *eng, unsigned char command, unsigned char allid, uint16_t length) {
+	int        bytesize;
+	int        dwsize;
+	int        i;
+	int        timeout = 0;
+	uint32_t      NCSI_TxDesDat;
+
+	eng->ncsi_req.IID++;
+	eng->ncsi_req.Command        = command;
+	eng->ncsi_req.ChID           = allid;
+	eng->ncsi_req.Payload_Length = SWAP_2B_BEDN( length );
+
+	memcpy (  eng->dat.NCSI_TxByteBUF               , &eng->ncsi_req                 , 30     );
+	memcpy ( (eng->dat.NCSI_TxByteBUF + 30         ), &eng->dat.NCSI_Payload_Data    , length );
+	Calculate_Checksum_NCSI( eng, eng->dat.NCSI_TxByteBUF, 30 + length );
+	memcpy ( (eng->dat.NCSI_TxByteBUF + 30 + length), &eng->dat.Payload_Checksum_NCSI, 4      );
+
+	// Header of NC-SI command format is 34 bytes. page 58, NC-SI spec. ver 1.0.0 from DMTF
+	// The minimum size of a NC-SI package is 64 bytes.
+	bytesize = 34 + length;
+	if ( bytesize < 60 ) {
+		memset ( eng->dat.NCSI_TxByteBUF + bytesize, 0, 60 - bytesize );
+		bytesize = 60;
+	}
+
+	// Fill up to multiple of 4
+	//    dwsize = (bytesize + 3) >> 2;
+	if ( ( bytesize % 4 ) != 0 )
+		dwsize = ( bytesize >> 2 ) + 1;
+	else
+		dwsize = bytesize >> 2;
+
+	if ( eng->arg.ctrl.b.print_ncsi ) {
+		if ( bytesize % 4 )
+			memset ( eng->dat.NCSI_TxByteBUF + bytesize, 0, (dwsize << 2) - bytesize );
+
+		PRINTF( FP_LOG ,"----->[Tx] %d bytes(%xh)\n", bytesize, bytesize );
+		for ( i = 0; i < dwsize-1; i++ )
+			PRINTF( FP_LOG, "      [Tx]%02d:%08x %08x\n", i, eng->dat.NCSI_TxDWBUF[i], SWAP_4B( eng->dat.NCSI_TxDWBUF[i] ) );
+
+		i = dwsize - 1;
+		switch ( bytesize % 4 ) {
+			case 0  : PRINTF( FP_LOG ,"      [Tx]%02d:%08x %08x\n",                          i, eng->dat.NCSI_TxDWBUF[i] & SWAP_4B_LEDN_NCSI( 0xffffffff ), SWAP_4B( eng->dat.NCSI_TxDWBUF[i] ) & SWAP_4B_BEDN_NCSI( 0xffffffff ) ); break;
+			case 3  : PRINTF( FP_LOG ,"      [Tx]%02d:%08x %08x [%08x %08x][%08x %08x]\n", i, eng->dat.NCSI_TxDWBUF[i] & SWAP_4B_LEDN_NCSI( 0x00ffffff ), SWAP_4B( eng->dat.NCSI_TxDWBUF[i] ) & SWAP_4B_BEDN_NCSI( 0x00ffffff ), eng->dat.NCSI_TxDWBUF[i], SWAP_4B( eng->dat.NCSI_TxDWBUF[i] ), SWAP_4B_LEDN_NCSI( 0x00ffffff ), SWAP_4B_BEDN_NCSI( 0x00ffffff ) ); break;
+			case 2  : PRINTF( FP_LOG ,"      [Tx]%02d:%08x %08x [%08x %08x][%08x %08x]\n", i, eng->dat.NCSI_TxDWBUF[i] & SWAP_4B_LEDN_NCSI( 0x0000ffff ), SWAP_4B( eng->dat.NCSI_TxDWBUF[i] ) & SWAP_4B_BEDN_NCSI( 0x0000ffff ), eng->dat.NCSI_TxDWBUF[i], SWAP_4B( eng->dat.NCSI_TxDWBUF[i] ), SWAP_4B_LEDN_NCSI( 0x0000ffff ), SWAP_4B_BEDN_NCSI( 0x0000ffff ) ); break;
+			case 1  : PRINTF( FP_LOG ,"      [Tx]%02d:%08x %08x [%08x %08x][%08x %08x]\n", i, eng->dat.NCSI_TxDWBUF[i] & SWAP_4B_LEDN_NCSI( 0x000000ff ), SWAP_4B( eng->dat.NCSI_TxDWBUF[i] ) & SWAP_4B_BEDN_NCSI( 0x000000ff ), eng->dat.NCSI_TxDWBUF[i], SWAP_4B( eng->dat.NCSI_TxDWBUF[i] ), SWAP_4B_LEDN_NCSI( 0x000000ff ), SWAP_4B_BEDN_NCSI( 0x000000ff ) ); break;
+			default : PRINTF( FP_LOG ,"      [Tx]%02d:error", i ); break;
+		}
+		PRINTF( FP_LOG ,"[Frm-NCSI][Tx IID:%2d]\n", eng->ncsi_req.IID );
+	}
+
+#if 1
+	// Copy data to DMA buffer
+	for ( i = 0; i < dwsize; i++ )
+		Write_Mem_Dat_NCSI_DD( DMA_BASE + ( i << 2 ), SWAP_4B_LEDN_NCSI( eng->dat.NCSI_TxDWBUF[i] ) );
+#endif		
+
+	// Setting one TX descriptor
+	Write_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base       , 0xf0008000 + bytesize );
+
+//	mac_reg_write( eng, 0x40, eng->reg.MAC_040 ); // 20170505
+
+	// Fire
+	mac_reg_write( eng, 0x18, 0x00000000 );//Tx Poll
+
+	do {
+		NCSI_TxDesDat = Read_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base );
+		if ( ++timeout > TIME_OUT_NCSI ) {
+			PRINTF( FP_LOG, "[TxDes] DesOwn timeout     %08X\n", NCSI_TxDesDat );
+			return( FindErr( eng, Err_Flag_NCSI_Check_TxOwnTimeOut  ));
+		}
+	} while ( HWOwnTx( NCSI_TxDesDat ) );
+
+	if ( eng->arg.ctrl.b.print_ncsi ) {
+#ifdef Print_DetailFrame
+		ncsi_reqdump ( eng, &eng->ncsi_req );
+#else
+		PRINTF( FP_LOG, "[NCSI-Request] ETyp:%04x MC_ID:%02x HeadVer:%02x IID:%02x Comm:%02x ChlID:%02x PayLen:%04x\n",
+		SWAP_2B_BEDN( eng->ncsi_req.EtherType ),
+		eng->ncsi_req.MC_ID,
+		eng->ncsi_req.Header_Revision,
+		eng->ncsi_req.IID,
+		eng->ncsi_req.Command,
+		eng->ncsi_req.ChID,
+		SWAP_2B_BEDN( eng->ncsi_req.Payload_Length ) );
+#endif
+
+		NCSI_PrintCommandType2File( eng, eng->ncsi_req.Command, eng->ncsi_req.IID );
+	}
+#ifdef Print_PackageName
+	NCSI_PrintCommandType( eng, eng->ncsi_req.Command, eng->ncsi_req.IID );
+#endif
+
+	return(0);
+} // End char NCSI_Tx (MAC_ENGINE *eng, unsigned char command, unsigned char allid, uint16_t length)
+
+//------------------------------------------------------------
+char NCSI_ARP (MAC_ENGINE *eng) {
+	int        i;
+	int        timeout = 0;
+	uint32_t      NCSI_TxDesDat;
+
+	if ( eng->arg.ctrl.b.print_ncsi )
+		PRINTF( FP_LOG ,"----->[ARP] 60 bytes x%d\n", eng->arg.GARPNumCnt );
+
+	for (i = 0; i < 15; i++) {
+		if ( eng->arg.ctrl.b.print_ncsi )
+			PRINTF( FP_LOG, "      [Tx%02d] %08x %08x\n", i, eng->dat.ARP_data[i], SWAP_4B( eng->dat.ARP_data[i] ) );
+
+		Write_Mem_Dat_NCSI_DD(((uint32_t)&dma_buf) + ( i << 2 ), eng->dat.ARP_data[i] );
+	}
+
+//	Write_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base + 0x04, 0                        );
+//	Write_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base + 0x08, 0                        );
+//	Write_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base + 0x0C, AT_MEMRW_BUF( DMA_BASE ) );
+	for (i = 0; i < eng->arg.GARPNumCnt; i++) {
+		Write_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base      , 0xf0008000 + 60);
+		mac_reg_write( eng, 0x18, 0x00000000 );//Tx Poll
+
+		do {
+			NCSI_TxDesDat = Read_Mem_Des_NCSI_DD( eng->run.ncsi_tdes_base );
+			if ( ++timeout > TIME_OUT_NCSI ) {
+				PRINTF( FP_LOG, "[TxDes-ARP] DesOwn timeout %08x\n", NCSI_TxDesDat );
+				return( FindErr( eng, Err_Flag_NCSI_Check_ARPOwnTimeOut ) );
+			}
+		} while ( HWOwnTx( NCSI_TxDesDat ) );
+	}
+	return(0);
+} // End char NCSI_ARP (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+char NCSI_SentWaitPacket (MAC_ENGINE *eng, unsigned char command, unsigned char allid, uint16_t length) {
+	int        Retry = 0;
+
+	do {
+		if ( NCSI_Tx( eng, command, allid, length ) )
+			return( 1 );
+
+#ifdef NCSI_EnableDelay_EachPackage
+		DELAY( Delay_EachPackage );
+#endif
+		if ( NCSI_Rx_SLT( eng ) )
+			return( 2 );
+
+		if (    ( eng->ncsi_rsp.IID           != eng->ncsi_req.IID                        )
+		     || ( eng->ncsi_rsp.Command       != ( command | 0x80 )                       )
+		     || ( eng->ncsi_rsp.Response_Code != SWAP_2B_BEDN( COMMAND_COMPLETED ) ) ) {
+			if ( eng->arg.ctrl.b.print_ncsi ) {
+				PRINTF( FP_LOG, "Retry: Command = %x, Response_Code = %x", eng->ncsi_req.Command, SWAP_2B_BEDN( eng->ncsi_rsp.Response_Code ) );
+				switch ( SWAP_2B_BEDN( eng->ncsi_rsp.Response_Code ) ) {
+					case COMMAND_COMPLETED  	: PRINTF( FP_LOG, "(completed  )\n" ); break;
+					case COMMAND_FAILED     	: PRINTF( FP_LOG, "(failed     )\n" ); break;
+					case COMMAND_UNAVAILABLE	: PRINTF( FP_LOG, "(unavailable)\n" ); break;
+					case COMMAND_UNSUPPORTED	: PRINTF( FP_LOG, "(unsupported)\n" ); break;
+					default                 	: PRINTF( FP_LOG, "(-----------)\n" ); break;
+				}
+			}
+			Retry++;
+		}
+		else {
+			return( 0 );
+		}
+	} while (Retry <= SENT_RETRY_COUNT);
+
+	return( 3 );
+} // End char NCSI_SentWaitPacket (unsigned char command, unsigned char id, uint16_t length)
+
+//------------------------------------------------------------
+char Clear_Initial_State_SLT (MAC_ENGINE *eng) {//Command:0x00
+	char       return_value;
+
+	eng->flg.error_backup  = eng->flg.error;
+	eng->flg.ncsi_backup = eng->flg.ncsi;
+
+	return_value = NCSI_SentWaitPacket( eng, CLEAR_INITIAL_STATE, eng->ncsi_cap.All_ID, 0 );//Internal Channel ID = 0
+
+	eng->flg.error  = eng->flg.error_backup;
+	eng->flg.ncsi = eng->flg.ncsi_backup;
+	return( return_value );//Internal Channel ID = 0
+}
+
+//------------------------------------------------------------
+char Select_Package_SLT (MAC_ENGINE *eng, char skipflag) {//Command:0x01
+	char       return_value;
+
+	if ( skipflag ) {
+		eng->flg.error_backup  = eng->flg.error;
+		eng->flg.ncsi_backup = eng->flg.ncsi;
+	}
+
+	memset ((void *)eng->dat.NCSI_Payload_Data, 0, 4);
+	eng->dat.NCSI_Payload_Data[ 3 ] = 1; //Arbitration Disable
+	return_value = NCSI_SentWaitPacket( eng, SELECT_PACKAGE, ( eng->ncsi_cap.Package_ID << 5 ) + 0x1F, 4 );//Internal Channel ID = 0x1F, 0x1F means all channel
+	if ( return_value )
+		ncsi_set_error_flag( eng, NCSI_Flag_Select_Package );
+
+	if ( skipflag ) {
+		eng->flg.error  = eng->flg.error_backup;
+		eng->flg.ncsi = eng->flg.ncsi_backup;
+	}
+	return( return_value );
+}
+
+//------------------------------------------------------------
+void Select_Active_Package_SLT (MAC_ENGINE *eng) {//Command:0x01
+	memset ((void *)eng->dat.NCSI_Payload_Data, 0, 4);
+	eng->dat.NCSI_Payload_Data[ 3 ] = 1; //Arbitration Disable
+
+	if ( NCSI_SentWaitPacket( eng, SELECT_PACKAGE, ( eng->ncsi_cap.Package_ID << 5 ) + 0x1F, 4 ) ) //Internal Channel ID = 0x1F, 0x1F means all channel
+		ncsi_set_error_flag( eng, NCSI_Flag_Select_Active_Package );
+}
+
+//------------------------------------------------------------
+void DeSelect_Package_SLT (MAC_ENGINE *eng) {//Command:0x02
+	if ( NCSI_SentWaitPacket( eng, DESELECT_PACKAGE, ( eng->ncsi_cap.Package_ID << 5 ) + 0x1F, 0 ) ) //Internal Channel ID = 0x1F, 0x1F means all channel
+		ncsi_set_error_flag( eng, NCSI_Flag_Deselect_Package );
+
+#ifdef NCSI_EnableDelay_DeSelectPackage
+	DELAY( Delay_DeSelectPackage );
+#endif
+}
+
+//------------------------------------------------------------
+void Enable_Channel_SLT (MAC_ENGINE *eng) {//Command:0x03
+	if ( NCSI_SentWaitPacket( eng, ENABLE_CHANNEL, eng->ncsi_cap.All_ID, 0 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Enable_Channel );
+}
+
+//------------------------------------------------------------
+void Disable_Channel_SLT (MAC_ENGINE *eng, char skipflag) {//Command:0x04
+	if ( skipflag ) {
+		eng->flg.error_backup  = eng->flg.error;
+		eng->flg.ncsi_backup = eng->flg.ncsi;
+	}
+
+	memset ((void *)eng->dat.NCSI_Payload_Data, 0, 4);
+	eng->dat.NCSI_Payload_Data[ 3 ] = 0x1; //ALD
+	if ( NCSI_SentWaitPacket( eng, DISABLE_CHANNEL, eng->ncsi_cap.All_ID, 4 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Disable_Channel );
+
+	if ( skipflag ) {
+		eng->flg.error  = eng->flg.error_backup;
+		eng->flg.ncsi = eng->flg.ncsi_backup;
+	}
+}
+
+//------------------------------------------------------------
+void Enable_Network_TX_SLT (MAC_ENGINE *eng) {//Command:0x06
+	if ( NCSI_SentWaitPacket( eng, ENABLE_CHANNEL_NETWORK_TX, eng->ncsi_cap.All_ID, 0 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Enable_Network_TX );
+}
+
+//------------------------------------------------------------
+void Disable_Network_TX_SLT (MAC_ENGINE *eng) {//Command:0x07
+	if ( NCSI_SentWaitPacket( eng, DISABLE_CHANNEL_NETWORK_TX, eng->ncsi_cap.All_ID, 0 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Disable_Network_TX );
+}
+
+//------------------------------------------------------------
+void Set_Link_SLT (MAC_ENGINE *eng) {//Command:0x09
+	memset ((void *)eng->dat.NCSI_Payload_Data, 0, 8);
+	eng->dat.NCSI_Payload_Data[ 2 ] = 0x02; //full duplex
+//	eng->dat.NCSI_Payload_Data[ 3 ] = 0x04; //100M, auto-disable
+	eng->dat.NCSI_Payload_Data[ 3 ] = 0x05; //100M, auto-enable
+
+	if ( NCSI_SentWaitPacket( eng, SET_LINK, eng->ncsi_cap.All_ID, 8 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Set_Link );
+}
+
+//------------------------------------------------------------
+char Get_Link_Status_SLT (MAC_ENGINE *eng) {//Command:0x0a
+	if ( NCSI_SentWaitPacket( eng, GET_LINK_STATUS, eng->ncsi_cap.All_ID, 0 ) )
+		return(0);
+	else {
+		if ( eng->ncsi_rsp.Payload_Data[ 3 ] & 0x20 ) {
+			if ( eng->ncsi_rsp.Payload_Data[ 3 ] & 0x40 ) {
+				if ( eng->ncsi_rsp.Payload_Data[ 3 ] & 0x01 )
+					return(1); //Link Up or Not
+				else
+					return(0);
+			}
+			else
+				return(0); //Auto Negotiate did not finish
+		}
+		else {
+			if ( eng->ncsi_rsp.Payload_Data[ 3 ] & 0x01 )
+				return(1); //Link Up or Not
+			else
+				return(0);
+		}
+	}
+} // End char Get_Link_Status_SLT (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+void Enable_Set_MAC_Address_SLT (MAC_ENGINE *eng) 
+{
+	//Command:0x0e
+
+	int        i;
+
+	for ( i = 0; i < 6; i++ )
+		eng->dat.NCSI_Payload_Data[ i ] = eng->ncsi_req.SA[ i ];
+	eng->dat.NCSI_Payload_Data[ 6 ] = 1; //MAC Address Num = 1 --> address filter 1, fixed in sample code
+
+	if ( eng->ncsi_req.SA[ 0 ] & 0x1 )
+		eng->dat.NCSI_Payload_Data[ 7 ] = MULTICAST + ENABLE_MAC_ADDRESS_FILTER; //AT + E
+	else
+		eng->dat.NCSI_Payload_Data[ 7 ] = UNICAST   + ENABLE_MAC_ADDRESS_FILTER; //AT + E
+
+	if ( NCSI_SentWaitPacket( eng, SET_MAC_ADDRESS, eng->ncsi_cap.All_ID, 8 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Enable_Set_MAC_Address );
+}
+
+//------------------------------------------------------------
+void Enable_Broadcast_Filter_SLT (MAC_ENGINE *eng) {//Command:0x10
+	memset ((void *)eng->dat.NCSI_Payload_Data, 0, 4);
+	eng->dat.NCSI_Payload_Data[ 3 ] = 0xF; //ARP, DHCP, NetBIOS
+
+	if ( NCSI_SentWaitPacket( eng, ENABLE_BROADCAST_FILTERING, eng->ncsi_cap.All_ID, 4 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Enable_Broadcast_Filter );
+}
+
+//------------------------------------------------------------
+void Get_Version_ID_SLT (MAC_ENGINE *eng) {//Command:0x15
+	if ( NCSI_SentWaitPacket( eng, GET_VERSION_ID, eng->ncsi_cap.All_ID, 0 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Get_Version_ID );
+	else {
+#ifdef Print_Version_ID
+		printf("NCSI Version        : %02x %02x %02x %02x\n", eng->ncsi_rsp.Payload_Data[  0 ], eng->ncsi_rsp.Payload_Data[  1 ], eng->ncsi_rsp.Payload_Data[  2 ], eng->ncsi_rsp.Payload_Data[  3 ]);
+		printf("NCSI Version        : %02x %02x %02x %02x\n", eng->ncsi_rsp.Payload_Data[  4 ], eng->ncsi_rsp.Payload_Data[  5 ], eng->ncsi_rsp.Payload_Data[  6 ], eng->ncsi_rsp.Payload_Data[  7 ]);
+		printf("Firmware Name String: %02x %02x %02x %02x\n", eng->ncsi_rsp.Payload_Data[  8 ], eng->ncsi_rsp.Payload_Data[  9 ], eng->ncsi_rsp.Payload_Data[ 10 ], eng->ncsi_rsp.Payload_Data[ 11 ]);
+		printf("Firmware Name String: %02x %02x %02x %02x\n", eng->ncsi_rsp.Payload_Data[ 12 ], eng->ncsi_rsp.Payload_Data[ 13 ], eng->ncsi_rsp.Payload_Data[ 14 ], eng->ncsi_rsp.Payload_Data[ 15 ]);
+		printf("Firmware Name String: %02x %02x %02x %02x\n", eng->ncsi_rsp.Payload_Data[ 16 ], eng->ncsi_rsp.Payload_Data[ 17 ], eng->ncsi_rsp.Payload_Data[ 18 ], eng->ncsi_rsp.Payload_Data[ 19 ]);
+		printf("Firmware Version    : %02x %02x %02x %02x\n", eng->ncsi_rsp.Payload_Data[ 20 ], eng->ncsi_rsp.Payload_Data[ 21 ], eng->ncsi_rsp.Payload_Data[ 22 ], eng->ncsi_rsp.Payload_Data[ 23 ]);
+		printf("PCI DID/VID         : %02x %02x/%02x %02x\n", eng->ncsi_rsp.Payload_Data[ 24 ], eng->ncsi_rsp.Payload_Data[ 25 ], eng->ncsi_rsp.Payload_Data[ 26 ], eng->ncsi_rsp.Payload_Data[ 27 ]);
+		printf("PCI SSID/SVID       : %02x %02x/%02x %02x\n", eng->ncsi_rsp.Payload_Data[ 28 ], eng->ncsi_rsp.Payload_Data[ 29 ], eng->ncsi_rsp.Payload_Data[ 30 ], eng->ncsi_rsp.Payload_Data[ 31 ]);
+		printf("Manufacturer ID     : %02x %02x %02x %02x\n", eng->ncsi_rsp.Payload_Data[ 32 ], eng->ncsi_rsp.Payload_Data[ 33 ], eng->ncsi_rsp.Payload_Data[ 34 ], eng->ncsi_rsp.Payload_Data[ 35 ]);
+		printf("Checksum            : %02x %02x %02x %02x\n", eng->ncsi_rsp.Payload_Data[ 36 ], eng->ncsi_rsp.Payload_Data[ 37 ], eng->ncsi_rsp.Payload_Data[ 38 ], eng->ncsi_rsp.Payload_Data[ 39 ]);
+#endif
+		eng->ncsi_cap.PCI_DID_VID    = (eng->ncsi_rsp.Payload_Data[ 24 ]<<24)
+		                             | (eng->ncsi_rsp.Payload_Data[ 25 ]<<16)
+		                             | (eng->ncsi_rsp.Payload_Data[ 26 ]<< 8)
+		                             | (eng->ncsi_rsp.Payload_Data[ 27 ]    );
+		eng->ncsi_cap.manufacturer_id = (eng->ncsi_rsp.Payload_Data[ 32 ]<<24)
+		                             | (eng->ncsi_rsp.Payload_Data[ 33 ]<<16)
+		                             | (eng->ncsi_rsp.Payload_Data[ 34 ]<< 8)
+		                             | (eng->ncsi_rsp.Payload_Data[ 35 ]    );
+	}
+} // End void Get_Version_ID_SLT (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+void Get_Capabilities_SLT (MAC_ENGINE *eng) {//Command:0x16
+	if ( NCSI_SentWaitPacket( eng, GET_CAPABILITIES, eng->ncsi_cap.All_ID, 0 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Get_Capabilities );
+	else {
+//		eng->ncsi_cap.Capabilities_Flags                   = (eng->ncsi_rsp.Payload_Data[  0 ]<<24)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[  1 ]<<16)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[  2 ]<< 8)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[  3 ]    );
+//		eng->ncsi_cap.Broadcast_Packet_Filter_Capabilities = (eng->ncsi_rsp.Payload_Data[  4 ]<<24)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[  5 ]<<16)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[  6 ]<< 8)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[  7 ]    );
+//		eng->ncsi_cap.Multicast_Packet_Filter_Capabilities = (eng->ncsi_rsp.Payload_Data[  8 ]<<24)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[  9 ]<<16)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[ 10 ]<< 8)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[ 11 ]    );
+//		eng->ncsi_cap.Buffering_Capabilities               = (eng->ncsi_rsp.Payload_Data[ 12 ]<<24)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[ 13 ]<<16)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[ 14 ]<< 8)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[ 15 ]    );
+//		eng->ncsi_cap.AEN_Control_Support                  = (eng->ncsi_rsp.Payload_Data[ 16 ]<<24)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[ 17 ]<<16)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[ 18 ]<< 8)
+//		                                                   | (eng->ncsi_rsp.Payload_Data[ 19 ]    );
+//		eng->ncsi_cap.VLAN_Filter_Count                    =  eng->ncsi_rsp.Payload_Data[ 20 ];
+		eng->ncsi_cap.Mixed_Filter_Count                   =  eng->ncsi_rsp.Payload_Data[ 21 ];
+//		eng->ncsi_cap.Multicast_Filter_Count               =  eng->ncsi_rsp.Payload_Data[ 22 ];
+		eng->ncsi_cap.Unicast_Filter_Count                 =  eng->ncsi_rsp.Payload_Data[ 23 ];
+//		eng->ncsi_cap.VLAN_Mode_Support                    =  eng->ncsi_rsp.Payload_Data[ 26 ]
+		eng->ncsi_cap.Channel_Count                        =  eng->ncsi_rsp.Payload_Data[ 27 ];
+	}
+}
+
+//------------------------------------------------------------
+void Get_Controller_Packet_Statistics_SLT (MAC_ENGINE *eng) {//Command:0x18
+	if ( NCSI_SentWaitPacket( eng, GET_CONTROLLER_PACKET_STATISTICS, eng->ncsi_cap.All_ID, 0 ) )
+		ncsi_set_error_flag( eng, NCSI_Flag_Get_Controller_Packet_Statistics );
+}
+
+//------------------------------------------------------------
+char phy_ncsi (MAC_ENGINE *eng) 
+{
+	uint32_t pkg_idx;
+	uint32_t chl_idx;
+	uint32_t select_flag[MAX_PACKAGE_NUM];
+	uint32_t Re_Send;
+	uint32_t Link_Status;
+
+	eng->dat.NCSI_RxEr = 0;
+	eng->dat.number_chl = 0;
+	eng->dat.number_pak = 0;
+	eng->ncsi_cap.Package_ID = 0;
+	eng->ncsi_cap.Channel_ID = 0x1F;
+	eng->ncsi_cap.All_ID = 0x1F;
+	PRINTF(FP_LOG, "\n\n======> Start:\n");
+
+	NCSI_Struct_Initialize_SLT(eng);
+
+#ifdef NCSI_Skip_Phase1_DeSelectPackage
+#else
+	//NCSI Start
+	//Disable Channel then DeSelect Package
+	for (pkg_idx = 0; pkg_idx < MAX_PACKAGE_NUM; pkg_idx++) {
+		eng->ncsi_cap.Package_ID = pkg_idx;
+		eng->ncsi_cap.Channel_ID = 0x1F;
+		eng->ncsi_cap.All_ID     = ( eng->ncsi_cap.Package_ID << 5) + eng->ncsi_cap.Channel_ID;
+
+		select_flag[ pkg_idx ] = Select_Package_SLT ( eng, 1 ); //skipflag// Command:0x01
+
+		if ( select_flag[ pkg_idx ] == 0 ) {
+			if ( !eng->run.IO_MrgChk ) {
+				printf("----Find Package ID: %d\n", eng->ncsi_cap.Package_ID);
+				PRINTF(FP_LOG, "----Find Package ID: %d\n", eng->ncsi_cap.Package_ID );
+			}
+			for ( chl_idx = 0; chl_idx < MAX_CHANNEL_NUM; chl_idx++ ) {
+				eng->ncsi_cap.Channel_ID = chl_idx;
+				eng->ncsi_cap.All_ID     = ( eng->ncsi_cap.Package_ID << 5) + eng->ncsi_cap.Channel_ID;
+
+				Disable_Channel_SLT( eng, 1 );//skipflag // Command: 0x04
+			}
+  #ifdef NCSI_Skip_DeSelectPackage
+  #else
+			DeSelect_Package_SLT ( eng ); // Command:0x02
+  #endif
+		} else {
+			if ( !eng->run.IO_MrgChk ) {
+				printf("----Absence of Package ID: %d\n", pkg_idx);
+				PRINTF( FP_LOG, "----Absence of Package ID: %d\n", pkg_idx );
+			}
+		} // End if ( select_flag[ pkg_idx ] == 0 )
+	} // End for (pkg_idx = 0; pkg_idx < MAX_PACKAGE_NUM; pkg_idx++)
+#endif
+
+	//Select Package
+	for ( pkg_idx = 0; pkg_idx < MAX_PACKAGE_NUM; pkg_idx++ ) {
+		eng->ncsi_cap.Package_ID = pkg_idx;
+		eng->ncsi_cap.Channel_ID = 0x1F;
+		eng->ncsi_cap.All_ID     = ( eng->ncsi_cap.Package_ID << 5) + eng->ncsi_cap.Channel_ID;
+
+#ifdef NCSI_Skip_Phase1_DeSelectPackage
+		select_flag[ pkg_idx ] = Select_Package_SLT ( eng, 1 ); //skipflag//Command:0x01
+#endif
+
+		if ( select_flag[ pkg_idx ] == 0 ) {
+			//eng->run.NCSI_RxTimeOutScale = 1000;
+			eng->run.NCSI_RxTimeOutScale = 10;
+
+#ifdef NCSI_Skip_Phase1_DeSelectPackage
+#else
+			Select_Package_SLT ( eng, 0 );//Command:0x01
+#endif
+			eng->dat.number_pak++;
+			if ( !eng->run.IO_MrgChk ) {
+				printf("====Find Package ID: %d\n", eng->ncsi_cap.Package_ID);
+				PRINTF(FP_LOG, "====Find Package ID: %d\n", eng->ncsi_cap.Package_ID );
+			}
+
+			// Scan all channel in the package
+			for ( chl_idx = 0; chl_idx < MAX_CHANNEL_NUM; chl_idx++ ) {
+				eng->ncsi_cap.Channel_ID = chl_idx;
+				eng->ncsi_cap.All_ID     = ( eng->ncsi_cap.Package_ID << 5) + eng->ncsi_cap.Channel_ID;
+
+				if ( Clear_Initial_State_SLT( eng ) == 0 ) { //Command:0x00
+					eng->dat.number_chl++;
+					if ( !eng->run.IO_MrgChk ) {
+						printf("--------Find Channel ID: %d\n", eng->ncsi_cap.Channel_ID);
+						PRINTF( FP_LOG, "--------Find Channel ID: %d\n", eng->ncsi_cap.Channel_ID );
+					}
+
+					// Get Version and Capabilities
+					Get_Version_ID_SLT( eng );          //Command:0x15
+					Get_Capabilities_SLT( eng );        //Command:0x16
+					Select_Active_Package_SLT( eng );   //Command:0x01
+					Enable_Set_MAC_Address_SLT( eng );  //Command:0x0e
+					Enable_Broadcast_Filter_SLT( eng ); //Command:0x10
+
+					// Enable TX
+					Enable_Network_TX_SLT( eng );       //Command:0x06
+
+					// Enable Channel
+					Enable_Channel_SLT( eng );          //Command:0x03
+
+					// Get Link Status
+					Re_Send = 0;
+					do {
+#ifdef NCSI_EnableDelay_GetLinkStatus
+						if ( Re_Send )
+							DELAY( Delay_GetLinkStatus );
+#endif
+
+						Link_Status = Get_Link_Status_SLT( eng );//Command:0x0a
+						if ( Link_Status == LINK_UP ) {
+							if ( eng->arg.GARPNumCnt )
+								NCSI_ARP ( eng );
+							break;
+						} // End if ( Link_Status == LINK_UP )
+					} while ( Re_Send++ <= 2 );
+
+					if ( !eng->run.IO_MrgChk ) {
+						if ( Link_Status == LINK_UP ) {
+							printf("        This Channel is LINK_UP (MFC:%d, UFC:%d, CC:%d)\n", eng->ncsi_cap.Mixed_Filter_Count, eng->ncsi_cap.Unicast_Filter_Count, eng->ncsi_cap.Channel_Count);
+							PRINTF( FP_LOG, "        This Channel is LINK_UP (MFC:%d, UFC:%d, CC:%d)\n", eng->ncsi_cap.Mixed_Filter_Count, eng->ncsi_cap.Unicast_Filter_Count, eng->ncsi_cap.Channel_Count);
+						}
+						else {
+							printf("        This Channel is LINK_DOWN (MFC:%d, UFC:%d, CC:%d)\n", eng->ncsi_cap.Mixed_Filter_Count, eng->ncsi_cap.Unicast_Filter_Count, eng->ncsi_cap.Channel_Count);
+							PRINTF( FP_LOG, "        This Channel is LINK_DOWN (MFC:%d, UFC:%d, CC:%d)\n", eng->ncsi_cap.Mixed_Filter_Count, eng->ncsi_cap.Unicast_Filter_Count, eng->ncsi_cap.Channel_Count);
+						}
+					}
+
+#ifdef NCSI_Skip_DiSChannel
+#else
+					if ( eng->run.TM_NCSI_DiSChannel ) {
+						// Disable TX
+						Disable_Network_TX_SLT( eng ); //Command:0x07
+						// Disable Channel
+						Disable_Channel_SLT( eng, 0 );    //Command:0x04
+					}
+#endif
+				} // End if ( Clear_Initial_State_SLT( eng, chl_idx ) == 0 )
+			} // End for ( chl_idx = 0; chl_idx < MAX_CHANNEL_NUM; chl_idx++ )
+
+#ifdef NCSI_Skip_DeSelectPackage
+#else
+			DeSelect_Package_SLT ( eng );//Command:0x02
+#endif
+			eng->run.NCSI_RxTimeOutScale = 1;
+		}
+		else {
+			if ( !eng->run.IO_MrgChk ) {
+				printf("====Absence of Package ID: %d\n", pkg_idx);
+				PRINTF( FP_LOG, "====Absence of Package ID: %d\n", pkg_idx );
+			}
+		} // End if ( select_flag[pkg_idx] == 0 )
+	} // End for ( pkg_idx = 0; pkg_idx < MAX_PACKAGE_NUM; pkg_idx++ )
+
+	if ( eng->dat.number_pak == 0                       ) FindErr( eng, Err_Flag_NCSI_No_PHY      );
+	if ( eng->dat.number_pak != eng->arg.GPackageTolNum ) FindErr( eng, Err_Flag_NCSI_Package_Num );
+	if ( eng->dat.number_chl != eng->arg.GChannelTolNum ) FindErr( eng, Err_Flag_NCSI_Channel_Num );
+//	if ( eng->dat.number_chl == 0                       ) FindErr( eng );
+
+	if ( eng->flg.error ) {
+		if ( eng->dat.NCSI_RxEr )
+			FindErr_Des( eng, Des_Flag_RxErr );
+		return(1);
+	}
+	else {
+		if ( eng->dat.NCSI_RxEr ) {
+			eng->flg.warn = eng->flg.warn | Wrn_Flag_RxErFloatting;
+			if ( eng->arg.ctrl.b.skip_rx_err ) {
+				eng->flg.all_fail = 0;
+				return(0);
+			}
+			else {
+				FindErr_Des( eng, Des_Flag_RxErr );
+				return(1);
+			}
+		}
+		else {
+			eng->flg.all_fail = 0;
+			return(0);
+		}
+	}
+}
diff -Naur uboot/oem/ami/standalone/nettest/ncsi.h uboot-new/oem/ami/standalone/nettest/ncsi.h
--- uboot/oem/ami/standalone/nettest/ncsi.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/ncsi.h	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,154 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef NCSI_H
+#define NCSI_H
+
+#define NCSI_RxDMA_PakSize                       2048
+#define NCSI_RxDMA_BASE                          ( DMA_BASE + 0x00100000 )
+
+//---------------------------------------------------------
+// Define
+//---------------------------------------------------------
+#define MAX_PACKAGE_NUM                          8      // 1 ~ 8
+#define MAX_CHANNEL_NUM                          4      // 1 ~ 32
+
+//---------------------------------------------------------
+// Function
+//---------------------------------------------------------
+#define SENT_RETRY_COUNT                         1
+#define NCSI_RxDESNum                            2048
+
+#define NCSI_Skip_RxCRCData
+//#define NCSI_Skip_Phase1_DeSelectPackage
+//#define NCSI_Skip_DeSelectPackage
+//#define NCSI_Skip_DiSChannel
+//#define NCSI_EnableDelay_DeSelectPackage
+//#define NCSI_EnableDelay_GetLinkStatus
+//#define NCSI_EnableDelay_EachPackage
+//#define Print_Version_ID
+//#define Print_PackageName
+#define Print_DetailFrame
+
+//---------------------------------------------------------
+// Delay (ms)
+//---------------------------------------------------------
+#define Delay_EachPackage                        1000
+#define Delay_DeSelectPackage                    50
+#define Delay_GetLinkStatus                      50
+
+//---------------------------------------------------------
+// PCI DID/VID & Manufacturer ID
+//---------------------------------------------------------
+#define ManufacturerID_Intel                     0x00000157     //343
+#define ManufacturerID_Broadcom                  0x0000113d     //4413
+#define ManufacturerID_Mellanox                  0x000002c9     //713
+#define ManufacturerID_Mellanox1                 0x00008119     //33049
+#define ManufacturerID_Emulex                    0x0000006c     //108
+
+//PCI VID: [163c]intel
+//PCI VID: [8086]Intel Corporation
+//PCI VID: [8087]Intel
+//PCI VID: [14e4]Broadcom Corporation
+//PCI VID: [15b3]Mellanox
+//PCI VID: [10df]Emulex
+#define PCI_DID_VID_Intel_82574L                 0x10d38086     // IntelR 82574L Gigabit Ethernet Controller
+#define PCI_DID_VID_Intel_82575_10d6             0x10d68086     // 82566 DM-2-gigabyte
+#define PCI_DID_VID_Intel_82575_10a7             0x10a78086     // 82575EB Gigabit Network Connection
+#define PCI_DID_VID_Intel_82575_10a9             0x10a98086     // 82575EB Gigabit Network Connection
+#define PCI_DID_VID_Intel_82576_10c9             0x10c98086     //*82576 Gigabit ET Dual Port Server Adapter
+#define PCI_DID_VID_Intel_82576_10e6             0x10e68086     // 82576 Gigabit Network Connection
+#define PCI_DID_VID_Intel_82576_10e7             0x10e78086     // 82576 Gigabit Network Connection
+#define PCI_DID_VID_Intel_82576_10e8             0x10e88086     // E64750-xxx Intel Gigabit ET Quad Port Server Adapter
+#define PCI_DID_VID_Intel_82576_1518             0x15188086     // 82576NS SerDes Gigabit Network Connectio
+#define PCI_DID_VID_Intel_82576_1526             0x15268086     // Intel Gigabit ET2 Quad Port Server Adapter
+#define PCI_DID_VID_Intel_82576_150a             0x150a8086     // 82576NS Gigabit Ethernet Controller
+#define PCI_DID_VID_Intel_82576_150d             0x150d8086     // 82576 Gigabit Backplane Connection
+#define PCI_DID_VID_Intel_82599_10fb             0x10fb8086     // 10 Gb Ethernet controller
+#define PCI_DID_VID_Intel_82599_1557             0x15578086     // 82599EN
+#define PCI_DID_VID_Intel_I210_1533              0x15338086     //
+#define PCI_DID_VID_Intel_I210_1537              0x15378086     //???
+#define PCI_DID_VID_Intel_I350_1521              0x15218086     //
+#define PCI_DID_VID_Intel_I350_1523              0x15238086     //
+#define PCI_DID_VID_Intel_X540                   0x15288086     //
+#define PCI_DID_VID_Intel_X550                   0x15638086     //
+#define PCI_DID_VID_Intel_Broadwell_DE           0x15ab8086     //PCH
+#define PCI_DID_VID_Intel_X722_37d0              0x37d08086     //
+#define PCI_DID_VID_Broadcom_BCM5718             0x165614e4     //
+#define PCI_DID_VID_Broadcom_BCM5719             0x165714e4     //
+#define PCI_DID_VID_Broadcom_BCM5720             0x165f14e4     //
+#define PCI_DID_VID_Broadcom_BCM5725             0x164314e4     //
+#define PCI_DID_VID_Broadcom_BCM57810S           0x168e14e4     //
+#define PCI_DID_VID_Broadcom_Cumulus             0x16ca14e4     //
+#define PCI_DID_VID_Broadcom_BCM57302            0x16c914e4     //
+#define PCI_DID_VID_Broadcom_BCM957452           0x16f114e4     //
+#define PCI_DID_VID_Mellanox_ConnectX_3_1003     0x100315b3     //*
+#define PCI_DID_VID_Mellanox_ConnectX_3_1007     0x100715b3     //ConnectX-3 Pro
+#define PCI_DID_VID_Mellanox_ConnectX_4          0x101515b3     //*
+#define PCI_DID_VID_Emulex_40G                   0x072010df     //
+
+//---------------------------------------------------------
+// NCSI Parameter
+//---------------------------------------------------------
+//Command and Response Type
+#define CLEAR_INITIAL_STATE                      0x00           //M
+#define SELECT_PACKAGE                           0x01           //M
+#define DESELECT_PACKAGE                         0x02           //M
+#define ENABLE_CHANNEL                           0x03           //M
+#define DISABLE_CHANNEL                          0x04           //M
+#define RESET_CHANNEL                            0x05           //M
+#define ENABLE_CHANNEL_NETWORK_TX                0x06           //M
+#define DISABLE_CHANNEL_NETWORK_TX               0x07           //M
+#define AEN_ENABLE                               0x08
+#define SET_LINK                                 0x09           //M
+#define GET_LINK_STATUS                          0x0A           //M
+#define SET_VLAN_FILTER                          0x0B           //M
+#define ENABLE_VLAN                              0x0C           //M
+#define DISABLE_VLAN                             0x0D           //M
+#define SET_MAC_ADDRESS                          0x0E           //M
+#define ENABLE_BROADCAST_FILTERING               0x10           //M
+#define DISABLE_BROADCAST_FILTERING              0x11           //M
+#define ENABLE_GLOBAL_MULTICAST_FILTERING        0x12
+#define DISABLE_GLOBAL_MULTICAST_FILTERING       0x13
+#define SET_NCSI_FLOW_CONTROL                    0x14
+#define GET_VERSION_ID                           0x15           //M
+#define GET_CAPABILITIES                         0x16           //M
+#define GET_PARAMETERS                           0x17           //M
+#define GET_CONTROLLER_PACKET_STATISTICS         0x18
+#define GET_NCSI_STATISTICS                      0x19
+#define GET_NCSI_PASS_THROUGH_STATISTICS         0x1A
+
+//Standard Response Code
+#define COMMAND_COMPLETED                        0x00
+#define COMMAND_FAILED                           0x01
+#define COMMAND_UNAVAILABLE                      0x02
+#define COMMAND_UNSUPPORTED                      0x03
+
+//Standard Reason Code
+#define NO_ERROR                                 0x0000
+#define INTERFACE_INITIALIZATION_REQUIRED        0x0001
+#define PARAMETER_IS_INVALID                     0x0002
+#define CHANNEL_NOT_READY                        0x0003
+#define PACKAGE_NOT_READY                        0x0004
+#define INVALID_PAYLOAD_LENGTH                   0x0005
+#define UNKNOWN_COMMAND_TYPE                     0x7FFF
+
+//SET_MAC_ADDRESS
+#define UNICAST                                  ( 0x00 << 5 )
+#define MULTICAST                                ( 0x01 << 5 )
+#define DISABLE_MAC_ADDRESS_FILTER               0x00
+#define ENABLE_MAC_ADDRESS_FILTER                0x01
+
+//GET_LINK_STATUS
+#define LINK_DOWN                                0
+#define LINK_UP                                  1
+
+#endif // NCSI_H
diff -Naur uboot/oem/ami/standalone/nettest/nettest.c uboot-new/oem/ami/standalone/nettest/nettest.c
--- uboot/oem/ami/standalone/nettest/nettest.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/nettest.c	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,53 @@
+/*
+(C) Copyright 2020
+ American Megatrends Inc
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of
+ the License, or (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ MA 02111-1307 USA
+*/
+
+#include <common.h>
+#include <exports.h>
+#include "stdalone.h"
+
+/* standalone application entry point */
+
+extern cmd_map_t cmd_map[CMD_MAX];
+
+/*
+ * @fn nettest
+ *
+ */
+int nettest(int argc, char * const argv[])
+{
+	int idx = 0;
+
+	app_startup(argv);
+
+	if (argc < 2){
+		/* ex: go 83000000 mactest 1 1 24 1 6 0 3 */
+		printf("usage: go %x <cmdname>\n", 0x83000000);
+		return 0;
+	}
+
+	for(idx = 0; idx < CMD_MAX; idx++){
+		if((strcmp(argv[1], cmd_map[idx].cmdname) == 0)) {
+			return cmd_map[idx].cmdfunc(argc - 1, &argv[1]);
+		}
+	}
+
+	printf("cmd name not found\n");
+	return 0;
+}
diff -Naur uboot/oem/ami/standalone/nettest/phy_api.h uboot-new/oem/ami/standalone/nettest/phy_api.h
--- uboot/oem/ami/standalone/nettest/phy_api.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/phy_api.h	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,17 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PHY_API_H
+#define PHY_API_H
+
+uint32_t phy_find_addr (MAC_ENGINE *eng);
+
+#endif
diff -Naur uboot/oem/ami/standalone/nettest/phy.c uboot-new/oem/ami/standalone/nettest/phy.c
--- uboot/oem/ami/standalone/nettest/phy.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/phy.c	2020-11-20 04:00:27.000000000 -0500
@@ -0,0 +1,2398 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define PHY_C
+//#define PHY_DEBUG
+//#define PHY_DEBUG_SET_CLR
+
+#ifdef PHY_DEBUG
+#undef DbgPrn_PHYRW
+#undef DbgPrn_PHYName
+#define DbgPrn_PHYRW		1
+#define DbgPrn_PHYName		1
+#endif
+
+#ifdef PHY_DEBUG_SET_CLR
+#undef DbgPrn_PHYRW
+#define DbgPrn_PHYRW		1
+#endif
+
+
+#include "comminf.h"
+#include "swfunc.h"
+
+#include <command.h>
+#include <common.h>
+
+#include "phy.h"
+
+#include "phy_tbl.h"
+#include "mem_io.h"
+
+//#define RTK_DEBUG
+#define RTK_DBG_GPIO		BIT(22)
+#ifdef RTK_DEBUG
+#define RTK_DBG_PRINTF		printf
+#else
+#define RTK_DBG_PRINTF(...)
+#endif
+
+static void rtk_dbg_gpio_set(void)
+{
+#ifdef RTK_DEBUG		
+	GPIO_WR(GPIO_RD(0x20) | RTK_DBG_GPIO, 0x20);
+#endif	
+}
+
+static void rtk_dbg_gpio_clr(void)
+{
+#ifdef RTK_DEBUG		
+	GPIO_WR(GPIO_RD(0x20) & ~RTK_DBG_GPIO, 0x20);
+#endif	
+}
+
+static void rtk_dbg_gpio_init(void)
+{
+#ifdef RTK_DEBUG
+	GPIO_WR(GPIO_RD(0x24) | RTK_DBG_GPIO, 0x24);
+
+	rtk_dbg_gpio_set();
+#endif	
+}
+
+//------------------------------------------------------------
+// PHY R/W basic
+//------------------------------------------------------------
+void phy_write (MAC_ENGINE *eng, int index, uint32_t data) 
+{
+	int timeout = 0;
+
+	if (eng->env.is_new_mdio_reg[eng->run.mdio_idx]) {
+#ifdef CONFIG_ASPEED_AST2600
+		writel(data | MAC_PHYWr_New | (eng->phy.Adr << 21) |
+			   (index << 16),
+		       eng->run.mdio_base);
+#else
+		writel(data | MAC_PHYWr_New | (eng->phy.Adr << 5) | index,
+		       eng->run.mdio_base);
+#endif
+		/* check time-out */
+		while(readl(eng->run.mdio_base) & MAC_PHYBusy_New) {
+			if (++timeout > TIME_OUT_PHY_RW) {
+				if (!eng->run.tm_tx_only)
+					PRINTF(FP_LOG,
+					       "[PHY-Write] Time out: %08x\n",
+					       readl(eng->run.mdio_base));
+
+				FindErr(eng, Err_Flag_PHY_TimeOut_RW);
+				break;
+			}
+		}
+	} else {
+		writel(data, eng->run.mdio_base + 0x4);
+		writel(MDC_Thres | MAC_PHYWr | (eng->phy.Adr << 16) |
+				     ((index & 0x1f) << 21), eng->run.mdio_base);
+
+		while (readl(eng->run.mdio_base) & MAC_PHYWr) {
+			if (++timeout > TIME_OUT_PHY_RW) {
+				if (!eng->run.tm_tx_only)
+					PRINTF(FP_LOG,
+					       "[PHY-Write] Time out: %08x\n",
+					       readl(eng->run.mdio_base));
+
+				FindErr(eng, Err_Flag_PHY_TimeOut_RW);
+				break;
+			}
+		}
+	} // End if (eng->env.new_mdio_reg)
+
+	if (DbgPrn_PHYRW) {
+		printf("[Wr ]%02d: 0x%04x (%02d:%08x)\n", index, data,
+		       eng->phy.Adr, eng->run.mdio_base);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG, "[Wr ]%02d: 0x%04x (%02d:%08x)\n", index,
+			       data, eng->phy.Adr, eng->run.mdio_base);
+	}
+
+} // End void phy_write (int adr, uint32_t data)
+
+//------------------------------------------------------------
+uint16_t phy_read (MAC_ENGINE *eng, int index) 
+{
+	uint32_t read_value;
+	int timeout = 0;
+
+	if (index > 0x1f) {
+		printf("invalid PHY register index: 0x%02x\n", index);
+		FindErr(eng, Err_Flag_PHY_TimeOut_RW);
+		return 0;
+	}
+
+	if (eng->env.is_new_mdio_reg[eng->run.mdio_idx]) {
+#ifdef CONFIG_ASPEED_AST2600
+		writel(MAC_PHYRd_New | (eng->phy.Adr << 21) | (index << 16),
+		       eng->run.mdio_base);
+#else
+		writel(MAC_PHYRd_New | (eng->phy.Adr << 5) | index,
+		       eng->run.mdio_base);
+#endif
+
+		while (readl(eng->run.mdio_base) & MAC_PHYBusy_New) {
+			if (++timeout > TIME_OUT_PHY_RW) {
+				if (!eng->run.tm_tx_only)
+					PRINTF(FP_LOG,
+					       "[PHY-Read] Time out: %08x\n",
+					       readl(eng->run.mdio_base));
+
+				FindErr(eng, Err_Flag_PHY_TimeOut_RW);
+				break;
+			}
+		}
+
+#ifdef Delay_PHYRd
+		DELAY(Delay_PHYRd);
+#endif
+		read_value = readl(eng->run.mdio_base + 0x4) & GENMASK(15, 0);
+	} else {
+		writel(MDC_Thres | MAC_PHYRd | (eng->phy.Adr << 16) |
+			   (index << 21),
+		       eng->run.mdio_base);
+
+		while (readl(eng->run.mdio_base) & MAC_PHYRd) {
+			if (++timeout > TIME_OUT_PHY_RW) {
+				if (!eng->run.tm_tx_only)
+					PRINTF(FP_LOG,
+					       "[PHY-Read] Time out: %08x\n",
+					       readl(eng->run.mdio_base));
+
+				FindErr(eng, Err_Flag_PHY_TimeOut_RW);
+				break;
+			}
+		}
+
+#ifdef Delay_PHYRd
+		DELAY(Delay_PHYRd);
+#endif
+		read_value = readl(eng->run.mdio_base + 0x4) >> 16;
+	}
+
+
+	if (DbgPrn_PHYRW) {
+		printf("[Rd ]%02d: 0x%04x (%02d:%08x)\n", index, read_value,
+		       eng->phy.Adr, eng->run.mdio_base);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG, "[Rd ]%02d: 0x%04x (%02d:%08x)\n", index,
+			       read_value, eng->phy.Adr, eng->run.mdio_base);
+	}
+
+	return (read_value);
+} // End uint16_t phy_read (MAC_ENGINE *eng, int adr)
+
+//------------------------------------------------------------
+void phy_clrset(MAC_ENGINE *eng, int adr, uint32_t clr_mask, uint32_t set_mask)
+{
+	if (DbgPrn_PHYRW) {
+		printf("[RW ]%02d: clr:0x%04x: set:0x%04x (%02d:%08x)\n", adr,
+		       clr_mask, set_mask, eng->phy.Adr, eng->run.mdio_base);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG,
+			       "[RW ]%02d: clr:0x%04x: set:0x%04x (%02d:%08x)\n",
+			       adr, clr_mask, set_mask, eng->phy.Adr,
+			       eng->run.mdio_base);
+	}
+	phy_write(eng, adr, ((phy_read(eng, adr) & (~clr_mask)) | set_mask));
+}
+
+//------------------------------------------------------------
+void phy_dump(MAC_ENGINE *eng)
+{
+	int index;
+
+	printf("[PHY%d][%d]----------------\n", eng->run.mac_idx + 1,
+	       eng->phy.Adr);
+	for (index = 0; index < 32; index++) {
+		printf("%02d: %04x ", index, phy_read(eng, index));
+
+		if ((index % 8) == 7)
+			printf("\n");
+	}
+}
+
+//------------------------------------------------------------
+static void phy_scan_id(MAC_ENGINE *eng, uint8_t option)
+{
+	int8_t phy_addr_orig;
+
+	phy_addr_orig = eng->phy.Adr;
+	for (eng->phy.Adr = 0; eng->phy.Adr < 32; eng->phy.Adr++) {
+		PRINTF(option, "[%02d] ", eng->phy.Adr);
+		PRINTF(option, "%d:%04x ", 2, phy_read(eng, 2));
+		PRINTF(option, "%d:%04x ", 3, phy_read(eng, 3));
+
+		if ((eng->phy.Adr % 4) == 3)
+			PRINTF(option, "\n");
+	}
+	eng->phy.Adr = phy_addr_orig;
+}
+
+//------------------------------------------------------------
+void phy_delay (int dt) 
+{
+	rtk_dbg_gpio_clr();
+
+#ifdef PHY_DEBUG
+        printf("delay %d ms\n", dt);
+#endif
+        DELAY(dt);
+	rtk_dbg_gpio_set();
+}
+
+//------------------------------------------------------------
+// PHY IC basic
+//------------------------------------------------------------
+void phy_basic_setting(MAC_ENGINE *eng)
+{
+	phy_clrset(eng, 0, 0x7140, eng->phy.PHY_00h);
+
+	if (DbgPrn_PHYRW) {
+		printf("[Set]00: 0x%04x (%02d:%08x)\n",
+		       phy_read(eng, PHY_REG_BMCR), eng->phy.Adr,
+		       eng->run.mdio_base);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG, "[Set]00: 0x%04x (%02d:%08x)\n",
+			       phy_read(eng, PHY_REG_BMCR), eng->phy.Adr,
+			       eng->run.mdio_base);
+	}
+}
+
+//------------------------------------------------------------
+void phy_wait_reset_done(MAC_ENGINE *eng)
+{
+	int timeout = 0;
+
+	while (phy_read(eng, PHY_REG_BMCR) & 0x8000) {
+		if (++timeout > TIME_OUT_PHY_Rst) {
+			if (!eng->run.tm_tx_only)
+				PRINTF(FP_LOG, "[PHY-Reset] Time out: %08x\n",
+				       readl(eng->run.mdio_base));
+
+			FindErr(eng, Err_Flag_PHY_TimeOut_Rst);
+			break;
+		}
+	} //wait Rst Done
+
+	if (DbgPrn_PHYRW) {
+		printf("[Clr]00: 0x%04x (%02d:%08x)\n",
+		       phy_read(eng, PHY_REG_BMCR), eng->phy.Adr,
+		       eng->run.mdio_base);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG, "[Clr]00: 0x%04x (%02d:%08x)\n",
+			       phy_read(eng, PHY_REG_BMCR), eng->phy.Adr,
+			       eng->run.mdio_base);
+	}
+#ifdef Delay_PHYRst
+	DELAY(Delay_PHYRst);
+#endif
+}
+
+//------------------------------------------------------------
+static void phy_reset(MAC_ENGINE *eng)
+{
+	phy_basic_setting(eng);
+
+	//phy_clrset(eng, 0, 0x0000, 0x8000 | eng->phy.PHY_00h);
+	phy_clrset(eng, 0, 0x7140, 0x8000 | eng->phy.PHY_00h);
+	//phy_write(eng, 0, 0x8000); //clr set//Rst PHY
+	phy_wait_reset_done(eng);
+
+	phy_basic_setting(eng);
+#ifdef Delay_PHYRst
+	DELAY(Delay_PHYRst);
+#endif
+}
+
+//------------------------------------------------------------
+void phy_check_register (MAC_ENGINE *eng, uint32_t adr, uint32_t check_mask, uint32_t check_value, uint32_t hit_number, char *runname) {
+        uint16_t     wait_phy_ready = 0;
+        uint16_t     hit_count = 0;
+
+        while ( wait_phy_ready < 1000 ) {
+                if ( (phy_read( eng, adr ) & check_mask) == check_value ) {
+                        if ( ++hit_count >= hit_number ) {
+                                break;
+                        }
+                        else {
+                                phy_delay(1);
+                        }
+                } else {
+                        hit_count = 0;
+                        wait_phy_ready++;
+                        phy_delay(10);
+                }
+        }
+        if ( hit_count < hit_number ) {
+                printf("Timeout: %s\n", runname);
+        }
+}
+
+//------------------------------------------------------------
+// PHY IC
+//------------------------------------------------------------
+void recov_phy_marvell (MAC_ENGINE *eng) {//88E1111
+        if ( eng->run.tm_tx_only ) {
+        }
+        else if ( eng->phy.loopback ) {
+        }
+        else {
+		if (eng->run.speed_sel[0]) {
+			phy_write(eng, 9, eng->phy.PHY_09h);
+
+			phy_reset(eng);
+
+			phy_write(eng, 29, 0x0007);
+			phy_clrset(eng, 30, 0x0008, 0x0000); //clr set
+			phy_write(eng, 29, 0x0010);
+			phy_clrset(eng, 30, 0x0002, 0x0000); //clr set
+			phy_write(eng, 29, 0x0012);
+			phy_clrset(eng, 30, 0x0001, 0x0000); //clr set
+
+			phy_write(eng, 18, eng->phy.PHY_12h);
+		}
+	}
+}
+
+//------------------------------------------------------------
+void phy_marvell (MAC_ENGINE *eng) 
+{//88E1111
+
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Marvell] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        if ( eng->run.tm_tx_only ) {
+                phy_reset( eng );
+        }
+        else if ( eng->phy.loopback ) {
+                phy_reset( eng );
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        eng->phy.PHY_09h = phy_read( eng, PHY_GBCR );
+                        eng->phy.PHY_12h = phy_read( eng, PHY_INER );
+                        phy_write( eng, 18, 0x0000 );
+                        phy_clrset( eng,  9, 0x0000, 0x1800 );//clr set
+                }
+
+                phy_reset( eng );
+
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 29, 0x0007 );
+                        phy_clrset( eng, 30, 0x0000, 0x0008 );//clr set
+                        phy_write( eng, 29, 0x0010 );
+                        phy_clrset( eng, 30, 0x0000, 0x0002 );//clr set
+                        phy_write( eng, 29, 0x0012 );
+                        phy_clrset( eng, 30, 0x0000, 0x0001 );//clr set
+                }
+        }
+
+        if ( !eng->phy.loopback )
+                phy_check_register ( eng, 17, 0x0400, 0x0400, 1, "wait 88E1111 link-up");
+//      Retry = 0;
+//      do {
+//              eng->phy.PHY_11h = phy_read( eng, PHY_SR );
+//      } while ( !( ( eng->phy.PHY_11h & 0x0400 ) | eng->phy.loopback | ( Retry++ > 20 ) ) );
+}
+
+//------------------------------------------------------------
+void recov_phy_marvell0 (MAC_ENGINE *eng) {//88E1310
+        if ( eng->run.tm_tx_only ) {
+        }
+        else if ( eng->phy.loopback ) {
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 22, 0x0006 );
+                        phy_clrset( eng, 16, 0x0020, 0x0000 );//clr set
+                        phy_write( eng, 22, 0x0000 );
+                }
+        }
+}
+
+//------------------------------------------------------------
+void phy_marvell0 (MAC_ENGINE *eng) {//88E1310
+//      int        Retry;
+
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Marvell] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        phy_write( eng, 22, 0x0002 );
+
+        eng->phy.PHY_15h = phy_read( eng, 21 );
+        if ( eng->phy.PHY_15h & 0x0030 ) {
+                printf("\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15_2:%04x]\n\n", eng->phy.PHY_15h);
+                if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15_2:%04x]\n\n", eng->phy.PHY_15h );
+                if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15_2:%04x]\n\n", eng->phy.PHY_15h );
+
+                phy_write( eng, 21, eng->phy.PHY_15h & 0xffcf ); // Set [5]Rx Dly, [4]Tx Dly to 0
+        }
+phy_read( eng, 21 ); // v069
+        phy_write( eng, 22, 0x0000 );
+
+        if ( eng->run.tm_tx_only ) {
+                phy_reset( eng );
+        }
+        else if ( eng->phy.loopback ) {
+                phy_write( eng, 22, 0x0002 );
+
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_clrset( eng, 21, 0x6040, 0x0040 );//clr set
+                }
+                else if ( eng->run.speed_sel[ 1 ] ) {
+                        phy_clrset( eng, 21, 0x6040, 0x2000 );//clr set
+                }
+                else {
+                        phy_clrset( eng, 21, 0x6040, 0x0000 );//clr set
+                }
+                phy_write( eng, 22, 0x0000 );
+                phy_reset(  eng  );
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 22, 0x0006 );
+                        phy_clrset( eng, 16, 0x0000, 0x0020 );//clr set
+phy_read( eng, 16 ); // v069
+                        phy_write( eng, 22, 0x0000 );
+                }
+
+                phy_reset( eng );
+phy_read( eng, 0 ); // v069
+        }
+
+        if ( !eng->phy.loopback )
+                phy_check_register ( eng, 17, 0x0400, 0x0400, 1, "wait 88E1310 link-up");
+//      Retry = 0;
+//      do {
+//              eng->phy.PHY_11h = phy_read( eng, PHY_SR );
+//      } while ( !( ( eng->phy.PHY_11h & 0x0400 ) | eng->phy.loopback | ( Retry++ > 20 ) ) );
+}
+
+//------------------------------------------------------------
+void recov_phy_marvell1 (MAC_ENGINE *eng) {//88E6176
+        int8_t       phy_addr_org;
+
+        phy_addr_org = eng->phy.Adr;
+        for ( eng->phy.Adr = 16; eng->phy.Adr <= 22; eng->phy.Adr++ ) {
+                if ( eng->run.tm_tx_only ) {
+                }
+                else {
+                        phy_write( eng,  6, eng->phy.PHY_06hA[eng->phy.Adr-16] );//06h[5]P5 loopback, 06h[6]P6 loopback
+                }
+        }
+        for ( eng->phy.Adr = 21; eng->phy.Adr <= 22; eng->phy.Adr++ ) {
+                phy_write( eng,  1, 0x0003 ); //01h[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+        }
+        eng->phy.Adr = phy_addr_org;
+}
+
+//------------------------------------------------------------
+void phy_marvell1 (MAC_ENGINE *eng) {//88E6176
+//      uint32_t      PHY_01h;
+        int8_t       phy_addr_org;
+
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Marvell] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        if ( eng->run.tm_tx_only ) {
+                printf("This mode doesn't support in 88E6176.\n");
+        } else {
+                //The 88E6176 is switch with 7 Port(P0~P6) and the PHYAdr will be fixed at 0x10~0x16, and only P5/P6 can be connected to the MAC.
+                //Therefor, the 88E6176 only can run the internal loopback.
+                phy_addr_org = eng->phy.Adr;
+                for ( eng->phy.Adr = 16; eng->phy.Adr <= 20; eng->phy.Adr++ ) {
+                        eng->phy.PHY_06hA[eng->phy.Adr-16] = phy_read( eng, PHY_ANER );
+                        phy_write( eng,  6, 0x0000 );//06h[5]P5 loopback, 06h[6]P6 loopback
+                }
+
+                for ( eng->phy.Adr = 21; eng->phy.Adr <= 22; eng->phy.Adr++ ) {
+//                      PHY_01h = phy_read( eng, PHY_REG_BMSR );
+//                      if      ( eng->run.speed_sel[ 0 ] ) phy_write( eng,  1, (PHY_01h & 0xfffc) | 0x0002 );//[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+//                      else if ( eng->run.speed_sel[ 1 ] ) phy_write( eng,  1, (PHY_01h & 0xfffc) | 0x0001 );//[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+//                      else                              phy_write( eng,  1, (PHY_01h & 0xfffc)          );//[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+                        if      ( eng->run.speed_sel[ 0 ] ) phy_write( eng,  1, 0x0002 );//01h[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+                        else if ( eng->run.speed_sel[ 1 ] ) phy_write( eng,  1, 0x0001 );//01h[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+                        else                                phy_write( eng,  1, 0x0000 );//01h[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+
+                        eng->phy.PHY_06hA[eng->phy.Adr-16] = phy_read( eng, PHY_ANER );
+                        if ( eng->phy.Adr == 21 ) phy_write( eng,  6, 0x0020 );//06h[5]P5 loopback, 06h[6]P6 loopback
+                        else                      phy_write( eng,  6, 0x0040 );//06h[5]P5 loopback, 06h[6]P6 loopback
+                }
+                eng->phy.Adr = phy_addr_org;
+        }
+}
+
+//------------------------------------------------------------
+void recov_phy_marvell2 (MAC_ENGINE *eng) {//88E1512//88E15 10/12/14/18
+        if ( eng->run.tm_tx_only ) {
+        }
+        else if ( eng->phy.loopback ) {
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        // Enable Stub Test
+                        // switch page 6
+                        phy_write( eng, 22, 0x0006 );
+                        phy_clrset( eng, 18, 0x0008, 0x0000 );//clr set
+                        phy_write( eng, 22, 0x0000 );
+                }
+        }
+}
+
+//------------------------------------------------------------
+void phy_marvell2 (MAC_ENGINE *eng) {//88E1512//88E15 10/12/14/18
+//      int        Retry = 0;
+//      uint32_t      temp_reg;
+
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Marvell] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        // switch page 2
+        phy_write( eng, 22, 0x0002 );
+        eng->phy.PHY_15h = phy_read( eng, 21 );
+        if ( eng->phy.PHY_15h & 0x0030 ) {
+                printf("\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15h_2:%04x]\n\n", eng->phy.PHY_15h);
+                if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15h_2:%04x]\n\n", eng->phy.PHY_15h );
+                if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15h_2:%04x]\n\n", eng->phy.PHY_15h );
+
+                phy_write( eng, 21, eng->phy.PHY_15h & 0xffcf );
+        }
+        phy_write( eng, 22, 0x0000 );
+
+
+        if ( eng->run.tm_tx_only ) {
+                phy_reset( eng );
+        }
+        else if ( eng->phy.loopback ) {
+                // Internal loopback funciton only support in copper mode
+                // switch page 18
+                phy_write( eng, 22, 0x0012 );
+                eng->phy.PHY_14h = phy_read( eng, 20 );
+                // Change mode to Copper mode
+//              if ( eng->phy.PHY_14h & 0x0020 ) {
+                if ( ( eng->phy.PHY_14h & 0x003f ) != 0x0010 ) {
+                        printf("\n\n[Warning] Internal loopback funciton only support in copper mode[%04x]\n\n", eng->phy.PHY_14h);
+                        if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Internal loopback funciton only support in copper mode[%04x]\n\n", eng->phy.PHY_14h);
+                        if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Internal loopback funciton only support in copper mode[%04x]\n\n", eng->phy.PHY_14h);
+
+                        phy_write( eng, 20, ( eng->phy.PHY_14h & 0xffc0 ) | 0x8010 );
+                        // do software reset
+                        phy_check_register ( eng, 20, 0x8000, 0x0000, 1, "wait 88E15 10/12/14/18 mode reset");
+//                      do {
+//                              temp_reg = phy_read( eng, 20 );
+//                      } while ( ( (temp_reg & 0x8000) == 0x8000 ) & (Retry++ < 20) );
+                }
+
+                // switch page 2
+                phy_write( eng, 22, 0x0002 );
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_clrset( eng, 21, 0x2040, 0x0040 );//clr set
+                }
+                else if ( eng->run.speed_sel[ 1 ] ) {
+                        phy_clrset( eng, 21, 0x2040, 0x2000 );//clr set
+                }
+                else {
+                        phy_clrset( eng, 21, 0x2040, 0x0000 );//clr set
+                }
+                phy_write( eng, 22, 0x0000 );
+
+                phy_reset( eng );
+
+                //Internal loopback at 100Mbps need delay 400~500 ms
+//              DELAY( 400 );//Still fail at 100Mbps
+//              DELAY( 500 );//All Pass
+                if ( !eng->run.speed_sel[ 0 ] ) {
+                        phy_check_register ( eng, 17, 0x0040, 0x0040, 10, "wait 88E15 10/12/14/18 link-up");
+                        phy_check_register ( eng, 17, 0x0040, 0x0000, 10, "wait 88E15 10/12/14/18 link-up");
+                        phy_check_register ( eng, 17, 0x0040, 0x0040, 10, "wait 88E15 10/12/14/18 link-up");
+                }
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        // Enable Stub Test
+                        // switch page 6
+                        phy_write( eng, 22, 0x0006 );
+                        phy_clrset( eng, 18, 0x0000, 0x0008 );//clr set
+                        phy_write( eng, 22, 0x0000 );
+                }
+
+                phy_reset( eng );
+                phy_check_register ( eng, 17, 0x0400, 0x0400, 10, "wait 88E15 10/12/14/18 link-up");
+        }
+
+//      if ( !eng->phy.loopback )
+////    if ( !eng->run.tm_tx_only )
+//              phy_check_register ( eng, 17, 0x0400, 0x0400, 10, "wait 88E15 10/12/14/18 link-up");
+////    Retry = 0;
+////    do {
+////            eng->phy.PHY_11h = phy_read( eng, PHY_SR );
+////    } while ( !( ( eng->phy.PHY_11h & 0x0400 ) | eng->phy.loopback | ( Retry++ > 20 ) ) );
+}
+
+//------------------------------------------------------------
+void phy_marvell3 (MAC_ENGINE *eng) 
+{//88E3019
+
+        if ( DbgPrn_PHYName ) {
+                printf("--->(%04x %04x)[Marvell] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+                if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "--->(%04x %04x)[Marvell] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+        }
+
+        //Reg1ch[11:10]: MAC Interface Mode
+        // 00 => RGMII where receive clock trnasitions when data transitions
+        // 01 => RGMII where receive clock trnasitions when data is stable
+        // 10 => RMII
+        // 11 => MII
+        eng->phy.PHY_1ch = phy_read( eng, 28 );
+        if (eng->run.is_rgmii) {
+                if ( ( eng->phy.PHY_1ch & 0x0c00 ) != 0x0000 ) {
+                        printf("\n\n[Warning] Register 28, bit 10~11 must be 0 (RGMIIRX Edge-align Mode)[Reg1ch:%04x]\n\n", eng->phy.PHY_1ch);
+                        eng->phy.PHY_1ch = ( eng->phy.PHY_1ch & 0xf3ff ) | 0x0000;
+                        phy_write( eng, 28, eng->phy.PHY_1ch );
+                }
+        } else {
+                if ( ( eng->phy.PHY_1ch & 0x0c00 ) != 0x0800 ) {
+                        printf("\n\n[Warning] Register 28, bit 10~11 must be 2 (RMII Mode)[Reg1ch:%04x]\n\n", eng->phy.PHY_1ch);
+                        eng->phy.PHY_1ch = ( eng->phy.PHY_1ch & 0xf3ff ) | 0x0800;
+                        phy_write( eng, 28, eng->phy.PHY_1ch );
+                }
+        }
+
+        if ( eng->run.tm_tx_only ) {
+                phy_reset( eng );
+        }
+        else if ( eng->phy.loopback ) {
+                phy_reset( eng );
+        }
+        else {
+                phy_reset( eng );
+        }
+
+        phy_check_register ( eng, 17, 0x0400, 0x0400, 1, "wait 88E3019 link-up");
+}
+
+//------------------------------------------------------------
+void phy_broadcom (MAC_ENGINE *eng) {//BCM5221
+    uint32_t      reg;
+
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Broadcom] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        phy_reset( eng );
+
+        if ( eng->run.TM_IEEE ) {
+                if ( eng->run.ieee_sel == 0 ) {
+                        phy_write( eng, 25, 0x1f01 );//Force MDI  //Measuring from channel A
+                }
+                else {
+                        phy_clrset( eng, 24, 0x0000, 0x4000 );//clr set//Force Link
+//                      phy_write( eng,  0, eng->phy.PHY_00h );
+//                      phy_write( eng, 30, 0x1000 );
+                }
+        }
+        else
+        {
+                // we can check link status from register 0x18
+                if ( eng->run.speed_sel[ 1 ] ) {
+                        do {
+                                reg = phy_read( eng, 0x18 ) & 0xF;
+                        } while ( reg != 0x7 );
+                }
+                else {
+                        do {
+                        reg = phy_read( eng, 0x18 ) & 0xF;
+                        } while ( reg != 0x1 );
+                }
+        }
+}
+
+//------------------------------------------------------------
+void recov_phy_broadcom0 (MAC_ENGINE *eng) {//BCM54612
+        phy_write( eng,  0, eng->phy.PHY_00h );
+        phy_write( eng,  9, eng->phy.PHY_09h );
+//      phy_write( eng, 24, eng->phy.PHY_18h | 0xf007 );//write reg 18h, shadow value 111
+//      phy_write( eng, 28, eng->phy.PHY_1ch | 0x8c00 );//write reg 1Ch, shadow value 00011
+
+        if ( eng->run.tm_tx_only ) {
+        }
+        else if ( eng->phy.loopback ) {
+                phy_write( eng,  0, eng->phy.PHY_00h );
+        }
+        else {
+        }
+}
+
+//------------------------------------------------------------
+//internal loop 1G  : no  loopback stub
+//internal loop 100M: Don't support(?)
+//internal loop 10M : Don't support(?)
+void phy_broadcom0 (MAC_ENGINE *eng) {//BCM54612
+        uint32_t      PHY_new;
+
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Broadcom] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+	phy_reset(eng);
+
+        eng->phy.PHY_00h = phy_read( eng, PHY_REG_BMCR );
+        eng->phy.PHY_09h = phy_read( eng, PHY_GBCR );
+
+	phy_write( eng, 0, eng->phy.PHY_00h & ~BIT(10));
+
+        phy_write( eng, 24, 0x7007 );//read reg 18h, shadow value 111
+        eng->phy.PHY_18h = phy_read( eng, 24 );
+        phy_write( eng, 28, 0x0c00 );//read reg 1Ch, shadow value 00011
+        eng->phy.PHY_1ch = phy_read( eng, 28 );
+
+        if ( eng->phy.PHY_18h & 0x0100 ) {
+                PHY_new = ( eng->phy.PHY_18h & 0x0af0 ) | 0xf007;
+                printf("\n\n[Warning] Shadow value 111, Register 24, bit 8 must be 0 [Reg18h_7:%04x->%04x]\n\n", eng->phy.PHY_18h, PHY_new);
+                if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Shadow value 111, Register 24, bit 8 must be 0 [Reg18h_7:%04x->%04x]\n\n", eng->phy.PHY_18h, PHY_new );
+                if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Shadow value 111, Register 24, bit 8 must be 0 [Reg18h_7:%04x->%04x]\n\n", eng->phy.PHY_18h, PHY_new );
+
+                phy_write( eng, 24, PHY_new ); // Disable RGMII RXD to RXC Skew
+        }
+        if ( eng->phy.PHY_1ch & 0x0200 ) {
+                PHY_new = ( eng->phy.PHY_1ch & 0x0000 ) | 0x8c00;
+                printf("\n\n[Warning] Shadow value 00011, Register 28, bit 9 must be 0 [Reg1ch_3:%04x->%04x]\n\n", eng->phy.PHY_1ch, PHY_new);
+                if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Shadow value 00011, Register 28, bit 9 must be 0 [Reg1ch_3:%04x->%04x]\n\n", eng->phy.PHY_1ch, PHY_new );
+                if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Shadow value 00011, Register 28, bit 9 must be 0 [Reg1ch_3:%04x->%04x]\n\n", eng->phy.PHY_1ch, PHY_new );
+
+                phy_write( eng, 28, PHY_new );// Disable GTXCLK Clock Delay Enable
+        }
+
+        if ( eng->run.tm_tx_only ) {
+                phy_basic_setting( eng );
+        }
+        else if ( eng->phy.loopback ) {
+                phy_basic_setting( eng );
+
+                // Enable Internal Loopback mode
+                // Page 58, BCM54612EB1KMLG_Spec.pdf
+                phy_write( eng,  0, 0x5140 );
+#ifdef Delay_PHYRst
+                phy_delay( Delay_PHYRst );
+#endif
+                /* Only 1G Test is PASS, 100M and 10M is 0 @20130619 */
+
+// Waiting for BCM FAE's response
+//              if ( eng->run.speed_sel[ 0 ] ) {
+//                      // Speed 1G
+//                      // Enable Internal Loopback mode
+//                      // Page 58, BCM54612EB1KMLG_Spec.pdf
+//                      phy_write( eng,  0, 0x5140 );
+//              }
+//              else if ( eng->run.speed_sel[ 1 ] ) {
+//                      // Speed 100M
+//                      // Enable Internal Loopback mode
+//                      // Page 58, BCM54612EB1KMLG_Spec.pdf
+//                      phy_write( eng,  0, 0x7100 );
+//                      phy_write( eng, 30, 0x1000 );
+//              }
+//              else if ( eng->run.speed_sel[ 2 ] ) {
+//                      // Speed 10M
+//                      // Enable Internal Loopback mode
+//                      // Page 58, BCM54612EB1KMLG_Spec.pdf
+//                      phy_write( eng,  0, 0x5100 );
+//                      phy_write( eng, 30, 0x1000 );
+//              }
+//
+#ifdef Delay_PHYRst
+//              phy_delay( Delay_PHYRst );
+#endif
+        }
+        else {
+
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        // Page 60, BCM54612EB1KMLG_Spec.pdf
+                        // need to insert loopback plug
+                        phy_write( eng,  9, 0x1800 );
+                        phy_write( eng,  0, 0x0140 );
+                        phy_write( eng, 24, 0x8400 ); // Enable Transmit test mode
+                }
+                else if ( eng->run.speed_sel[ 1 ] ) {
+                        // Page 60, BCM54612EB1KMLG_Spec.pdf
+                        // need to insert loopback plug
+                        phy_write( eng,  0, 0x2100 );
+                        phy_write( eng, 24, 0x8400 ); // Enable Transmit test mode
+                }
+                else {
+                        // Page 60, BCM54612EB1KMLG_Spec.pdf
+                        // need to insert loopback plug
+                        phy_write( eng,  0, 0x0100 );
+                        phy_write( eng, 24, 0x8400 ); // Enable Transmit test mode
+                }
+#ifdef Delay_PHYRst
+                phy_delay( Delay_PHYRst );
+                phy_delay( Delay_PHYRst );
+#endif                
+        }
+}
+
+//------------------------------------------------------------
+void phy_realtek (MAC_ENGINE *eng) {//RTL8201N
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Realtek] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        phy_reset( eng );
+}
+
+//------------------------------------------------------------
+//internal loop 100M: Don't support
+//internal loop 10M : no  loopback stub
+void phy_realtek0 (MAC_ENGINE *eng) {//RTL8201E
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Realtek] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        eng->phy.RMIICK_IOMode |= PHY_Flag_RMIICK_IOMode_RTL8201E;
+
+        phy_reset( eng );
+
+        eng->phy.PHY_19h = phy_read( eng, 25 );
+        //Check RMII Mode
+        if ( ( eng->phy.PHY_19h & 0x0400 ) == 0x0 ) {
+                phy_write( eng, 25, eng->phy.PHY_19h | 0x0400 );
+                printf("\n\n[Warning] Register 25, bit 10 must be 1 [Reg19h:%04x]\n\n", eng->phy.PHY_19h);
+                if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Register 25, bit 10 must be 1 [Reg19h:%04x]\n\n", eng->phy.PHY_19h );
+                if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Register 25, bit 10 must be 1 [Reg19h:%04x]\n\n", eng->phy.PHY_19h );
+        }
+        //Check TXC Input/Output Direction
+        if ( eng->arg.ctrl.b.rmii_phy_in == 0 ) {
+                if ( ( eng->phy.PHY_19h & 0x0800 ) == 0x0800 ) {
+                        phy_write( eng, 25, eng->phy.PHY_19h & 0xf7ff );
+                        printf("\n\n[Warning] Register 25, bit 11 must be 0 (TXC should be output mode)[Reg19h:%04x]\n\n", eng->phy.PHY_19h);
+                        if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Register 25, bit 11 must be 0 (TXC should be output mode)[Reg19h:%04x]\n\n", eng->phy.PHY_19h );
+                        if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Register 25, bit 11 must be 0 (TXC should be output mode)[Reg19h:%04x]\n\n", eng->phy.PHY_19h );
+                }
+        } else {
+                if ( ( eng->phy.PHY_19h & 0x0800 ) == 0x0000 ) {
+                        phy_write( eng, 25, eng->phy.PHY_19h | 0x0800 );
+                        printf("\n\n[Warning] Register 25, bit 11 must be 1 (TXC should be input mode)[Reg19h:%04x]\n\n", eng->phy.PHY_19h);
+                        if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Register 25, bit 11 must be 1 (TXC should be input mode)[Reg19h:%04x]\n\n", eng->phy.PHY_19h );
+                        if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Register 25, bit 11 must be 1 (TXC should be input mode)[Reg19h:%04x]\n\n", eng->phy.PHY_19h );
+                }
+        }
+
+        if ( eng->run.TM_IEEE ) {
+                phy_write( eng, 31, 0x0001 );
+                if ( eng->run.ieee_sel == 0 ) {
+                        phy_write( eng, 25, 0x1f01 );//Force MDI  //Measuring from channel A
+                }
+                else {
+                        phy_write( eng, 25, 0x1f00 );//Force MDIX //Measuring from channel B
+                }
+                phy_write( eng, 31, 0x0000 );
+        }
+}
+
+//------------------------------------------------------------
+void recov_phy_realtek1 (MAC_ENGINE *eng) {//RTL8211D
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        if ( eng->run.speed_sel[ 0 ] ) {
+                                if ( eng->run.ieee_sel == 0 ) {//Test Mode 1
+                                        //Rev 1.2
+                                        phy_write( eng, 31, 0x0002 );
+                                        phy_write( eng,  2, 0xc203 );
+                                        phy_write( eng, 31, 0x0000 );
+                                        phy_write( eng,  9, 0x0000 );
+                                }
+                                else {//Test Mode 4
+                                        //Rev 1.2
+                                        phy_write( eng, 31, 0x0000 );
+                                        phy_write( eng,  9, 0x0000 );
+                                }
+                        }
+                        else if ( eng->run.speed_sel[ 1 ] ) {
+                                //Rev 1.2
+                                phy_write( eng, 23, 0x2100 );
+                                phy_write( eng, 16, 0x016e );
+                        }
+                        else {
+                                //Rev 1.2
+                                phy_write( eng, 31, 0x0006 );
+                                phy_write( eng,  0, 0x5a00 );
+                                phy_write( eng, 31, 0x0000 );
+                        }
+                } else {
+                        phy_reset( eng );
+                } // End if ( eng->run.TM_IEEE )
+        }
+        else if ( eng->phy.loopback ) {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 31, 0x0000 ); // new in Rev. 1.6
+                        phy_write( eng,  0, 0x1140 ); // new in Rev. 1.6
+                        phy_write( eng, 20, 0x8040 ); // new in Rev. 1.6
+                }
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 31, 0x0001 );
+                        phy_write( eng,  3, 0xdf41 );
+                        phy_write( eng,  2, 0xdf20 );
+                        phy_write( eng,  1, 0x0140 );
+                        phy_write( eng,  0, 0x00bb );
+                        phy_write( eng,  4, 0xb800 );
+                        phy_write( eng,  4, 0xb000 );
+
+                        phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng, 26, 0x0020 ); // Rev. 1.2
+                        phy_write( eng, 26, 0x0040 ); // new in Rev. 1.6
+                        phy_write( eng,  0, 0x1140 );
+//                      phy_write( eng, 21, 0x0006 ); // Rev. 1.2
+                        phy_write( eng, 21, 0x1006 ); // new in Rev. 1.6
+                        phy_write( eng, 23, 0x2100 );
+//              }
+//              else if ( eng->run.speed_sel[ 1 ] ) {//option
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0200 );
+//                      phy_write( eng,  0, 0x1200 );
+//              }
+//              else if ( eng->run.speed_sel[ 2 ] ) {//option
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0200 );
+//                      phy_write( eng,  4, 0x05e1 );
+//                      phy_write( eng,  0, 0x1200 );
+                }
+                phy_reset( eng );
+                phy_delay(2000);
+        } // End if ( eng->run.tm_tx_only )
+} // End void recov_phy_realtek1 (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+//internal loop 1G  : no  loopback stub
+//internal loop 100M: no  loopback stub
+//internal loop 10M : no  loopback stub
+void phy_realtek1 (MAC_ENGINE *eng) {//RTL8211D
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Realtek] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        if ( eng->run.speed_sel[ 0 ] ) {
+                                if ( eng->run.ieee_sel == 0 ) {//Test Mode 1
+                                        //Rev 1.2
+                                        phy_write( eng, 31, 0x0002 );
+                                        phy_write( eng,  2, 0xc22b );
+                                        phy_write( eng, 31, 0x0000 );
+                                        phy_write( eng,  9, 0x2000 );
+                                }
+                                else {//Test Mode 4
+                                        //Rev 1.2
+                                        phy_write( eng, 31, 0x0000 );
+                                        phy_write( eng,  9, 0x8000 );
+                                }
+                        }
+                        else if ( eng->run.speed_sel[ 1 ] ) {
+                                if ( eng->run.ieee_sel == 0 ) {//From Channel A
+                                        //Rev 1.2
+                                        phy_write( eng, 23, 0xa102 );
+                                        phy_write( eng, 16, 0x01ae );//MDI
+                                }
+                                else {//From Channel B
+                                        //Rev 1.2
+                                        phy_clrset( eng, 17, 0x0008, 0x0000 ); // clr set
+                                        phy_write( eng, 23, 0xa102 );         // MDI
+                                        phy_write( eng, 16, 0x010e );
+                                }
+                        }
+                        else {
+                                if ( eng->run.ieee_sel == 0 ) {//Diff. Voltage/TP-IDL/Jitter: Pseudo-random pattern
+                                        phy_write( eng, 31, 0x0006 );
+                                        phy_write( eng,  0, 0x5a21 );
+                                        phy_write( eng, 31, 0x0000 );
+                                }
+                                else if ( eng->run.ieee_sel == 1 ) {//Harmonic: pattern
+                                        phy_write( eng, 31, 0x0006 );
+                                        phy_write( eng,  2, 0x05ee );
+                                        phy_write( eng,  0, 0xff21 );
+                                        phy_write( eng, 31, 0x0000 );
+                                }
+                                else {//Harmonic: 00 pattern
+                                        phy_write( eng, 31, 0x0006 );
+                                        phy_write( eng,  2, 0x05ee );
+                                        phy_write( eng,  0, 0x0021 );
+                                        phy_write( eng, 31, 0x0000 );
+                                }
+                        }
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+        else if ( eng->phy.loopback ) {
+                phy_reset( eng );
+
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 20, 0x0042 );//new in Rev. 1.6
+                }
+        }
+        else {
+        // refer to RTL8211D Register for Manufacture Test_V1.6.pdf
+        // MDI loop back
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 31, 0x0001 );
+                        phy_write( eng,  3, 0xff41 );
+                        phy_write( eng,  2, 0xd720 );
+                        phy_write( eng,  1, 0x0140 );
+                        phy_write( eng,  0, 0x00bb );
+                        phy_write( eng,  4, 0xb800 );
+                        phy_write( eng,  4, 0xb000 );
+
+                        phy_write( eng, 31, 0x0007 );
+                        phy_write( eng, 30, 0x0040 );
+                        phy_write( eng, 24, 0x0008 );
+
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  9, 0x0300 );
+                        phy_write( eng, 26, 0x0020 );
+                        phy_write( eng,  0, 0x0140 );
+                        phy_write( eng, 23, 0xa101 );
+                        phy_write( eng, 21, 0x0200 );
+                        phy_write( eng, 23, 0xa121 );
+                        phy_write( eng, 23, 0xa161 );
+                        phy_write( eng,  0, 0x8000 );
+                        phy_wait_reset_done( eng );
+
+//                      phy_delay(200); // new in Rev. 1.6
+                        phy_delay(5000); // 20150504
+//              }
+//              else if ( eng->run.speed_sel[ 1 ] ) {//option
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0000 );
+//                      phy_write( eng,  4, 0x0061 );
+//                      phy_write( eng,  0, 0x1200 );
+//                      phy_delay(5000);
+//              }
+//              else if ( eng->run.speed_sel[ 2 ] ) {//option
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0000 );
+//                      phy_write( eng,  4, 0x05e1 );
+//                      phy_write( eng,  0, 0x1200 );
+//                      phy_delay(5000);
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+} // End void phy_realtek1 (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+void recov_phy_realtek2 (MAC_ENGINE *eng)
+{
+	RTK_DBG_PRINTF("\nClear RTL8211E [Start] =====>\n");
+
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        if ( eng->run.speed_sel[ 0 ] ) {
+                                //Rev 1.2
+                                phy_write( eng, 31, 0x0000 );
+                                phy_write( eng,  9, 0x0000 );
+                        }
+                        else if ( eng->run.speed_sel[ 1 ] ) {
+                                //Rev 1.2
+                                phy_write( eng, 31, 0x0007 );
+                                phy_write( eng, 30, 0x002f );
+                                phy_write( eng, 23, 0xd88f );
+                                phy_write( eng, 30, 0x002d );
+                                phy_write( eng, 24, 0xf050 );
+                                phy_write( eng, 31, 0x0000 );
+                                phy_write( eng, 16, 0x006e );
+                        }
+                        else {
+                                //Rev 1.2
+                                phy_write( eng, 31, 0x0006 );
+                                phy_write( eng,  0, 0x5a00 );
+                                phy_write( eng, 31, 0x0000 );
+                        }
+                        //Rev 1.2
+                        phy_write( eng, 31, 0x0005 );
+                        phy_write( eng,  5, 0x8b86 );
+                        phy_write( eng,  6, 0xe201 );
+                        phy_write( eng, 31, 0x0007 );
+                        phy_write( eng, 30, 0x0020 );
+                        phy_write( eng, 21, 0x1108 );
+                        phy_write( eng, 31, 0x0000 );
+                }
+                else {
+                }
+        }
+        else if ( eng->phy.loopback ) {
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        //Rev 1.6
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  0, 0x8000 );
+#ifdef RTK_DEBUG
+#else
+                        phy_wait_reset_done( eng );
+                        phy_delay(30);
+#endif
+
+                        phy_write( eng, 31, 0x0007 );
+                        phy_write( eng, 30, 0x0042 );
+                        phy_write( eng, 21, 0x0500 );
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  0, 0x1140 );
+                        phy_write( eng, 26, 0x0040 );
+                        phy_write( eng, 31, 0x0007 );
+                        phy_write( eng, 30, 0x002f );
+                        phy_write( eng, 23, 0xd88f );
+                        phy_write( eng, 30, 0x0023 );
+                        phy_write( eng, 22, 0x0300 );
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng, 21, 0x1006 );
+                        phy_write( eng, 23, 0x2100 );
+                }
+//              else if ( eng->run.speed_sel[ 1 ] ) {//option
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0200 );
+//                      phy_write( eng,  0, 0x1200 );
+//              }
+//              else if ( eng->run.speed_sel[ 2 ] ) {//option
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0200 );
+//                      phy_write( eng,  4, 0x05e1 );
+//                      phy_write( eng,  0, 0x1200 );
+//              }
+                else {
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  0, 0x1140 );
+                }
+#ifdef RTK_DEBUG
+#else
+                // Check register 0x11 bit10 Link OK or not OK
+                phy_check_register ( eng, 17, 0x0c02, 0x0000, 10, "clear RTL8211E");
+#endif
+        }
+
+	RTK_DBG_PRINTF("\nClear RTL8211E [End] =====>\n");
+} // End void recov_phy_realtek2 (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+//internal loop 1G  : no  loopback stub
+//internal loop 100M: no  loopback stub
+//internal loop 10M : no  loopback stub
+// for RTL8211E
+void phy_realtek2 (MAC_ENGINE *eng) 
+{
+        uint16_t     check_value;
+
+	RTK_DBG_PRINTF("\nSet RTL8211E [Start] =====>\n");
+
+	rtk_dbg_gpio_init();	
+
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Realtek] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+#ifdef RTK_DEBUG
+#else
+        phy_write( eng, 31, 0x0000 );
+        phy_clrset( eng,  0, 0x0000, 0x8000 | eng->phy.PHY_00h ); // clr set // Rst PHY
+        phy_wait_reset_done( eng );
+        phy_delay(30);
+#endif
+
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        //Rev 1.2
+                        phy_write( eng, 31, 0x0005 );
+                        phy_write( eng,  5, 0x8b86 );
+                        phy_write( eng,  6, 0xe200 );
+                        phy_write( eng, 31, 0x0007 );
+                        phy_write( eng, 30, 0x0020 );
+                        phy_write( eng, 21, 0x0108 );
+                        phy_write( eng, 31, 0x0000 );
+
+                        if ( eng->run.speed_sel[ 0 ] ) {
+                                //Rev 1.2
+                                phy_write( eng, 31, 0x0000 );
+
+                                if ( eng->run.ieee_sel == 0 ) {
+                                        phy_write( eng,  9, 0x2000 );//Test Mode 1
+                                }
+                                else {
+                                        phy_write( eng,  9, 0x8000 );//Test Mode 4
+                                }
+                        }
+                        else if ( eng->run.speed_sel[ 1 ] ) {
+                                //Rev 1.2
+                                phy_write( eng, 31, 0x0007 );
+                                phy_write( eng, 30, 0x002f );
+                                phy_write( eng, 23, 0xd818 );
+                                phy_write( eng, 30, 0x002d );
+                                phy_write( eng, 24, 0xf060 );
+                                phy_write( eng, 31, 0x0000 );
+
+                                if ( eng->run.ieee_sel == 0 ) {
+                                        phy_write( eng, 16, 0x00ae );//From Channel A
+                                }
+                                else {
+                                        phy_write( eng, 16, 0x008e );//From Channel B
+                                }
+                        }
+                        else {
+                                //Rev 1.2
+                                phy_write( eng, 31, 0x0006 );
+                                if ( eng->run.ieee_sel == 0 ) {//Diff. Voltage/TP-IDL/Jitter
+                                        phy_write( eng,  0, 0x5a21 );
+                                }
+                                else if ( eng->run.ieee_sel == 1 ) {//Harmonic: FF pattern
+                                        phy_write( eng,  2, 0x05ee );
+                                        phy_write( eng,  0, 0xff21 );
+                                }
+                                else {//Harmonic: 00 pattern
+                                        phy_write( eng,  2, 0x05ee );
+                                        phy_write( eng,  0, 0x0021 );
+                                }
+                                phy_write( eng, 31, 0x0000 );
+                        }
+                }
+                else {
+                        phy_basic_setting( eng );
+                        phy_delay(30);
+                }
+        }
+        else if ( eng->phy.loopback ) {
+#ifdef RTK_DEBUG
+                phy_write( eng,  0, 0x0000 );
+                phy_write( eng,  0, 0x8000 );
+                phy_delay(60);
+                phy_write( eng,  0, eng->phy.PHY_00h );
+                phy_delay(60);
+#else
+                phy_basic_setting( eng );
+
+                phy_clrset( eng,  0, 0x0000, 0x8000 | eng->phy.PHY_00h );//clr set//Rst PHY
+                phy_wait_reset_done( eng );
+                phy_delay(30);
+
+                phy_basic_setting( eng );
+                phy_delay(30);
+#endif
+        }
+        else {
+#ifdef Enable_Dual_Mode
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        check_value = 0x0c02 | 0xa000;
+                }
+                else if ( eng->run.speed_sel[ 1 ] ) {
+                        check_value = 0x0c02 | 0x6000;
+                }
+                else if ( eng->run.speed_sel[ 2 ] ) {
+                        check_value = 0x0c02 | 0x2000;
+                }
+#else
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        check_value = 0x0c02 | 0xa000;                
+#ifdef RTK_DEBUG
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  0, 0x8000 );
+                        phy_delay(60);
+  #endif
+
+                        phy_write( eng, 31, 0x0007 );
+                        phy_write( eng, 30, 0x0042 );
+                        phy_write( eng, 21, 0x2500 );
+                        phy_write( eng, 30, 0x0023 );
+                        phy_write( eng, 22, 0x0006 );
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  0, 0x0140 );
+                        phy_write( eng, 26, 0x0060 );
+                        phy_write( eng, 31, 0x0007 );
+                        phy_write( eng, 30, 0x002f );
+                        phy_write( eng, 23, 0xd820 );
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng, 21, 0x0206 );
+                        phy_write( eng, 23, 0x2120 );
+                        phy_write( eng, 23, 0x2160 );
+  #ifdef RTK_DEBUG
+                        phy_delay(600);
+  #else
+                        phy_delay(300);
+  #endif
+                }
+//              else if ( eng->run.speed_sel[ 1 ] ) {//option
+//                      check_value = 0x0c02 | 0x6000;
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0000 );
+//                      phy_write( eng,  4, 0x05e1 );
+//                      phy_write( eng,  0, 0x1200 );
+//                      phy_delay(6000);
+//              }
+//              else if ( eng->run.speed_sel[ 2 ] ) {//option
+//                      check_value = 0x0c02 | 0x2000;
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0000 );
+//                      phy_write( eng,  4, 0x0061 );
+//                      phy_write( eng,  0, 0x1200 );
+//                      phy_delay(6000);
+//              }
+                else {
+                        if ( eng->run.speed_sel[ 1 ] )
+                                check_value = 0x0c02 | 0x6000;
+                        else
+                                check_value = 0x0c02 | 0x2000;
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  0, eng->phy.PHY_00h );
+  #ifdef RTK_DEBUG
+                        phy_delay(300);
+  #else
+                        phy_delay(150);
+  #endif
+                }
+#endif
+#ifdef RTK_DEBUG
+#else
+                // Check register 0x11 bit10 Link OK or not OK
+                phy_check_register ( eng, 17, 0x0c02 | 0xe000, check_value, 10, "set RTL8211E");
+#endif
+        }
+
+	RTK_DBG_PRINTF("\nSet RTL8211E [End] =====>\n");
+} // End void phy_realtek2 (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+void recov_phy_realtek3 (MAC_ENGINE *eng) {//RTL8211C
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        if ( eng->run.speed_sel[ 0 ] ) {
+                                phy_write( eng,  9, 0x0000 );
+                        }
+                        else if ( eng->run.speed_sel[ 1 ] ) {
+                                phy_write( eng, 17, eng->phy.PHY_11h );
+                                phy_write( eng, 14, 0x0000 );
+                                phy_write( eng, 16, 0x00a0 );
+                        }
+                        else {
+//                              phy_write( eng, 31, 0x0006 );
+//                              phy_write( eng,  0, 0x5a00 );
+//                              phy_write( eng, 31, 0x0000 );
+                        }
+                }
+                else {
+                }
+        }
+        else if ( eng->phy.loopback ) {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 11, 0x0000 );
+                }
+                phy_write( eng, 12, 0x1006 );
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 31, 0x0001 );
+                        phy_write( eng,  4, 0xb000 );
+                        phy_write( eng,  3, 0xff41 );
+                        phy_write( eng,  2, 0xdf20 );
+                        phy_write( eng,  1, 0x0140 );
+                        phy_write( eng,  0, 0x00bb );
+                        phy_write( eng,  4, 0xb800 );
+                        phy_write( eng,  4, 0xb000 );
+
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng, 25, 0x8c00 );
+                        phy_write( eng, 26, 0x0040 );
+                        phy_write( eng,  0, 0x1140 );
+                        phy_write( eng, 14, 0x0000 );
+                        phy_write( eng, 12, 0x1006 );
+                        phy_write( eng, 23, 0x2109 );
+                }
+        }
+}
+
+//------------------------------------------------------------
+void phy_realtek3 (MAC_ENGINE *eng) {//RTL8211C
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Realtek] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        if ( eng->run.speed_sel[ 0 ] ) {
+                                if ( eng->run.ieee_sel == 0 ) {   //Test Mode 1
+                                        phy_write( eng,  9, 0x2000 );
+                                }
+                                else if ( eng->run.ieee_sel == 1 ) {//Test Mode 2
+                                        phy_write( eng,  9, 0x4000 );
+                                }
+                                else if ( eng->run.ieee_sel == 2 ) {//Test Mode 3
+                                        phy_write( eng,  9, 0x6000 );
+                                }
+                                else {                           //Test Mode 4
+                                        phy_write( eng,  9, 0x8000 );
+                                }
+                        }
+                        else if ( eng->run.speed_sel[ 1 ] ) {
+                                eng->phy.PHY_11h = phy_read( eng, PHY_SR );
+                                phy_write( eng, 17, eng->phy.PHY_11h & 0xfff7 );
+                                phy_write( eng, 14, 0x0660 );
+
+                                if ( eng->run.ieee_sel == 0 ) {
+                                        phy_write( eng, 16, 0x00a0 );//MDI  //From Channel A
+                                }
+                                else {
+                                        phy_write( eng, 16, 0x0080 );//MDIX //From Channel B
+                                }
+                        }
+                        else {
+//                              if ( eng->run.ieee_sel == 0 ) {//Pseudo-random pattern
+//                                      phy_write( eng, 31, 0x0006 );
+//                                      phy_write( eng,  0, 0x5a21 );
+//                                      phy_write( eng, 31, 0x0000 );
+//                              }
+//                              else if ( eng->run.ieee_sel == 1 ) {//FF pattern
+//                                      phy_write( eng, 31, 0x0006 );
+//                                      phy_write( eng,  2, 0x05ee );
+//                                      phy_write( eng,  0, 0xff21 );
+//                                      phy_write( eng, 31, 0x0000 );
+//                              }
+//                              else {//00 pattern
+//                                      phy_write( eng, 31, 0x0006 );
+//                                      phy_write( eng,  2, 0x05ee );
+//                                      phy_write( eng,  0, 0x0021 );
+//                                      phy_write( eng, 31, 0x0000 );
+//                              }
+                        }
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+        else if ( eng->phy.loopback ) {
+                phy_write( eng,  0, 0x9200 );
+                phy_wait_reset_done( eng );
+                phy_delay(30);
+
+                phy_write( eng, 17, 0x401c );
+                phy_write( eng, 12, 0x0006 );
+
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 11, 0x0002 );
+                }
+                else {
+                        phy_basic_setting( eng );
+                }
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 31, 0x0001 );
+                        phy_write( eng,  4, 0xb000 );
+                        phy_write( eng,  3, 0xff41 );
+                        phy_write( eng,  2, 0xd720 );
+                        phy_write( eng,  1, 0x0140 );
+                        phy_write( eng,  0, 0x00bb );
+                        phy_write( eng,  4, 0xb800 );
+                        phy_write( eng,  4, 0xb000 );
+
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng, 25, 0x8400 );
+                        phy_write( eng, 26, 0x0020 );
+                        phy_write( eng,  0, 0x0140 );
+                        phy_write( eng, 14, 0x0210 );
+                        phy_write( eng, 12, 0x0200 );
+                        phy_write( eng, 23, 0x2109 );
+                        phy_write( eng, 23, 0x2139 );
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+} // End void phy_realtek3 (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+//external loop 100M: OK
+//external loop 10M : OK
+//internal loop 100M: no  loopback stub
+//internal loop 10M : no  loopback stub
+void phy_realtek4 (MAC_ENGINE *eng) {//RTL8201F
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Realtek] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        eng->phy.RMIICK_IOMode |= PHY_Flag_RMIICK_IOMode_RTL8201F;
+
+        phy_write( eng, 31, 0x0007 );
+        eng->phy.PHY_10h = phy_read( eng, 16 );
+        //Check RMII Mode
+        if ( ( eng->phy.PHY_10h & 0x0008 ) == 0x0 ) {
+                phy_write( eng, 16, eng->phy.PHY_10h | 0x0008 );
+                printf("\n\n[Warning] Page 7 Register 16, bit 3 must be 1 [Reg10h_7:%04x]\n\n", eng->phy.PHY_10h);
+                if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Page 7 Register 16, bit 3 must be 1 [Reg10h_7:%04x]\n\n", eng->phy.PHY_10h );
+                if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Page 7 Register 16, bit 3 must be 1 [Reg10h_7:%04x]\n\n", eng->phy.PHY_10h );
+        }
+        //Check TXC Input/Output Direction
+        if ( eng->arg.ctrl.b.rmii_phy_in == 0 ) {
+                if ( ( eng->phy.PHY_10h & 0x1000 ) == 0x1000 ) {
+                        phy_write( eng, 16, eng->phy.PHY_10h & 0xefff );
+                        printf("\n\n[Warning] Page 7 Register 16, bit 12 must be 0 (TXC should be output mode)[Reg10h_7:%04x]\n\n", eng->phy.PHY_10h);
+                        if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Page 7 Register 16, bit 12 must be 0 (TXC should be output mode)[Reg10h_7:%04x]\n\n", eng->phy.PHY_10h );
+                        if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Page 7 Register 16, bit 12 must be 0 (TXC should be output mode)[Reg10h_7:%04x]\n\n", eng->phy.PHY_10h );
+                }
+        } else {
+                if ( ( eng->phy.PHY_10h & 0x1000 ) == 0x0000 ) {
+                        phy_write( eng, 16, eng->phy.PHY_10h | 0x1000 );
+                        printf("\n\n[Warning] Page 7 Register 16, bit 12 must be 1 (TXC should be input mode)[Reg10h_7:%04x]\n\n", eng->phy.PHY_10h);
+                        if ( eng->run.TM_IOTiming ) PRINTF( FP_IO, "\n\n[Warning] Page 7 Register 16, bit 12 must be 1 (TXC should be input mode)[Reg10h_7:%04x]\n\n", eng->phy.PHY_10h );
+                        if ( !eng->run.tm_tx_only ) PRINTF( FP_LOG, "\n\n[Warning] Page 7 Register 16, bit 12 must be 1 (TXC should be input mode)[Reg10h_7:%04x]\n\n", eng->phy.PHY_10h );
+                }
+        }
+        phy_write( eng, 31, 0x0000 );
+
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        //Rev 1.0
+                        phy_write( eng, 31, 0x0004 );
+                        phy_write( eng, 16, 0x4077 );
+                        phy_write( eng, 21, 0xc5a0 );
+                        phy_write( eng, 31, 0x0000 );
+
+                        if ( eng->run.speed_sel[ 1 ] ) {
+                                phy_write( eng,  0, 0x8000 ); // Reset PHY
+                                phy_wait_reset_done( eng );
+                                phy_write( eng, 24, 0x0310 ); // Disable ALDPS
+
+                                if ( eng->run.ieee_sel == 0 ) {//From Channel A (RJ45 pair 1, 2)
+                                        phy_write( eng, 28, 0x40c2 ); //Force MDI
+                                }
+                                else {//From Channel B (RJ45 pair 3, 6)
+                                        phy_write( eng, 28, 0x40c0 ); //Force MDIX
+                                }
+                                phy_write( eng,  0, 0x2100 );       //Force 100M/Full Duplex)
+                        } else {
+                        }
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+        else if ( eng->phy.loopback ) {
+                // Internal loopback
+                if ( eng->run.speed_sel[ 1 ] ) {
+                        // Enable 100M PCS loop back; RTL8201(F_FL_FN)-VB-CG_DataSheet_1.6.pdf
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  0, 0x6100 );
+                        phy_write( eng, 31, 0x0007 );
+                        phy_write( eng, 16, 0x1FF8 );
+                        phy_write( eng, 16, 0x0FF8 );
+                        phy_write( eng, 31, 0x0000 );
+                        phy_delay(20);
+                } else if ( eng->run.speed_sel[ 2 ] ) {
+                        // Enable 10M PCS loop back; RTL8201(F_FL_FN)-VB-CG_DataSheet_1.6.pdf
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  0, 0x4100 );
+                        phy_write( eng, 31, 0x0007 );
+                        phy_write( eng, 16, 0x1FF8 );
+                        phy_write( eng, 16, 0x0FF8 );
+                        phy_write( eng, 31, 0x0000 );
+                        phy_delay(20);
+                }
+        }
+        else {
+                // External loopback
+                if ( eng->run.speed_sel[ 1 ] ) {
+                        // Enable 100M MDI loop back Nway option; RTL8201(F_FL_FN)-VB-CG_DataSheet_1.6.pdf
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  4, 0x01E1 );
+                        phy_write( eng,  0, 0x1200 );
+                } else if ( eng->run.speed_sel[ 2 ] ) {
+                        // Enable 10M MDI loop back Nway option; RTL8201(F_FL_FN)-VB-CG_DataSheet_1.6.pdf
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  4, 0x0061 );
+                        phy_write( eng,  0, 0x1200 );
+                }
+//              phy_write( eng,  0, 0x8000 );
+//              while ( phy_read( eng, 0 ) != 0x3100 ) {}
+//              while ( phy_read( eng, 0 ) != 0x3100 ) {}
+//              phy_write( eng,  0, eng->phy.PHY_00h );
+////            phy_delay(100);
+//              phy_delay(400);
+
+                // Check register 0x1 bit2 Link OK or not OK
+                phy_check_register ( eng, 1, 0x0004, 0x0004, 10, "set RTL8201F");
+                phy_delay(300);
+        }
+}
+
+//------------------------------------------------------------
+/* for RTL8211F */
+void recov_phy_realtek5 (MAC_ENGINE *eng) 
+{
+	RTK_DBG_PRINTF("\nClear RTL8211F [Start] =====>\n");
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        if ( eng->run.speed_sel[ 0 ] ) {
+                                //Rev 1.0
+                                phy_write( eng, 31, 0x0000 );
+                                phy_write( eng,  9, 0x0000 );
+                        }
+                        else if ( eng->run.speed_sel[ 1 ] ) {
+                                //Rev 1.0
+                                phy_write( eng, 31, 0x0000 );
+                                phy_write( eng, 24, 0x2118 );//RGMII
+                                phy_write( eng,  9, 0x0200 );
+                                phy_write( eng,  0, 0x9200 );
+                                phy_wait_reset_done( eng );
+                        }
+                        else {
+                                //Rev 1.0
+                                phy_write( eng, 31, 0x0c80 );
+                                phy_write( eng, 16, 0x5a00 );
+                                phy_write( eng, 31, 0x0000 );
+                                phy_write( eng,  4, 0x01e1 );
+                                phy_write( eng,  9, 0x0200 );
+                                phy_write( eng,  0, 0x9200 );
+                                phy_wait_reset_done( eng );
+                        }
+                }
+                else {
+                }
+        }
+        else if ( eng->phy.loopback ) {
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        //Rev 1.1
+                        phy_write( eng, 31, 0x0a43 );
+                        phy_write( eng, 24, 0x2118 );
+                        phy_write( eng,  0, 0x1040 );
+                }
+//              else if ( eng->run.speed_sel[ 1 ] ) {//option
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0200 );
+//                      phy_write( eng,  0, 0x1200 );
+//              }
+//              else if ( eng->run.speed_sel[ 2 ] ) {//option
+//                      phy_write( eng, 31, 0x0000 );
+//                      phy_write( eng,  9, 0x0200 );
+//                      phy_write( eng,  4, 0x01e1 );
+//                      phy_write( eng,  0, 0x1200 );
+//              }
+                else {
+                        phy_write( eng, 31, 0x0000 );
+                        phy_write( eng,  0, 0x1040 );
+                }
+
+#ifdef RTK_DEBUG
+#else
+                // Check register 0x1A bit2 Link OK or not OK
+                phy_write( eng, 31, 0x0a43 );
+                phy_check_register ( eng, 26, 0x0004, 0x0000, 10, "clear RTL8211F");
+                phy_write( eng, 31, 0x0000 );
+#endif
+        }
+
+	RTK_DBG_PRINTF("\nClear RTL8211F [End] =====>\n");
+}
+
+//------------------------------------------------------------
+void phy_realtek5 (MAC_ENGINE *eng) {//RTL8211F
+	uint16_t check_value;
+
+	RTK_DBG_PRINTF("\nSet RTL8211F [Start] =====>\n");
+	if (DbgPrn_PHYName)
+		printf("--->(%04x %04x)[Realtek] %s\n", eng->phy.id1,
+		       eng->phy.id2, eng->phy.phy_name);
+
+	if (eng->run.tm_tx_only) {
+		if (eng->run.TM_IEEE) {
+			if (eng->run.speed_sel[0]) {
+				// Rev 1.0
+				phy_write(eng, 31, 0x0000);
+				if (eng->run.ieee_sel == 0) { // Test Mode 1
+					phy_write(eng, 9, 0x0200);
+				} else if (eng->run.ieee_sel ==
+					   1) { // Test Mode 2
+					phy_write(eng, 9, 0x0400);
+				} else { // Test Mode 4
+					phy_write(eng, 9, 0x0800);
+				}
+			} else if (eng->run.speed_sel[1]) { // option
+				// Rev 1.0
+				phy_write(eng, 31, 0x0000);
+				if (eng->run.ieee_sel ==
+				    0) { // Output MLT-3 from Channel A
+					phy_write(eng, 24, 0x2318);
+				} else { // Output MLT-3 from Channel B
+					phy_write(eng, 24, 0x2218);
+				}
+				phy_write(eng, 9, 0x0000);
+				phy_write(eng, 0, 0x2100);
+			} else {
+				// Rev 1.0
+				// 0: For Diff. Voltage/TP-IDL/Jitter with EEE
+				// 1: For Diff. Voltage/TP-IDL/Jitter without
+				// EEE 2: For Harmonic (all "1" patten) with EEE
+				// 3: For Harmonic (all "1" patten) without EEE
+				// 4: For Harmonic (all "0" patten) with EEE
+				// 5: For Harmonic (all "0" patten) without EEE
+				phy_write(eng, 31, 0x0000);
+				phy_write(eng, 9, 0x0000);
+				phy_write(eng, 4, 0x0061);
+				if ((eng->run.ieee_sel & 0x1) == 0) { // with
+								      // EEE
+					phy_write(eng, 25, 0x0853);
+				} else { // without EEE
+					phy_write(eng, 25, 0x0843);
+				}
+				phy_write(eng, 0, 0x9200);
+				phy_wait_reset_done(eng);
+
+				if ((eng->run.ieee_sel & 0x6) ==
+				    0) { // For Diff. Voltage/TP-IDL/Jitter
+					phy_write(eng, 31, 0x0c80);
+					phy_write(eng, 18, 0x0115);
+					phy_write(eng, 16, 0x5a21);
+				} else if ((eng->run.ieee_sel & 0x6) ==
+					   0x2) { // For Harmonic (all "1"
+						  // patten)
+					phy_write(eng, 31, 0x0c80);
+					phy_write(eng, 18, 0x0015);
+					phy_write(eng, 16, 0xff21);
+				} else { // For Harmonic (all "0" patten)
+					phy_write(eng, 31, 0x0c80);
+					phy_write(eng, 18, 0x0015);
+					phy_write(eng, 16, 0x0021);
+				}
+				phy_write(eng, 31, 0x0000);
+			}
+		} else {
+			phy_reset(eng);
+		}
+	} else if (eng->phy.loopback) {
+		phy_reset(eng);
+	} else {
+		if (eng->run.speed_sel[0]) {
+			check_value = 0x0004 | 0x0028;
+			// Rev 1.1
+			phy_write(eng, 31, 0x0a43);
+			phy_write(eng, 0, 0x8000);
+#ifdef RTK_DEBUG
+			phy_delay(60);
+#else
+			phy_wait_reset_done(eng);
+			phy_delay(30);
+#endif
+
+			phy_write(eng, 0, 0x0140);
+			phy_write(eng, 24, 0x2d18);
+#ifdef RTK_DEBUG
+			phy_delay(600);
+#else
+			phy_delay(300);
+#endif
+		} else {
+			if (eng->run.speed_sel[1])
+				check_value = 0x0004 | 0x0018;
+			else
+				check_value = 0x0004 | 0x0008;
+#ifdef RTK_DEBUG
+#else
+			phy_write(eng, 31, 0x0a43);
+			phy_write(eng, 0, 0x8000);
+			phy_wait_reset_done(eng);
+			phy_delay(30);
+#endif
+
+			phy_write(eng, 31, 0x0000);
+			phy_write(eng, 0, eng->phy.PHY_00h);
+#ifdef RTK_DEBUG
+			phy_delay(300);
+#else
+			phy_delay(150);
+#endif
+		}
+
+#ifdef RTK_DEBUG
+#else
+		// Check register 0x1A bit2 Link OK or not OK
+		phy_write(eng, 31, 0x0a43);
+		phy_check_register(eng, 26, 0x0004 | 0x0038, check_value, 10,
+				   "set RTL8211F");
+		phy_write(eng, 31, 0x0000);
+#endif
+	}
+
+	RTK_DBG_PRINTF("\nSet RTL8211F [End] =====>\n");
+}
+
+//------------------------------------------------------------
+//It is a LAN Switch, only support 1G internal loopback test.
+void phy_realtek6 (MAC_ENGINE *eng) 
+{//RTL8363S
+	if (DbgPrn_PHYName)
+		printf("--->(%04x %04x)[Realtek] %s\n", eng->phy.id1,
+		       eng->phy.id2, eng->phy.phy_name);
+
+	if (eng->run.tm_tx_only) {
+		printf("This mode doesn't support in RTL8363S.\n");
+	} else if (eng->phy.loopback) {
+
+		// RXDLY2 and TXDLY2 of RTL8363S should set to LOW
+		phy_basic_setting(eng);
+
+		phy_clrset(eng, 0, 0x0000,
+			       0x8000 | eng->phy.PHY_00h); // clr set//Rst PHY
+		phy_wait_reset_done(eng);
+		phy_delay(30);
+
+		phy_basic_setting(eng);
+		phy_delay(30);
+	} else {
+		printf("This mode doesn't support in RTL8363S\n");
+	}
+} // End void phy_realtek6 (MAC_ENGINE *eng)
+
+//------------------------------------------------------------
+void phy_smsc (MAC_ENGINE *eng) 
+{//LAN8700
+	if (DbgPrn_PHYName)
+		printf("--->(%04x %04x)[SMSC] %s\n", eng->phy.id1,
+		       eng->phy.id2, eng->phy.phy_name);
+
+	phy_reset(eng);
+}
+
+//------------------------------------------------------------
+void phy_micrel (MAC_ENGINE *eng) 
+{//KSZ8041
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Micrel] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        phy_reset( eng );
+
+//      phy_write( eng, 24, 0x0600 );
+}
+
+//------------------------------------------------------------
+void phy_micrel0 (MAC_ENGINE *eng) {//KSZ8031/KSZ8051
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Micrel] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        //For KSZ8051RNL only
+        //Reg1Fh[7] = 0(default): 25MHz Mode, XI, XO(pin 9, 8) is 25MHz(crystal/oscilator).
+        //Reg1Fh[7] = 1         : 50MHz Mode, XI(pin 9) is 50MHz(oscilator).
+        eng->phy.PHY_1fh = phy_read( eng, 31 );
+        if ( eng->phy.PHY_1fh & 0x0080 ) sprintf((char *)eng->phy.phy_name, "%s-50MHz Mode", eng->phy.phy_name);
+        else                             sprintf((char *)eng->phy.phy_name, "%s-25MHz Mode", eng->phy.phy_name);
+
+        if ( eng->run.TM_IEEE ) {
+                phy_clrset( eng,  0, 0x0000, 0x8000 | eng->phy.PHY_00h );//clr set//Rst PHY
+                phy_wait_reset_done( eng );
+
+                phy_clrset( eng, 31, 0x0000, 0x2000 );//clr set//1Fh[13] = 1: Disable auto MDI/MDI-X
+                phy_basic_setting( eng );
+                phy_clrset( eng, 31, 0x0000, 0x0800 );//clr set//1Fh[11] = 1: Force link pass
+
+//              phy_delay(2500);//2.5 sec
+        }
+        else {
+                phy_reset( eng );
+
+                //Reg16h[6] = 1         : RMII B-to-B override
+                //Reg16h[1] = 1(default): RMII override
+                phy_clrset( eng, 22, 0x0000, 0x0042 );//clr set
+        }
+
+        if ( eng->phy.PHY_1fh & 0x0080 )
+                phy_clrset( eng, 31, 0x0000, 0x0080 );//clr set//Reset PHY will clear Reg1Fh[7]
+}
+
+//------------------------------------------------------------
+//external loop 1G  : NOT Support
+//external loop 100M: OK
+//external loop 10M : OK
+//internal loop 1G  : no  loopback stub
+//internal loop 100M: no  loopback stub
+//internal loop 10M : no  loopback stub
+void phy_micrel1 (MAC_ENGINE *eng) 
+{//KSZ9031
+//      int        temp;
+
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Micrel] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+/*
+        phy_write( eng, 13, 0x0002 );
+        phy_write( eng, 14, 0x0004 );
+        phy_write( eng, 13, 0x4002 );
+        temp = phy_read( eng, 14 );
+        //Reg2.4[ 7: 4]: RXDV Pad Skew
+        phy_write( eng, 14, temp & 0xff0f | 0x0000 );
+//      phy_write( eng, 14, temp & 0xff0f | 0x00f0 );
+printf("Reg2.4 = %04x -> %04x\n", temp, phy_read( eng, 14 ));
+
+        phy_write( eng, 13, 0x0002 );
+        phy_write( eng, 14, 0x0005 );
+        phy_write( eng, 13, 0x4002 );
+        temp = phy_read( eng, 14 );
+        //Reg2.5[15:12]: RXD3 Pad Skew
+        //Reg2.5[11: 8]: RXD2 Pad Skew
+        //Reg2.5[ 7: 4]: RXD1 Pad Skew
+        //Reg2.5[ 3: 0]: RXD0 Pad Skew
+        phy_write( eng, 14, 0x0000 );
+//      phy_write( eng, 14, 0xffff );
+printf("Reg2.5 = %04x -> %04x\n", temp, phy_read( eng, 14 ));
+
+        phy_write( eng, 13, 0x0002 );
+        phy_write( eng, 14, 0x0008 );
+        phy_write( eng, 13, 0x4002 );
+        temp = phy_read( eng, 14 );
+        //Reg2.8[9:5]: GTX_CLK Pad Skew
+        //Reg2.8[4:0]: RX_CLK Pad Skew
+//      phy_write( eng, 14, temp & 0xffe0 | 0x0000 );
+        phy_write( eng, 14, temp & 0xffe0 | 0x001f );
+printf("Reg2.8 = %04x -> %04x\n", temp, phy_read( eng, 14 ));
+*/
+
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        phy_reset( eng );
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+        else if ( eng->phy.loopback ) {
+                phy_reset( eng );
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_reset( eng );//DON'T support for 1G external loopback testing
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+}
+
+//------------------------------------------------------------
+//external loop 100M: OK
+//external loop 10M : OK
+//internal loop 100M: no  loopback stub
+//internal loop 10M : no  loopback stub
+void phy_micrel2 (MAC_ENGINE *eng) 
+{//KSZ8081
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[Micrel] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        phy_reset( eng );
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+        else if ( eng->phy.loopback ) {
+                phy_reset( eng );
+        }
+        else {
+                if ( eng->run.speed_sel[ 1 ] )
+                        phy_reset( eng );
+                else
+                        phy_reset( eng );
+        }
+}
+
+//------------------------------------------------------------
+void recov_phy_vitesse (MAC_ENGINE *eng) {//VSC8601
+        if ( eng->run.tm_tx_only ) {
+//              if ( eng->run.TM_IEEE ) {
+//              }
+//              else {
+//              }
+        }
+        else if ( eng->phy.loopback ) {
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        phy_write( eng, 24, eng->phy.PHY_18h );
+                        phy_write( eng, 18, eng->phy.PHY_12h );
+                }
+        }
+}
+
+//------------------------------------------------------------
+void phy_vitesse (MAC_ENGINE *eng) {//VSC8601
+        if ( DbgPrn_PHYName )
+                printf("--->(%04x %04x)[VITESSE] %s\n", eng->phy.id1, eng->phy.id2, eng->phy.phy_name);
+
+        if ( eng->run.tm_tx_only ) {
+                if ( eng->run.TM_IEEE ) {
+                        phy_reset( eng );
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+        else if ( eng->phy.loopback ) {
+                phy_reset( eng );
+        }
+        else {
+                if ( eng->run.speed_sel[ 0 ] ) {
+                        eng->phy.PHY_18h = phy_read( eng, 24 );
+                        eng->phy.PHY_12h = phy_read( eng, PHY_INER );
+
+                        phy_reset( eng );
+
+                        phy_write( eng, 24, eng->phy.PHY_18h | 0x0001 );
+                        phy_write( eng, 18, eng->phy.PHY_12h | 0x0020 );
+                }
+                else {
+                        phy_reset( eng );
+                }
+        }
+}
+
+//------------------------------------------------------------
+void recov_phy_atheros (MAC_ENGINE *eng) {//AR8035
+	if (eng->run.tm_tx_only) {
+		if (eng->run.TM_IEEE) {
+		} else {
+		}
+	} else if (eng->phy.loopback) {
+	} else {
+		phy_clrset(
+		    eng, 11, 0x0000,
+		    0x8000); // clr set//Disable hibernate: Reg0Bh[15] = 0
+		phy_clrset(
+		    eng, 17, 0x0001,
+		    0x0000); // clr set//Enable external loopback: Reg11h[0] = 1
+	}
+}
+
+//------------------------------------------------------------
+void phy_atheros (MAC_ENGINE *eng) 
+{
+#ifdef PHY_DEBUG
+	if (1) {
+#else
+	if (DbgPrn_PHYName) {
+#endif
+		printf("--->(%04x %04x)[ATHEROS] %s\n", eng->phy.id1,
+		       eng->phy.id2, eng->phy.phy_name);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG, "--->(%04x %04x)[ATHEROS] %s\n",
+			       eng->phy.id1, eng->phy.id2,
+			       eng->phy.phy_name);
+	}
+
+	// Reg0b[15]: Power saving
+	phy_write(eng, 29, 0x000b);
+	eng->phy.PHY_1eh = phy_read(eng, 30);
+	if (eng->phy.PHY_1eh & 0x8000) {
+		printf("\n\n[Warning] Debug register offset = 11, bit 15 must "
+		       "be 0 [%04x]\n\n",
+		       eng->phy.PHY_1eh);
+		if (eng->run.TM_IOTiming)
+			PRINTF(FP_IO,
+			       "\n\n[Warning] Debug register offset = 11, bit "
+			       "15 must be 0 [%04x]\n\n",
+			       eng->phy.PHY_1eh);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG,
+			       "\n\n[Warning] Debug register offset = 11, bit "
+			       "15 must be 0 [%04x]\n\n",
+			       eng->phy.PHY_1eh);
+
+		phy_write(eng, 30, eng->phy.PHY_1eh & 0x7fff);
+	}
+	//      phy_write( eng, 30, (eng->phy.PHY_1eh & 0x7fff) | 0x8000 );
+
+	// Check RGMIIRXCK delay (Sel_clk125m_dsp)
+	phy_write(eng, 29, 0x0000);
+	eng->phy.PHY_1eh = phy_read(eng, 30);
+	if (eng->phy.PHY_1eh & 0x8000) {
+		printf("\n\n[Warning] Debug register offset = 0, bit 15 must "
+		       "be 0 [%04x]\n\n",
+		       eng->phy.PHY_1eh);
+		if (eng->run.TM_IOTiming)
+			PRINTF(FP_IO,
+			       "\n\n[Warning] Debug register offset = 0, bit "
+			       "15 must be 0 [%04x]\n\n",
+			       eng->phy.PHY_1eh);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG,
+			       "\n\n[Warning] Debug register offset = 0, bit "
+			       "15 must be 0 [%04x]\n\n",
+			       eng->phy.PHY_1eh);
+
+		phy_write(eng, 30, eng->phy.PHY_1eh & 0x7fff);
+	}
+	//      phy_write( eng, 30, (eng->phy.PHY_1eh & 0x7fff) | 0x8000 );
+
+	// Check RGMIITXCK delay (rgmii_tx_clk_dly)
+	phy_write(eng, 29, 0x0005);
+	eng->phy.PHY_1eh = phy_read(eng, 30);
+	if (eng->phy.PHY_1eh & 0x0100) {
+		printf("\n\n[Warning] Debug register offset = 5, bit 8 must be "
+		       "0 [%04x]\n\n",
+		       eng->phy.PHY_1eh);
+		if (eng->run.TM_IOTiming)
+			PRINTF(FP_IO,
+			       "\n\n[Warning] Debug register offset = 5, bit 8 "
+			       "must be 0 [%04x]\n\n",
+			       eng->phy.PHY_1eh);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG,
+			       "\n\n[Warning] Debug register offset = 5, bit 8 "
+			       "must be 0 [%04x]\n\n",
+			       eng->phy.PHY_1eh);
+
+		phy_write(eng, 30, eng->phy.PHY_1eh & 0xfeff);
+	}
+	//      phy_write( eng, 30, (eng->phy.PHY_1eh & 0xfeff) | 0x0100 );
+
+	// Check CLK_25M output (Select_clk125m)
+	phy_write(eng, 13, 0x0007);
+	phy_write(eng, 14, 0x8016);
+	phy_write(eng, 13, 0x4007);
+	eng->phy.PHY_0eh = phy_read(eng, 14);
+	if ((eng->phy.PHY_0eh & 0x0018) != 0x0018) {
+		printf("\n\n[Warning] Device addrress = 7, Addrress ofset = "
+		       "0x8016, bit 4~3 must be 3 [%04x]\n\n",
+		       eng->phy.PHY_0eh);
+		if (eng->run.TM_IOTiming)
+			PRINTF(FP_IO,
+			       "\n\n[Warning] Device addrress = 7, Addrress "
+			       "ofset = 0x8016, bit 4~3 must be 3 [%04x]\n\n",
+			       eng->phy.PHY_0eh);
+		if (!eng->run.tm_tx_only)
+			PRINTF(FP_LOG,
+			       "\n\n[Warning] Device addrress = 7, Addrress "
+			       "ofset = 0x8016, bit 4~3 must be 3 [%04x]\n\n",
+			       eng->phy.PHY_0eh);
+		printf("          The CLK_25M don't ouput 125MHz clock for the "
+		       "RGMIICK !!!\n\n");
+
+		phy_write(eng, 14, (eng->phy.PHY_0eh & 0xffe7) | 0x0018);
+	}
+
+	if (eng->run.tm_tx_only) {
+		if (eng->run.TM_IEEE) {
+			phy_write(eng, 0, eng->phy.PHY_00h);
+		} else {
+			phy_write(eng, 0, eng->phy.PHY_00h);
+		}
+	} else if (eng->phy.loopback) {
+		phy_write(eng, 0, eng->phy.PHY_00h);
+	} else {
+		phy_clrset(
+		    eng, 11, 0x8000,
+		    0x0000); // clr set//Disable hibernate: Reg0Bh[15] = 0
+		phy_clrset(
+		    eng, 17, 0x0000,
+		    0x0001); // clr set//Enable external loopback: Reg11h[0] = 1
+
+		phy_write(eng, 0, eng->phy.PHY_00h | 0x8000);
+#ifdef Delay_PHYRst
+		phy_delay(Delay_PHYRst);
+#endif
+	}
+}
+
+//------------------------------------------------------------
+void phy_default (MAC_ENGINE *eng) 
+{
+	nt_log_func_name();
+
+	if (DbgPrn_PHYName)
+		printf("--->(%04x %04x)%s\n", eng->phy.id1,
+		       eng->phy.id2, eng->phy.phy_name);
+
+	phy_reset(eng);
+}
+
+//------------------------------------------------------------
+// PHY Init
+//------------------------------------------------------------
+/**
+ * @return	1->addr found,  0->else
+*/
+uint32_t phy_find_addr(MAC_ENGINE *eng)
+{
+	uint32_t value;
+	uint32_t ret = 0;
+	int8_t phy_addr_org;
+
+	nt_log_func_name();
+        
+        phy_addr_org = eng->phy.Adr;
+        value = phy_read(eng, PHY_REG_ID_1);
+	
+        ret = PHY_IS_VALID(value);
+        if ((ret == 0) && (eng->arg.ctrl.b.skip_phy_id_check)) {
+		value = phy_read(eng, PHY_REG_BMCR);
+		if ((value & BIT(15)) && (0 == eng->arg.ctrl.b.skip_phy_init)) {
+                        /* user wants to skip PHY init but PHY is in reset state
+                         * this case should not be allowed.
+                         */
+		} else {
+			ret = 1;
+		}
+	}
+
+	if (ret == 0) {
+		for (eng->phy.Adr = 0; eng->phy.Adr < 32; eng->phy.Adr++) {
+			value = phy_read(eng, PHY_REG_ID_1);
+			if (PHY_IS_VALID(value)) {
+				ret = 1;
+				break;
+			}
+		}
+	}
+
+	if (ret == 0)
+		eng->phy.Adr = eng->arg.phy_addr;
+
+	if (0 == eng->arg.ctrl.b.skip_phy_init) {
+		if (ret == 1) {
+			if (phy_addr_org != eng->phy.Adr) {
+				phy_scan_id(eng, STD_OUT);
+			}
+		} else {
+			phy_scan_id(eng, STD_OUT);
+			FindErr(eng, Err_Flag_PHY_Type);
+		}
+	}
+
+
+	eng->phy.id1 = phy_read(eng, PHY_REG_ID_1);
+	eng->phy.id2 = phy_read(eng, PHY_REG_ID_2);
+        value = (eng->phy.id2 << 16) | eng->phy.id1;
+        
+	if (0 == eng->arg.ctrl.b.skip_phy_id_check) {
+                if ((value == 0) || (value == 0xffffffff)) {
+                        sprintf((char *)eng->phy.phy_name, "--");
+                        if (0 == eng->arg.ctrl.b.skip_phy_init)
+			        FindErr(eng, Err_Flag_PHY_Type);
+                }
+        }
+
+        return ret;
+}
+
+//------------------------------------------------------------
+void phy_set00h (MAC_ENGINE *eng) 
+{
+	nt_log_func_name();
+	if (eng->run.tm_tx_only) {
+		if (eng->run.TM_IEEE) {
+			if (eng->run.speed_sel[0])
+				eng->phy.PHY_00h = 0x0140;
+			else if (eng->run.speed_sel[1])
+				eng->phy.PHY_00h = 0x2100;
+			else
+				eng->phy.PHY_00h = 0x0100;
+		} else {
+			if (eng->run.speed_sel[0])
+				eng->phy.PHY_00h = 0x0140;
+			else if (eng->run.speed_sel[1])
+				eng->phy.PHY_00h = 0x2100;
+			else
+				eng->phy.PHY_00h = 0x0100;
+		}
+	} else if (eng->phy.loopback) {
+		if (eng->run.speed_sel[0])
+			eng->phy.PHY_00h = 0x4140;
+		else if (eng->run.speed_sel[1])
+			eng->phy.PHY_00h = 0x6100;
+		else
+			eng->phy.PHY_00h = 0x4100;
+	} else {
+		if (eng->run.speed_sel[0])
+			eng->phy.PHY_00h = 0x0140;
+		else if (eng->run.speed_sel[1])
+			eng->phy.PHY_00h = 0x2100;
+		else
+			eng->phy.PHY_00h = 0x0100;
+	}
+}
+
+static uint32_t phy_check_id(MAC_ENGINE *p_eng, const struct phy_desc *p_phy) 
+{
+        uint32_t value, id;
+
+        value  = (p_eng->phy.id1 << 16) | (p_eng->phy.id2 & p_phy->id2_mask);
+        id  = (p_phy->id1 << 16) | (p_phy->id2 & p_phy->id2_mask);
+        debug("%s:value %04x, id %04x\n", __func__, value, id);
+
+        if (value == id)
+                return 1;
+	
+        return 0;
+}
+
+void phy_select(MAC_ENGINE *eng, PHY_ENGINE *phyeng)
+{
+	int i;
+	const struct phy_desc *p_phy;
+	nt_log_func_name();
+
+	/* set default before lookup */
+	sprintf((char *)eng->phy.phy_name, "default");
+	phyeng->fp_set = phy_default;
+	phyeng->fp_clr = NULL;
+
+	if (eng->phy.default_phy) {
+		debug("use default PHY\n");
+	} else {
+		for (i = 0; i < PHY_LOOKUP_N; i++) {
+			p_phy = &phy_lookup_tbl[i];
+			if (phy_check_id(eng, p_phy)) {
+				sprintf((char *)eng->phy.phy_name,
+					(char *)p_phy->name);
+				phyeng->fp_set = p_phy->cfg.fp_set;
+				phyeng->fp_clr = p_phy->cfg.fp_clr;
+				break;
+			}
+		}
+	}
+
+	if (eng->arg.ctrl.b.skip_phy_init) {
+		phyeng->fp_set = NULL;
+		phyeng->fp_clr = NULL;
+	} else if (eng->arg.ctrl.b.skip_phy_deinit) {
+		phyeng->fp_clr = NULL;
+	}
+}
+
+//------------------------------------------------------------
+void recov_phy (MAC_ENGINE *eng, PHY_ENGINE *phyeng) 
+{
+	nt_log_func_name();
+
+	if (phyeng->fp_clr != NULL)
+        	(*phyeng->fp_clr)( eng );
+}
+
+//------------------------------------------------------------
+void init_phy (MAC_ENGINE *eng, PHY_ENGINE *phyeng) 
+{
+	nt_log_func_name();
+
+	if (DbgPrn_PHYInit)
+		phy_dump(eng);
+
+	phy_set00h(eng);
+	if (phyeng->fp_set != NULL)
+		(*phyeng->fp_set)(eng);
+
+	if (DbgPrn_PHYInit)
+		phy_dump(eng);
+}
diff -Naur uboot/oem/ami/standalone/nettest/phy.h uboot-new/oem/ami/standalone/nettest/phy.h
--- uboot/oem/ami/standalone/nettest/phy.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/phy.h	2020-11-20 04:00:27.000000000 -0500
@@ -0,0 +1,49 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PHY_H
+#define PHY_H
+
+//
+// Define
+//
+
+#define PHY_IS_VALID(dat)                                                      \
+	(((dat & 0xffff) != 0xffff) && ((dat & 0xffff) != 0x0))
+
+// Define PHY basic register
+#define PHY_REG_BMCR    0x00 // Basic Mode Control Register
+#define PHY_REG_BMSR    0x01 // Basic Mode Status Register
+#define PHY_REG_ID_1    0x02
+#define PHY_REG_ID_2    0x03
+#define PHY_ANER        0x06 // Auto-negotiation Expansion Register
+#define PHY_GBCR        0x09 // 1000Base-T Control Register
+#define PHY_SR          0x11 // PHY Specific Status Register
+#define PHY_INER        0x12 // Interrupt Enable Register
+
+#define PHYID3_Mask                0xfc00         //0xffc0
+
+/* --- Note for SettingPHY chip ---
+void phy_xxxx (int loop_phy) {
+
+	if ( BurstEnable ) {
+        // IEEE test
+	}
+	else if (loop_phy) {
+        // Internal loop back
+	}
+	else {
+        // external loop back
+	}
+}
+----------------------------------- */
+
+#endif // PHY_H
diff -Naur uboot/oem/ami/standalone/nettest/phy_tbl.h uboot-new/oem/ami/standalone/nettest/phy_tbl.h
--- uboot/oem/ami/standalone/nettest/phy_tbl.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/phy_tbl.h	2020-11-20 04:00:27.000000000 -0500
@@ -0,0 +1,244 @@
+void recov_phy_marvell(MAC_ENGINE *eng);
+void phy_marvell(MAC_ENGINE *eng);
+void recov_phy_marvell0(MAC_ENGINE *eng);
+void phy_marvell0(MAC_ENGINE *eng);
+void recov_phy_marvell1(MAC_ENGINE *eng);
+void phy_marvell1(MAC_ENGINE *eng);
+void recov_phy_marvell2(MAC_ENGINE *eng);
+void phy_marvell2(MAC_ENGINE *eng);
+void phy_marvell3(MAC_ENGINE *eng);
+void phy_broadcom(MAC_ENGINE *eng);
+void recov_phy_broadcom0(MAC_ENGINE *eng);
+void phy_broadcom0(MAC_ENGINE *eng);
+void phy_realtek(MAC_ENGINE *eng);
+void phy_realtek0(MAC_ENGINE *eng);
+void recov_phy_realtek1(MAC_ENGINE *eng);
+void phy_realtek1(MAC_ENGINE *eng);
+void recov_phy_realtek2(MAC_ENGINE *eng);
+void recov_phy_realtek3(MAC_ENGINE *eng);
+void phy_realtek3(MAC_ENGINE *eng);
+void phy_realtek4(MAC_ENGINE *eng);
+void phy_realtek2(MAC_ENGINE *eng);
+void recov_phy_realtek5(MAC_ENGINE *eng);
+void phy_realtek5(MAC_ENGINE *eng);
+void phy_realtek6(MAC_ENGINE *eng);
+void phy_smsc(MAC_ENGINE *eng);
+void phy_micrel(MAC_ENGINE *eng);
+void phy_micrel0(MAC_ENGINE *eng);
+void phy_micrel1(MAC_ENGINE *eng);
+void phy_micrel2(MAC_ENGINE *eng);
+void recov_phy_vitesse(MAC_ENGINE *eng);
+void phy_vitesse(MAC_ENGINE *eng);
+void recov_phy_atheros(MAC_ENGINE *eng);
+void phy_atheros(MAC_ENGINE *eng);
+void phy_default(MAC_ENGINE *eng);
+
+struct phy_desc {
+	uint16_t id1;
+	uint16_t id2;
+	uint16_t id2_mask;
+	uint8_t name[64];
+	PHY_ENGINE cfg;
+};
+
+#define PHY_LOOKUP_N 33
+static const struct phy_desc phy_lookup_tbl[PHY_LOOKUP_N] = {
+	{ .id1 = 0x001c,
+	  .id2 = 0xc916,
+	  .id2_mask = 0xffff,
+	  .name = "RTL8211F",
+	  .cfg.fp_set = phy_realtek5,
+	  .cfg.fp_clr = recov_phy_realtek5 },
+	{ .id1 = 0x001c,
+	  .id2 = 0xc915,
+	  .id2_mask = 0xffff,
+	  .name = "RTL8211E",
+	  .cfg.fp_set = phy_realtek2,
+	  .cfg.fp_clr = recov_phy_realtek2 },
+	{ .id1 = 0x001c,
+	  .id2 = 0xc914,
+	  .id2_mask = 0xffff,
+	  .name = "RTL8211D",
+	  .cfg.fp_set = phy_realtek1,
+	  .cfg.fp_clr = recov_phy_realtek1 },
+	{ .id1 = 0x001c,
+	  .id2 = 0xc912,
+	  .id2_mask = 0xffff,
+	  .name = "RTL8211C",
+	  .cfg.fp_set = phy_realtek3,
+	  .cfg.fp_clr = recov_phy_realtek3 },
+	{ .id1 = 0x001c,
+	  .id2 = 0xc930,
+	  .id2_mask = 0xffff,
+	  .name = "RTL8363S",
+	  .cfg.fp_set = phy_realtek6,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x001c,
+	  .id2 = 0xc816,
+	  .id2_mask = 0xffff,
+	  .name = "RTL8201F",
+	  .cfg.fp_set = phy_realtek4,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x001c,
+	  .id2 = 0xc815,
+	  .id2_mask = 0xfff0,
+	  .name = "RTL8201E",
+	  .cfg.fp_set = phy_realtek0,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x0000,
+	  .id2 = 0x8201,
+	  .id2_mask = PHYID3_Mask,
+	  .name = "RTL8201N",
+	  .cfg.fp_set = phy_realtek,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x0143,
+	  .id2 = 0xbcb2,
+	  .id2_mask = 0xfff0,
+	  .name = "BCM5482",
+	  .cfg.fp_set = phy_broadcom0,
+	  .cfg.fp_clr = recov_phy_broadcom0 },
+	{ .id1 = 0x0143,
+	  .id2 = 0xbca0,
+	  .id2_mask = 0xfff0,
+	  .name = "BCM5481",
+	  .cfg.fp_set = phy_broadcom0,
+	  .cfg.fp_clr = recov_phy_broadcom0 },
+	{ .id1 = 0x0362,
+	  .id2 = 0x5e6a,
+	  .id2_mask = 0xfff0,
+	  .name = "BCM54612",
+	  .cfg.fp_set = phy_broadcom0,
+	  .cfg.fp_clr = recov_phy_broadcom0 },
+	{ .id1 = 0x0362,
+	  .id2 = 0x5d10,
+	  .id2_mask = 0xfff0,
+	  .name = "BCM54616S",
+	  .cfg.fp_set = phy_broadcom0,
+	  .cfg.fp_clr = recov_phy_broadcom0 },
+	{ .id1 = 0x0020,
+	  .id2 = 0x60b0,
+	  .id2_mask = 0xfff0,
+	  .name = "BCM5464SR",
+	  .cfg.fp_set = phy_broadcom0,
+	  .cfg.fp_clr = recov_phy_broadcom0 },
+	{ .id1 = 0x0020,
+	  .id2 = 0x60c1,
+	  .id2_mask = 0xfff0,
+	  .name = "BCM5461S",
+	  .cfg.fp_set = phy_broadcom0,
+	  .cfg.fp_clr = recov_phy_broadcom0 },
+	{ .id1 = 0x600d,
+	  .id2 = 0x84a2,
+	  .id2_mask = 0xfff0,
+	  .name = "BCM54210E",
+	  .cfg.fp_set = phy_broadcom0,
+	  .cfg.fp_clr = recov_phy_broadcom0 },
+	{ .id1 = 0x0143,
+	  .id2 = 0xbd63,
+	  .id2_mask = 0xfff0,
+	  .name = "BCM54610C",
+	  .cfg.fp_set = phy_broadcom0,
+	  .cfg.fp_clr = recov_phy_broadcom0 },
+	{ .id1 = 0x0040,
+	  .id2 = 0x61e0,
+	  .id2_mask = PHYID3_Mask,
+	  .name = "BCM5221",
+	  .cfg.fp_set = phy_broadcom,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x0141,
+	  .id2 = 0x0e22,
+	  .id2_mask = 0xfff0,
+	  .name = "88E3019",
+	  .cfg.fp_set = phy_marvell3,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x0141,
+	  .id2 = 0x0dd0,
+	  .id2_mask = 0xfff0,
+	  .name = "88E15 10/12/14/18",
+	  .cfg.fp_set = phy_marvell2,
+	  .cfg.fp_clr = recov_phy_marvell2 },
+	{ .id1 = 0xff00,
+	  .id2 = 0x1761,
+	  .id2_mask = 0xffff,
+	  .name = "88E6176(IntLoop)",
+	  .cfg.fp_set = phy_marvell1,
+	  .cfg.fp_clr = recov_phy_marvell1 },
+	{ .id1 = 0xff00,
+	  .id2 = 0x1152,
+	  .id2_mask = 0xffff,
+	  .name = "88E6320(IntLoop)",
+	  .cfg.fp_set = phy_marvell1,
+	  .cfg.fp_clr = recov_phy_marvell1 },
+	{ .id1 = 0x0141,
+	  .id2 = 0x0e90,
+	  .id2_mask = 0xfff0,
+	  .name = "88E1310",
+	  .cfg.fp_set = phy_marvell0,
+	  .cfg.fp_clr = recov_phy_marvell0 },
+	{ .id1 = 0x0141,
+	  .id2 = 0x0cc0,
+	  .id2_mask = PHYID3_Mask,
+	  .name = "88E1111",
+	  .cfg.fp_set = phy_marvell,
+	  .cfg.fp_clr = recov_phy_marvell },
+	{ .id1 = 0x0022,
+	  .id2 = 0x1555,
+	  .id2_mask = 0xfff0,
+	  .name = "KSZ8031/KSZ8051",
+	  .cfg.fp_set = phy_micrel0,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x0022,
+	  .id2 = 0x1622,
+	  .id2_mask = 0xfff0,
+	  .name = "KSZ9031",
+	  .cfg.fp_set = phy_micrel1,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x0022,
+	  .id2 = 0x1562,
+	  .id2_mask = 0xfff0,
+	  .name = "KSZ8081",
+	  .cfg.fp_set = phy_micrel2,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x0022,
+	  .id2 = 0x1512,
+	  .id2_mask = 0xfff0,
+	  .name = "KSZ8041",
+	  .cfg.fp_set = phy_micrel,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x004d,
+	  .id2 = 0xd072,
+	  .id2_mask = 0xfff0,
+	  .name = "AR8035",
+	  .cfg.fp_set = phy_atheros,
+	  .cfg.fp_clr = recov_phy_atheros },
+	{ .id1 = 0x0007,
+	  .id2 = 0xc0c4,
+	  .id2_mask = PHYID3_Mask,
+	  .name = "LAN8700",
+	  .cfg.fp_set = phy_smsc,
+	  .cfg.fp_clr = NULL },
+	{ .id1 = 0x000f,
+	  .id2 = 0xc4b1,
+	  .id2_mask = 0xfff0,
+	  .name = "VSC8211",
+	  .cfg.fp_set = phy_vitesse,
+	  .cfg.fp_clr = recov_phy_vitesse },
+	{ .id1 = 0x0007,
+	  .id2 = 0x0421,
+	  .id2_mask = 0xfff0,
+	  .name = "VSC8601",
+	  .cfg.fp_set = phy_vitesse,
+	  .cfg.fp_clr = recov_phy_vitesse },
+	{ .id1 = 0x0007,
+	  .id2 = 0x0431,
+	  .id2_mask = 0xfff0,
+	  .name = "VSC8641",
+	  .cfg.fp_set = phy_vitesse,
+	  .cfg.fp_clr = recov_phy_vitesse },
+	{ .id1 = 0x0000,
+	  .id2 = 0x0000,
+	  .id2_mask = 0x0000,
+	  .name = "default",
+	  .cfg.fp_set = phy_default,
+	  .cfg.fp_clr = NULL },
+};
\ No newline at end of file
diff -Naur uboot/oem/ami/standalone/nettest/stdalone.c uboot-new/oem/ami/standalone/nettest/stdalone.c
--- uboot/oem/ami/standalone/nettest/stdalone.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/stdalone.c	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,63 @@
+/*
+(C) Copyright 2020
+ American Megatrends Inc
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of
+ the License, or (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ MA 02111-1307 USA
+*/
+
+#include "stdalone.h"
+#include "comminf.h"
+
+/*standalone application*/
+cmd_map_t cmd_map[CMD_MAX] = {
+		{"mactest", s_do_mactest},
+		{"mactestd", s_do_mactestd},
+		{"ncsitest", s_do_ncsitest},
+		{"ncsitestd", s_do_ncsitestd},
+		{"dramtest", s_do_dramtest},
+};
+
+extern int main_function(int argc, char * const argv[], char mode);
+extern int dram_stress_function(int argc, char * const argv[]);
+
+int s_do_mactest(int argc, char * const argv[])
+{
+	display_lantest_log_msg = 0;
+	return main_function( argc, argv, MODE_DEDICATED );
+}
+
+int s_do_mactestd(int argc, char * const argv[])
+{
+	display_lantest_log_msg = 1;
+	return main_function( argc, argv, MODE_DEDICATED );
+}
+
+int s_do_ncsitest(int argc, char * const argv[])
+{
+	display_lantest_log_msg = 0;
+	return main_function( argc, argv, MODE_NCSI );
+}
+
+int s_do_ncsitestd(int argc, char * const argv[])
+{
+	display_lantest_log_msg = 1;
+	return main_function( argc, argv, MODE_NCSI );
+}
+
+int s_do_dramtest (int argc, char * const argv[])
+{
+	return dram_stress_function( argc, argv);
+}
diff -Naur uboot/oem/ami/standalone/nettest/stdalone.h uboot-new/oem/ami/standalone/nettest/stdalone.h
--- uboot/oem/ami/standalone/nettest/stdalone.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/stdalone.h	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,38 @@
+/*
+(C) Copyright 2020
+ American Megatrends Inc
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of
+ the License, or (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ MA 02111-1307 USA
+*/
+
+#ifndef STD_ALONE_H
+#define STD_ALONE_H
+
+#define CMD_MAX 5
+#define CMD_NAME_LEN 20
+
+typedef struct {
+	char cmdname[CMD_NAME_LEN];
+	int (*cmdfunc)(int argc, char * const argv[]);
+}cmd_map_t;
+
+int s_do_mactest (int argc, char * const argv[]);
+int s_do_mactestd (int argc, char * const argv[]);
+int s_do_ncsitest (int argc, char * const argv[]);
+int s_do_ncsitestd (int argc, char * const argv[]);
+int s_do_dramtest (int argc, char * const argv[]);
+
+#endif
diff -Naur uboot/oem/ami/standalone/nettest/stduboot.c uboot-new/oem/ami/standalone/nettest/stduboot.c
--- uboot/oem/ami/standalone/nettest/stduboot.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/stduboot.c	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,225 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define STDUBOOT_C
+
+#include <common.h>
+#include <console.h>
+#include "swfunc.h"
+#include <stdarg.h>
+
+int isspace(char c)
+{
+	if ((c == ' ') || (c == 9) || (c == 13))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * strtoul.c --
+ *
+ *  Source code for the "strtoul" library procedure.
+ *
+ * Copyright 1988 Regents of the University of California
+ * Permission to use, copy, modify, and distribute this
+ * software and its documentation for any purpose and without
+ * fee is hereby granted, provided that the above copyright
+ * notice appear in all copies.  The University of California
+ * makes no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without
+ * express or implied warranty.
+ */
+
+//#include <ctype.h>
+
+/*
+ * The table below is used to convert from ASCII digits to a
+ * numerical equivalent.  It maps from '0' through 'z' to integers
+ * (100 for non-digit characters).
+ */
+
+static char cvtIn[] = {
+		0,   1,   2,   3,   4,   5,   6,   7,  8,  9,  /* '0' - '9' */
+		100, 100, 100, 100, 100, 100, 100,		   /* punctuation */
+		10,  11,  12,  13,  14,  15,  16,  17, 18, 19, /* 'A' - 'Z' */
+		20,  21,  22,  23,  24,  25,  26,  27, 28, 29, 30, 31, 32, 33, 34, 35,
+		100, 100, 100, 100, 100, 100,		   /* punctuation */
+		10,  11,  12,  13,  14,  15,  16,  17, 18, 19, /* 'a' - 'z' */
+		20,  21,  22,  23,  24,  25,  26,  27, 28, 29, 30, 31, 32, 33, 34, 35};
+
+/**
+ * @brief	Convert an ASCII string into an integer
+ * @param[in] 	string - String of ASCII digits, possibly preceded by white
+ * 		space.  For bases greater than 10, either lower- or upper-case
+ *		digits may be used.
+ * @param[in] 	**endPtr - Where to store address of terminating character
+ * @param[in] 	base - Base for conversion.  Must be less than 37.  If 0, then
+ * 		the base is chosen from the leading characters of string: "0x"
+ * 		means hex, "0" means octal, anything else means decimal.
+ *
+ * The return value is the integer equivalent of string.  If endPtr is non-NULL,
+ * then *endPtr is filled in with the character after the last one that was part
+ * of the integer.  If string doesn't contain a valid integer value, then zero 
+ * is returned and *endPtr is set to string.
+ */
+unsigned long strtoul_ext(char *string, char **endPtr, int base)
+/* string;     String of ASCII digits, possibly
+ * preceded by white space.  For bases
+ * greater than 10, either lower- or
+ * upper-case digits may be used.
+ */
+/* **endPtr;   Where to store address of terminating
+ * character, or NULL. */
+/* base;       Base for conversion.  Must be less
+ * than 37.  If 0, then the base is chosen
+ * from the leading characters of string:
+ * "0x" means hex, "0" means octal, anything
+ * else means decimal.
+ */
+{
+	register char *p = NULL;
+	register unsigned long int result = 0;
+	register unsigned digit = 0;
+	int anyDigits = 0;
+
+	/*
+	 * Skip any leading blanks.
+	 */
+
+	p = string;
+	while (isspace(*p)) {
+		p += 1;
+	}
+
+	/*
+	 * If no base was provided, pick one from the leading characters
+	 * of the string.
+	 */
+
+	if (base == 0)
+	{
+		if (*p == '0') {
+			p += 1;
+			if (*p == 'x') {
+				p += 1;
+				base = 16;
+			} else {
+
+				/*
+				 * Must set anyDigits here, otherwise "0" produces a
+				 * "no digits" error.
+				 */
+
+				anyDigits = 1;
+				base = 8;
+			}
+		}
+		else base = 10;
+	} else if (base == 16) {
+
+		/*
+		 * Skip a leading "0x" from hex numbers.
+		 */
+
+		if ((p[0] == '0') && (p[1] == 'x')) {
+			p += 2;
+		}
+	}
+
+	/*
+	 * Sorry this code is so messy, but speed seems important.  Do
+	 * different things for base 8, 10, 16, and other.
+	 */
+
+	if (base == 8) {
+		for ( ; ; p += 1) {
+			digit = *p - '0';
+			if (digit > 7) {
+				break;
+			}
+			result = (result << 3) + digit;
+			anyDigits = 1;
+		}
+	} else if (base == 10) {
+		for ( ; ; p += 1) {
+			digit = *p - '0';
+			if (digit > 9) {
+				break;
+			}
+			result = (10*result) + digit;
+			anyDigits = 1;
+		}
+	} else if (base == 16) {
+		for ( ; ; p += 1) {
+			digit = *p - '0';
+			if (digit > ('z' - '0')) {
+				break;
+			}
+			digit = cvtIn[digit];
+			if (digit > 15) {
+				break;
+			}
+			result = (result << 4) + digit;
+			anyDigits = 1;
+		}
+	} else {
+		for ( ; ; p += 1) {
+			digit = *p - '0';
+			if (digit > ('z' - '0')) {
+				break;
+			}
+			digit = cvtIn[digit];
+			if (digit >= base) {
+				break;
+			}
+			result = result*base + digit;
+			anyDigits = 1;
+		}
+	}
+
+	/*
+	 * See if there were any digits at all.
+	 */
+
+	if (!anyDigits) {
+		p = string;
+	}
+
+	if (endPtr != 0) {
+		*endPtr = p;
+	}
+
+	return result;
+}
+
+// -----------------------------------------------------------------------------
+int atoi( char s[] )
+{
+
+	int i  = 0;
+	int ans = 0;
+
+	for( i = 0; s[i] >= '0' && s[i] <= '9'; ++i )
+		ans = ( 10 * ans ) + ( s[i] - '0' );
+
+	return ans;
+}
+
+
+unsigned int rand(void)
+{
+	static unsigned long int next = 1;
+
+	next = next * 1103515245 + 12345;
+
+	return (unsigned int) ( next / 65536 ) % 32768;
+}
diff -Naur uboot/oem/ami/standalone/nettest/stduboot.h uboot-new/oem/ami/standalone/nettest/stduboot.h
--- uboot/oem/ami/standalone/nettest/stduboot.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/stduboot.h	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,17 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _STDUBOOT_H_
+#define _STDUBOOT_H_
+
+int atoi(char s[]);
+
+#endif /* end of "#ifndef _STDUBOOT_H_" */
diff -Naur uboot/oem/ami/standalone/nettest/stress.c uboot-new/oem/ami/standalone/nettest/stress.c
--- uboot/oem/ami/standalone/nettest/stress.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/stress.c	2021-01-06 11:51:55.000000000 -0500
@@ -0,0 +1,207 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <console.h>
+#include <bootretry.h>
+#include <cli.h>
+#include <command.h>
+#include <console.h>
+
+#include <inttypes.h>
+#include <mapmem.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define DRAM_BASE	0x80000000
+#define TIMEOUT_DRAM	5000000
+
+#ifdef CONFIG_ASPEED_AST2600
+#define BLK_SIZE_MB				64
+#define N_BLK					32
+#define MCR74_BLK_OFFSET		26
+#define MCR74_LEN_OFFSET		4
+#define MCR74_BLK_LEN_MASK		GENMASK(30, 4)
+#else
+#define BLK_SIZE_MB				16
+#define N_BLK					64
+#define MCR74_BLK_OFFSET		24
+#define MCR74_LEN_OFFSET		4
+#define MCR74_BLK_LEN_MASK		GENMASK(29, 4)
+#endif
+#define BLK_SIZE				(BLK_SIZE_MB * 1024 * 1024)
+#define N_16B_IN_BLK			(BLK_SIZE / 16)
+
+/* ------------------------------------------------------------------------- */
+int MMCTestBurst(unsigned int datagen)
+{
+	unsigned int data = 0;
+	unsigned int timeout = 0;
+
+	writel(0x00000000, 0x1E6E0070);
+	writel((0x000000C1 | (datagen << 3)), 0x1E6E0070);
+
+	do {
+		data = readl(0x1E6E0070) & 0x3000;
+
+		if( data & 0x2000 ){
+			return(0);
+		}
+
+		if( ++timeout > TIMEOUT_DRAM ) {
+			printf("Timeout!!\n");
+			writel(0x00000000, 0x1E6E0070);
+			return(0);
+		} 
+	} while (!data);
+
+	writel(0x00000000, 0x1E6E0070);
+
+	return(1);
+}
+
+/* ------------------------------------------------------------------------- */
+int MMCTestSingle(unsigned int datagen)
+{
+	unsigned int data = 0;
+	unsigned int timeout = 0;
+
+	writel(0x00000000, 0x1E6E0070);
+	writel((0x00000085 | (datagen << 3)), 0x1E6E0070);
+
+	do {
+		data = readl(0x1E6E0070) & 0x3000;
+
+		if( data & 0x2000 ){
+			return(0);
+		}
+
+		if( ++timeout > TIMEOUT_DRAM ){
+			printf("Timeout!!\n");
+			writel(0x00000000, 0x1E6E0070);
+
+			return(0);
+		}
+	} while ( !data );
+
+	writel(0x00000000, 0x1E6E0070);
+
+	return(1);
+}
+
+/* ------------------------------------------------------------------------- */
+int MMCTest(void)
+{
+	unsigned int pattern;
+
+	pattern = rand();
+	writel(pattern, 0x1E6E007C);
+	printf("Pattern = %08X : ",pattern);
+  
+
+	if(!MMCTestBurst(0))    return(0);
+	if(!MMCTestBurst(1))    return(0);
+	if(!MMCTestBurst(2))    return(0);
+	if(!MMCTestBurst(3))    return(0);
+	if(!MMCTestBurst(4))    return(0);
+	if(!MMCTestBurst(5))    return(0);
+	if(!MMCTestBurst(6))    return(0);
+	if(!MMCTestBurst(7))    return(0);
+	if(!MMCTestSingle(0))   return(0);
+	if(!MMCTestSingle(1))   return(0);
+	if(!MMCTestSingle(2))   return(0);
+	if(!MMCTestSingle(3))   return(0);
+	if(!MMCTestSingle(4))   return(0);
+	if(!MMCTestSingle(5))   return(0);
+	if(!MMCTestSingle(6))   return(0);
+	if(!MMCTestSingle(7))   return(0);
+
+	return(1);
+}
+
+/* ------------------------------------------------------------------------- */
+static void print_usage(void)
+{
+	printf("\nASPEED DRAM BIST\n\n");
+	printf("Usage: dramtest <count> <block> <length>\n\n");
+	printf("count:  how many iterations to run (mandatory, in decimal)\n");
+	printf("        0: infinite loop.\n");
+	printf("block:  index of the address block to test "
+			"(optional, in decimal, default: 0)\n");
+	printf("        0: [%08x, %08x)\n", DRAM_BASE + BLK_SIZE * 0, DRAM_BASE + BLK_SIZE * 1);
+	printf("        1: [%08x, %08x)\n", DRAM_BASE + BLK_SIZE * 1, DRAM_BASE + BLK_SIZE * 2);
+	printf("        2: [%08x, %08x)\n", DRAM_BASE + BLK_SIZE * 2, DRAM_BASE + BLK_SIZE * 3);
+	printf("        n: [80000000 + n*%dMB, 80000000 + (n+1)*%dMB)\n", BLK_SIZE_MB, BLK_SIZE_MB);
+	printf("           where n = [0, %d]\n", N_BLK - 1);
+	printf("length: size to test (optional, in hex, default: 0x10000)\n");
+	printf("        0x0: test the whole memory block %dMB\n", BLK_SIZE_MB);
+	printf("        0x1: test the first 16 Bytes of the memory block\n");
+	printf("        0x2: test the first 2*16 Bytes of the memory block\n");
+	printf("        n  : test the first n*16 Bytes of the memory block\n");
+	printf("             where n = [0x00000001, 0x%08x]\n", N_16B_IN_BLK - 1);
+	printf("\n\n");
+}
+int dram_stress_function(int argc, char * const argv[], char mode)
+{
+	u32 PassCnt = 0;
+	unsigned long Testcounter = 0;
+	unsigned long block = 0;
+	unsigned long length = 0x10000;
+	int ret;
+
+	if (argc < 2) {
+		ret = 0;
+		goto cmd_err;
+	}
+
+	ret = CMD_RET_USAGE;
+	switch (argc) {
+	case 4:
+		if (strict_strtoul(argv[3], 16, &length) < 0)
+			goto cmd_err;
+	case 3:
+		if (strict_strtoul(argv[2], 10, &block) < 0)
+			goto cmd_err;
+	case 2:
+		if (strict_strtoul(argv[1], 10, &Testcounter) < 0)
+			goto cmd_err;
+		break;
+	}
+
+	printf("Test range: 0x%08lx - 0x%08lx\n", DRAM_BASE + (block << MCR74_BLK_OFFSET),
+	       DRAM_BASE + (block << MCR74_BLK_OFFSET) + (length << 4) + 15);
+
+	ret = 1;
+	writel(0xFC600309, 0x1E6E0000);
+	while ((Testcounter > PassCnt) || (Testcounter == 0)) {
+		clrsetbits_le32(0x1E6E0074, MCR74_BLK_LEN_MASK,
+				(block << MCR74_BLK_OFFSET) | (length << MCR74_LEN_OFFSET));
+
+		if (!MMCTest()) {
+			printf("FAIL %d/%ld (fail DQ 0x%08x)\n", PassCnt,
+			       Testcounter, readl(0x1E6E0078));
+			ret = 0;
+			break;
+		} else {
+			PassCnt++;
+			printf("Pass %d/%ld\n", PassCnt, Testcounter);
+		}
+	}
+
+	return (ret);
+
+cmd_err:	
+	print_usage();
+	return (ret);
+}
+
diff -Naur uboot/oem/ami/standalone/nettest/stubs.c uboot-new/oem/ami/standalone/nettest/stubs.c
--- uboot/oem/ami/standalone/nettest/stubs.c	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/stubs.c	2021-01-06 11:27:30.070290581 -0500
@@ -0,0 +1,309 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <exports.h>
+#include <linux/compiler.h>
+
+#define FO(x) offsetof(struct jt_funcs, x)
+
+#if defined(CONFIG_X86)
+/*
+ * x86 does not have a dedicated register to store the pointer to
+ * the global_data. Thus the jump table address is stored in a
+ * global variable, but such approach does not allow for execution
+ * from flash memory. The global_data address is passed as argv[-1]
+ * to the application program.
+ */
+static struct jt_funcs *jt;
+gd_t *global_data;
+
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	movl	%0, %%eax\n"		\
+				"	movl	jt, %%ecx\n"		\
+				"	jmp	*(%%ecx, %%eax)\n"	\
+				: : "i"(FO(x)) : "eax", "ecx");
+#elif defined(CONFIG_PPC)
+/*
+ * r2 holds the pointer to the global_data, r11 is a call-clobbered
+ * register
+ */
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	lwz	%%r11, %0(%%r2)\n"	\
+				"	lwz	%%r11, %1(%%r11)\n"	\
+				"	mtctr	%%r11\n"		\
+				"	bctr\n"				\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "r11");
+#elif defined(CONFIG_ARM)
+#ifdef CONFIG_ARM64
+/*
+ * x18 holds the pointer to the global_data, x9 is a call-clobbered
+ * register
+ */
+
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	ldr	x9, [x18, %0]\n"		\
+				"	ldr	x9, [x9, %1]\n"		\
+				"	br	x9\n"		\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "x9");
+#else
+/*
+ * r9 holds the pointer to the global_data, ip is a call-clobbered
+ * register
+ */
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	ldr	ip, [r9, %0]\n"		\
+				"	ldr	pc, [ip, %1]\n"		\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "ip");
+#endif
+#elif defined(CONFIG_MIPS)
+#ifdef CONFIG_CPU_MIPS64
+/*
+ * k0 ($26) holds the pointer to the global_data; t9 ($25) is a call-
+ * clobbered register that is also used to set gp ($26). Note that the
+ * jr instruction also executes the instruction immediately following
+ * it; however, GCC/mips generates an additional `nop' after each asm
+ * statement
+ */
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	ld	$25, %0($26)\n"		\
+				"	ld	$25, %1($25)\n"		\
+				"	jr	$25\n"			\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "t9");
+#else
+/*
+ * k0 ($26) holds the pointer to the global_data; t9 ($25) is a call-
+ * clobbered register that is also used to set gp ($26). Note that the
+ * jr instruction also executes the instruction immediately following
+ * it; however, GCC/mips generates an additional `nop' after each asm
+ * statement
+ */
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	lw	$25, %0($26)\n"		\
+				"	lw	$25, %1($25)\n"		\
+				"	jr	$25\n"			\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "t9");
+#endif
+#elif defined(CONFIG_NIOS2)
+/*
+ * gp holds the pointer to the global_data, r8 is call-clobbered
+ */
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	movhi	r8, %%hi(%0)\n"		\
+				"	ori	r8, r0, %%lo(%0)\n"	\
+				"	add	r8, r8, gp\n"		\
+				"	ldw	r8, 0(r8)\n"		\
+				"	ldw	r8, %1(r8)\n"		\
+				"	jmp	r8\n"			\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "gp");
+#elif defined(CONFIG_M68K)
+/*
+ * d7 holds the pointer to the global_data, a0 is a call-clobbered
+ * register
+ */
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	move.l	%%d7, %%a0\n"		\
+				"	adda.l	%0, %%a0\n"		\
+				"	move.l	(%%a0), %%a0\n"		\
+				"	adda.l	%1, %%a0\n"		\
+				"	move.l	(%%a0), %%a0\n"		\
+				"	jmp	(%%a0)\n"			\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "a0");
+#elif defined(CONFIG_MICROBLAZE)
+/*
+ * r31 holds the pointer to the global_data. r5 is a call-clobbered.
+ */
+#define EXPORT_FUNC(f, a, x, ...)				\
+		asm volatile (				\
+				"	.globl " #x "\n"			\
+				#x ":\n"					\
+				"	lwi	r5, r31, %0\n"			\
+				"	lwi	r5, r5, %1\n"			\
+				"	bra	r5\n"				\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "r5");
+#elif defined(CONFIG_SH)
+/*
+ * r13 holds the pointer to the global_data. r1 is a call clobbered.
+ */
+#define EXPORT_FUNC(f, a, x, ...)					\
+		asm volatile (					\
+				"	.align	2\n"			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	mov	r13, r1\n"		\
+				"	add	%0, r1\n"		\
+				"	mov.l @r1, r2\n"	\
+				"	add	%1, r2\n"		\
+				"	mov.l @r2, r1\n"	\
+				"	jmp	@r1\n"			\
+				"	nop\n"				\
+				"	nop\n"				\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "r1", "r2");
+#elif defined(CONFIG_NDS32)
+/*
+ * r16 holds the pointer to the global_data. gp is call clobbered.
+ * not support reduced register (16 GPR).
+ */
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	lwi	$r16, [$gp + (%0)]\n"	\
+				"	lwi	$r16, [$r16 + (%1)]\n"	\
+				"	jr	$r16\n"			\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "$r16");
+#elif defined(CONFIG_RISCV)
+/*
+ * gp holds the pointer to the global_data. t0 is call clobbered.
+ */
+#ifdef CONFIG_ARCH_RV64I
+#define EXPORT_FUNC(f, a, x, ...)	\
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	ld	t0, %0(gp)\n"		\
+				"	ld	t0, %1(t0)\n"		\
+				"	jr	t0\n"			\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "t0");
+#else
+#define EXPORT_FUNC(f, a, x, ...)	\
+		asm volatile (			\
+				"	.globl " #x "\n"		\
+				#x ":\n"				\
+				"	lw	t0, %0(gp)\n"		\
+				"	lw	t0, %1(t0)\n"		\
+				"	jr	t0\n"			\
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "t0");
+#endif
+#elif defined(CONFIG_ARC)
+/*
+ * r25 holds the pointer to the global_data. r10 is call clobbered.
+ */
+#define EXPORT_FUNC(f, a, x, ...) \
+		asm volatile( \
+				"	.align 4\n" \
+				"	.globl " #x "\n" \
+				#x ":\n" \
+				"	ld	r10, [r25, %0]\n" \
+				"	ld	r10, [r10, %1]\n" \
+				"	j	[r10]\n" \
+				: : "i"(offsetof(gd_t, jt)), "i"(FO(x)) : "r10");
+#elif defined(CONFIG_XTENSA)
+/*
+ * Global data ptr is in global_data, jump table ptr is in jt.
+ * Windowed ABI: Jump just past 'entry' in target and adjust stack frame
+ * (extract stack frame size from target 'entry' instruction).
+ */
+
+static void **jt;
+
+#if defined(__XTENSA_CALL0_ABI__)
+#define EXPORT_FUNC(f, a, x, ...)	\
+		asm volatile (			\
+				"	.extern jt\n"			\
+				"	.globl " #x "\n"		\
+				"	.align 4\n"			\
+				#x ":\n"				\
+				"	l32i	a8, %0, 0\n"		\
+				"	l32i	a8, a8, %1\n"		\
+				"	jx	a8\n"			\
+				: : "r"(jt), "i" (FO(x)) : "a8");
+#elif defined(__XTENSA_WINDOWED_ABI__)
+#if XCHAL_HAVE_BE
+# define SFT "8"
+#else
+# define SFT "12"
+#endif
+#define EXPORT_FUNC(f, a, x, ...)	\
+		asm volatile (			\
+				"	.extern jt\n"			\
+				"	.globl " #x "\n"		\
+				"	.align 4\n"			\
+				#x ":\n"				\
+				"	entry	sp, 16\n"		\
+				"	l32i	a8, %0, 0\n"		\
+				"	l32i	a8, a8, %1\n"		\
+				"	l32i	a9, a8, 0\n"		\
+				"	extui	a9, a9, " SFT ", 12\n"	\
+				"	subx8	a9, a9, sp\n"		\
+				"	movi	a10, 16\n"		\
+				"	sub	a9, a10, a9\n"		\
+				"	movsp	sp, a9\n"		\
+				"	addi	a8, a8, 3\n"		\
+				"	jx	a8\n"			\
+				: : "r"(jt), "i" (FO(x)) : "a8", "a9", "a10");
+#else
+#error Unsupported Xtensa ABI
+#endif
+#else
+/*"	addi	$sp, $sp, -24\n"	\
+"	br	$r16\n"			\*/
+
+#error stubs definition missing for this architecture
+#endif
+
+/* This function is necessary to prevent the compiler from
+ * generating prologue/epilogue, preparing stack frame etc.
+ * The stub functions are special, they do not use the stack
+ * frame passed to them, but pass it intact to the actual
+ * implementation. On the other hand, asm() statements with
+ * arguments can be used only inside the functions (gcc limitation)
+ */
+#if GCC_VERSION < 30400
+static
+#endif /* GCC_VERSION */
+void __attribute__((unused)) dummy(void)
+{
+#include <_exports.h>
+}
+
+#include <asm/sections.h>
+
+void app_startup(char * const *argv)
+{
+	char *cp = __bss_start;
+
+	/* Zero out BSS */
+	while (cp < _end)
+		*cp++ = 0;
+
+#if defined(CONFIG_X86)
+	/* x86 does not have a dedicated register for passing global_data */
+	global_data = (gd_t *)argv[-1];
+	jt = global_data->jt;
+#endif
+}
+
+#undef EXPORT_FUNC
diff -Naur uboot/oem/ami/standalone/nettest/swfunc.h uboot-new/oem/ami/standalone/nettest/swfunc.h
--- uboot/oem/ami/standalone/nettest/swfunc.h	1969-12-31 19:00:00.000000000 -0500
+++ uboot-new/oem/ami/standalone/nettest/swfunc.h	2020-11-20 04:00:27.000000000 -0500
@@ -0,0 +1,85 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef SWFUNC_H
+#define SWFUNC_H
+
+#include <config.h> // for uboot system
+
+//---------------------------------------------------------
+// Program information
+//---------------------------------------------------------
+/* PHY in Normal mode */
+#define VER_NAME "Ver 0.77 version @2017/12/20 1310"
+
+/* ========================================================== */
+#define NETESTCMD_MAX_ARGS CONFIG_SYS_MAXARGS
+
+/* == Step 4:==========   Select PHY    ================== */
+
+/* ======================== Program flow control ======================== */
+#define RUN_STEP                                 5
+// 1: parameter setup
+// 2: mdc/mdio pinmux,
+// 4: Data Initial
+// 5: ALL
+
+/* ====================== Switch print debug message ====================== */
+//#define   DbgPrn_Enable_Debug_pause                //[off]
+//#define DBG_LOG_FUNC_NAME
+#define DBG_PRINT_ERR_FLAG		0
+#define DbgPrn_BufAdr			0
+#define DbgPrn_Bufdat			0
+#define DbgPrn_BufdatDetail		0
+#define DbgPrn_PHYRW			0
+#define DbgPrn_PHYInit			0
+#define DbgPrn_PHYName			0
+#define DbgPrn_DumpMACCnt		0
+#define DbgPrn_Info			    0
+#define DbgPrn_FRAME_LEN		0
+
+#ifdef DBG_LOG_FUNC_NAME
+#define nt_log_func_name()				\
+			do{printf("%s\n", __func__); debug_pause();}while(0)
+#else
+#define nt_log_func_name(...)
+#endif
+/* ============ Enable or Disable Check item of the descriptor ============ */
+    #define CheckRxOwn
+    #define CheckRxLen
+    #define CheckRxErr
+    #define CheckCRC
+    #define CheckFTL
+    #define CheckRunt
+//    #define CheckOddNibble
+    #define CheckRxFIFOFull
+  
+
+//    #define CheckRxbufUNAVA
+    #define CheckRPktLost
+//    #define CheckNPTxbufUNAVA
+    #define CheckTPktLost
+    #define CheckRxBuf
+    //#define CHECK_RX_DATA
+
+
+/* error mask of the RX descriptor */
+#define RXDES_EM_RXERR			BIT(18)
+#define RXDES_EM_CRC			BIT(19)
+#define RXDES_EM_FTL			BIT(20)
+#define RXDES_EM_RUNT			BIT(21)
+#define RXDES_EM_ODD_NB			BIT(22)
+#define RXDES_EM_FIFO_FULL		BIT(23)
+#define RXDES_EM_ALL                                                           \
+	(RXDES_EM_RXERR | RXDES_EM_CRC | RXDES_EM_FTL | RXDES_EM_RUNT |        \
+	 RXDES_EM_ODD_NB | RXDES_EM_FIFO_FULL)
+
+#endif // SWFUNC_H
diff -Naur uboot/oem/Makefile uboot-new/oem/Makefile
--- uboot/oem/Makefile	2021-01-06 11:22:28.581596688 -0500
+++ uboot-new/oem/Makefile	2021-01-06 11:29:30.000000000 -0500
@@ -1,4 +1,13 @@
 obj-y += ami/fmh/
+ifeq ($(CONFIG_SPX_FEATURE_LAN_AND_DRAM_TEST_CMD),"YES")
+ifndef CONFIG_SANDBOX
+ifdef FTRACE
+subdir-ccflags-y += -finstrument-functions -DFTRACE
+endif
+subdir-y += ami/standalone/nettest
+endif
+obj-y += ami/standalone/
+endif
 ifeq ($(CONFIG_SPX_FEATURE_WRITE_MAC_TO_EEPROM_SUPPORT),"YES")
 obj-y += ami/mac_eeprom/
 endif
