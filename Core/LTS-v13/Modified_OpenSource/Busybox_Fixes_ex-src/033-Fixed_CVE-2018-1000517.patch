--- busybox_patch031/networking/wget.c	2020-04-30 09:30:08.000000000 +0000
+++ busybox/networking/wget.c	2020-05-06 09:04:00.000000000 +0000
@@ -120,6 +120,7 @@
         const char *user_agent; /* "User-Agent" header field */
 #if ENABLE_FEATURE_WGET_TIMEOUT
 	unsigned timeout_seconds;
+	bool die_if_timed_out;
 #endif
 	int output_fd;
 	int o_flags;
@@ -142,17 +143,18 @@
 /* Must match option string! */
 enum {
 	WGET_OPT_CONTINUE   = (1 << 0),
-	WGET_OPT_SPIDER     = (1 << 1),
-	WGET_OPT_QUIET      = (1 << 2),
+	WGET_OPT_QUIET      = (1 << 1),
+	WGET_OPT_SERVER_RESPONSE = (1 << 2),
 	WGET_OPT_OUTNAME    = (1 << 3),
 	WGET_OPT_PREFIX     = (1 << 4),
 	WGET_OPT_PROXY      = (1 << 5),
 	WGET_OPT_USER_AGENT = (1 << 6),
 	WGET_OPT_NETWORK_READ_TIMEOUT = (1 << 7),
 	WGET_OPT_RETRIES    = (1 << 8),
-	WGET_OPT_PASSIVE    = (1 << 9),
+	WGET_OPT_nsomething = (1 << 9),
 	WGET_OPT_HEADER     = (1 << 10) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
 	WGET_OPT_POST_DATA  = (1 << 11) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
+	WGET_OPT_SPIDER     = (1 << 12) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
 };
 
 enum {
@@ -243,13 +245,39 @@
 	return s;
 }
 
+#if ENABLE_FEATURE_WGET_TIMEOUT
+/* Currently not use it in AMI code base */
+#if 0
+static void alarm_handler(int sig UNUSED_PARAM)
+{
+	/* This is theoretically unsafe (uses stdio and malloc in signal handler) */
+	if (G.die_if_timed_out)
+		bb_error_msg_and_die("download timed out");
+}
+#endif
+
+static void set_alarm(void)
+{
+	if (G.timeout_seconds) {
+		alarm(G.timeout_seconds);
+		G.die_if_timed_out = 1;
+	}
+}
+# define clear_alarm() ((void)(G.die_if_timed_out = 0))
+#else
+# define set_alarm()   ((void)0)
+# define clear_alarm() ((void)0)
+#endif
+
 static FILE *open_socket(len_and_sockaddr *lsa)
 {
 	FILE *fp;
 
 	/* glibc 2.4 seems to try seeking on it - ??! */
 	/* hopefully it understands what ESPIPE means... */
+	set_alarm();
 	fp = fdopen(xconnect_stream(lsa), "r+");
+	clear_alarm();
 	if (fp == NULL)
 		bb_perror_msg_and_die(bb_msg_memory_exhausted);
 
@@ -257,24 +285,34 @@
 }
 
 /* Returns '\n' if it was seen, else '\0'. Trims at first '\r' or '\n' */
-static char fgets_and_trim(FILE *fp)
+static char fgets_trim_sanitize(FILE *fp, const char *fmt)
 {
 	char c;
 	char *buf_ptr;
 
-	if (fgets(G.wget_buf, sizeof(G.wget_buf) - 1, fp) == NULL) {
+	set_alarm();
+	if (fgets(G.wget_buf, sizeof(G.wget_buf), fp) == NULL) {
 		set_status_type(FW_UPDATE_CANNOT_ESTABLISH_CONNECTION); 
 		bb_perror_msg_and_die("error getting response");
 	}
+	clear_alarm();
 	
 	buf_ptr = strchrnul(G.wget_buf, '\n');
 	c = *buf_ptr;
+#if 1
+	/* Disallow any control chars: trim at first char < 0x20 */
+	sanitize_string(G.wget_buf);
+#else
 	*buf_ptr = '\0';
 	buf_ptr = strchrnul(G.wget_buf, '\r');
 	*buf_ptr = '\0';
+#endif
 
 	log_io("< %s", G.wget_buf);
 
+	if (fmt && (option_mask32 & WGET_OPT_SERVER_RESPONSE))
+		fprintf(stderr, fmt, G.wget_buf);
+
 	return c;
 }
 
@@ -289,8 +327,10 @@
 		log_io("> %s%s", s1, s2);
 	}
 
+	/* Read until "Nxx something" is received */
+	G.wget_buf[3] = 0;
 	do {
-		fgets_and_trim(fp);
+		fgets_trim_sanitize(fp, "%s\n");
 	} while (!isdigit(G.wget_buf[0]) || G.wget_buf[3] != ' ');
 
 	G.wget_buf[3] = '\0';
@@ -375,7 +415,7 @@
 	int c;
 
 	/* retrieve header line */
-	c = fgets_and_trim(fp);
+	c = fgets_trim_sanitize(fp, "  %s\n");
 
 	/* end of the headers? */
 	if (G.wget_buf[0] == '\0')
@@ -616,12 +656,17 @@
 		if (!G.chunked)
 			break;
 
-		fgets_and_trim(dfp); /* Eat empty line */
+		/* Each chunk ends with "\r\n" - eat it */
+		fgets_trim_sanitize(dfp, NULL);
  get_clen:
-		fgets_and_trim(dfp);
+		/* chunk size format is "HEXNUM[;name[=val]]\r\n" */
+		fgets_trim_sanitize(dfp, NULL);
 		errno = 0;
 		G.content_len = STRTOOFF(G.wget_buf, NULL, 16);
-		/* FIXME: error check? */
+		/*
+		 * Had a bug with inputs like "ffffffff0001f400"
+		 * smashing the heap later. Ensure >= 0.
+		 */
 		if (G.content_len < 0 || errno)
 			bb_error_msg_and_die("bad chunk length '%s'", G.wget_buf);		
 		if (G.content_len == 0)
@@ -805,7 +850,7 @@
 		 * Retrieve HTTP response line and check for "200" status code.
 		 */
  read_response:
-		fgets_and_trim(sfp);
+		fgets_trim_sanitize(sfp, "  %s\n");
 
 		str = G.wget_buf;
 		str = skip_non_whitespace(str);
