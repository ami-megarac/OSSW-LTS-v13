--- busybox_patch031/archival/libarchive/data_extract_all.c	2020-04-30 17:30:08.819817882 +0800
+++ busybox/archival/libarchive/data_extract_all.c	2020-05-06 10:13:38.800221710 +0800
@@ -69,9 +69,7 @@
 			}
 		}
 		else if (existing_sb.st_mtime >= file_header->mtime) {
-			if (!(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)
-			 && !S_ISDIR(file_header->mode)
-			) {
+			if (!S_ISDIR(file_header->mode)) {
 				bb_error_msg("%s not created: newer or "
 					"same age file exists", file_header->name);
 			}
@@ -92,9 +90,9 @@
 	) {
 		/* hard link */
 		res = link(file_header->link_target, file_header->name);
-		if ((res == -1) && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)) {
+		if (res != 0) {
 			bb_perror_msg("can't create %slink "
-					"from %s to %s", "hard",
+					"from '%s' to '%s'", "hard",
 					file_header->name,
 					file_header->link_target);
 		}
@@ -119,10 +117,9 @@
 	}
 	case S_IFDIR:
 		res = mkdir(file_header->name, file_header->mode);
-		if ((res == -1)
+		if ((res != 0)
 		 && (errno != EISDIR) /* btw, Linux doesn't return this */
 		 && (errno != EEXIST)
-		 && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)
 		) {
 			bb_perror_msg("can't make dir %s", file_header->name);
 		}
@@ -130,23 +127,36 @@
 	case S_IFLNK:
 		/* Symlink */
 //TODO: what if file_header->link_target == NULL (say, corrupted tarball?)
-		res = symlink(file_header->link_target, file_header->name);
-		if ((res == -1)
-		 && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)
-		) {
-			bb_perror_msg("can't create %slink "
-				"from %s to %s", "sym",
-				file_header->name,
-				file_header->link_target);
-		}
+
+		/* To avoid a directory traversal attack via symlinks,
+		 * do not restore symlinks with ".." components
+		 * or symlinks starting with "/", unless a magic
+		 * envvar is set.
+		 *
+		 * For example, consider a .tar created via:
+		 *  $ tar cvf bug.tar anything.txt
+		 *  $ ln -s /tmp symlink
+		 *  $ tar --append -f bug.tar symlink
+		 *  $ rm symlink
+		 *  $ mkdir symlink
+		 *  $ tar --append -f bug.tar symlink/evil.py
+		 *
+		 * This will result in an archive that contains:
+		 *  $ tar --list -f bug.tar
+		 *  anything.txt
+		 *  symlink [-> /tmp]
+		 *  symlink/evil.py
+		 *
+		 * Untarring bug.tar would otherwise place evil.py in '/tmp'.
+		 */
+		create_or_remember_symlink(&archive_handle->symlink_placeholders, file_header->link_target, file_header->name);
 		break;
 	case S_IFSOCK:
 	case S_IFBLK:
 	case S_IFCHR:
 	case S_IFIFO:
 		res = mknod(file_header->name, file_header->mode, file_header->device);
-		if ((res == -1)
-		 && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)
+		if ((res != 0)
 		) {
 			bb_perror_msg("can't create node %s", file_header->name);
 		}
--- /dev/null	1970-01-01 08:00:00.000000000 +0800
+++ busybox/archival/libarchive/unsafe_symlink_target.c	2020-05-06 10:53:13.848693654 +0800
@@ -0,0 +1,32 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+#include "libbb.h"
+#include "bb_archive.h"
+
+void FAST_FUNC create_or_remember_symlink(llist_t **symlink_placeholders,			const char *target,
+		const char *linkname)
+{
+	if (target[0] == '/' || strstr(target, "..")) {
+		llist_add_to(symlink_placeholders, xasprintf("%s%c%s", linkname, '\0', target));
+		return;
+	}
+	if (symlink(target, linkname) != 0) {
+		/* shared message */
+		bb_perror_msg_and_die("can't create %slink '%s' to '%s'", "sym", linkname, target);
+	}
+}
+
+void FAST_FUNC create_symlinks_from_list(llist_t *list)
+{
+	while (list) {
+		char *target;
+		target = list->data + strlen(list->data) + 1;
+		if (symlink(target, list->data)) {
+			/* shared message */
+			bb_error_msg_and_die("can't create %slink '%s' to '%s'", "sym", list->data, target);
+			list = list->link;
+		}
+	}
+}
--- busybox_patch031/archival/tar.c	2020-04-30 17:30:08.839817891 +0800
+++ busybox/archival/tar.c	2020-05-06 10:55:08.532641546 +0800
@@ -23,25 +23,6 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 
-/* TODO: security with -C DESTDIR option can be enhanced.
- * Consider tar file created via:
- * $ tar cvf bug.tar anything.txt
- * $ ln -s /tmp symlink
- * $ tar --append -f bug.tar symlink
- * $ rm symlink
- * $ mkdir symlink
- * $ tar --append -f bug.tar symlink/evil.py
- *
- * This will result in an archive which contains:
- * $ tar --list -f bug.tar
- * anything.txt
- * symlink
- * symlink/evil.py
- *
- * Untarring it puts evil.py in '/tmp' even if the -C DESTDIR is given.
- * This doesn't feel right, and IIRC GNU tar doesn't do that.
- */
-
 #include <fnmatch.h>
 #include "libbb.h"
 #include "bb_archive.h"
@@ -1099,6 +1080,8 @@
 	while (get_header_tar(tar_handle) == EXIT_SUCCESS)
 		continue;
 
+	create_symlinks_from_list(tar_handle->symlink_placeholders);
+
 	/* Check that every file that should have been extracted was */
 	while (tar_handle->accept) {
 		if (!find_list_entry(tar_handle->reject, tar_handle->accept->data)
--- /dev/null	1970-01-01 08:00:00.000000000 +0800
+++ busybox/archival/tar_symlink_attack	2020-05-05 17:09:51.538711751 +0800
@@ -0,0 +1,16 @@
+#!/bin/sh
+# Makes "symlink attack" tarball (needs GNU tar for --append)
+
+true >anything.txt
+tar cvf tar_symlink_attack.tar anything.txt
+rm anything.txt
+
+ln -s /tmp symlink
+tar --append -f tar_symlink_attack.tar symlink
+rm symlink
+
+mkdir symlink
+echo BUG >symlink/bb_test_evilfile
+tar --append -f tar_symlink_attack.tar symlink/bb_test_evilfile
+rm symlink/bb_test_evilfile
+rmdir symlink
--- busybox_patch031/include/bb_archive.h	2020-04-30 17:30:08.919817929 +0800
+++ busybox/include/bb_archive.h	2020-05-06 10:58:30.556728791 +0800
@@ -64,6 +64,9 @@
 	/* Currently processed file's header */
 	file_header_t *file_header;
 
+	/* List of symlink placeholders */
+	llist_t *symlink_placeholders;
+
 	/* Process the header component, e.g. tar -t */
 	void FAST_FUNC (*action_header)(const file_header_t *);
 
@@ -115,14 +118,15 @@
 #define ARCHIVE_RESTORE_DATE        (1 << 0)
 #define ARCHIVE_CREATE_LEADING_DIRS (1 << 1)
 #define ARCHIVE_UNLINK_OLD          (1 << 2)
-#define ARCHIVE_EXTRACT_QUIET       (1 << 3)
-#define ARCHIVE_EXTRACT_NEWER       (1 << 4)
-#define ARCHIVE_DONT_RESTORE_OWNER  (1 << 5)
-#define ARCHIVE_DONT_RESTORE_PERM   (1 << 6)
-#define ARCHIVE_NUMERIC_OWNER       (1 << 7)
-#define ARCHIVE_O_TRUNC             (1 << 8)
-#define ARCHIVE_REMEMBER_NAMES      (1 << 9)
-
+#define ARCHIVE_EXTRACT_NEWER       (1 << 3)
+#define ARCHIVE_DONT_RESTORE_OWNER  (1 << 4)
+#define ARCHIVE_DONT_RESTORE_PERM   (1 << 5)
+#define ARCHIVE_NUMERIC_OWNER       (1 << 6)
+#define ARCHIVE_O_TRUNC             (1 << 7)
+#define ARCHIVE_REMEMBER_NAMES      (1 << 8)
+#if ENABLE_RPM
+#define ARCHIVE_REPLACE_VIA_RENAME  (1 << 9)
+#endif
 
 /* POSIX tar Header Block, from POSIX 1003.1-1990  */
 #define TAR_BLOCK_SIZE 512
@@ -186,6 +190,8 @@
 void seek_by_read(int fd, off_t amount) FAST_FUNC;
 
 const char *strip_unsafe_prefix(const char *str) FAST_FUNC;
+void create_or_remember_symlink(llist_t **symlink_placeholders, const char *target, const char *linkname) FAST_FUNC;
+void create_symlinks_from_list(llist_t *list) FAST_FUNC;
 
 void data_align(archive_handle_t *archive_handle, unsigned boundary) FAST_FUNC;
 const llist_t *find_list_entry(const llist_t *list, const char *filename) FAST_FUNC;
--- busybox_patch031/libbb/copy_file.c	2020-04-30 17:30:08.851817897 +0800
+++ busybox/libbb/copy_file.c	2020-05-05 17:44:40.391530369 +0800
@@ -345,7 +345,8 @@
 			int r = symlink(lpath, dest);
 			free(lpath);
 			if (r < 0) {
-				bb_perror_msg("can't create symlink '%s'", dest);
+				/* shared message */
+				bb_perror_msg("can't create %slink '%s' to '%s'", "sym", dest, lpath);
 				return -1;
 			}
 			if (flags & FILEUTILS_PRESERVE_STATUS)
--- busybox_patch031/archival/cpio.c	2020-04-30 17:30:08.839817891 +0800
+++ busybox/archival/cpio.c	2020-05-06 11:11:57.628280485 +0800
@@ -449,6 +449,8 @@
 	while (get_header_cpio(archive_handle) == EXIT_SUCCESS)
 		continue;
 
+	create_symlinks_from_list(archive_handle->symlink_placeholders);
+
 	if (archive_handle->cpio__blocks != (off_t)-1
 	 && !(opt & OPT_QUIET)
 	) {
--- busybox_patch031/testsuite/tar.tests	2020-04-30 17:30:09.071818001 +0800
+++ busybox/testsuite/tar.tests	2020-05-06 11:00:15.224852293 +0800
@@ -10,9 +10,6 @@
 unset LC_ALL
 umask 022
 
-rm -rf tar.tempdir 2>/dev/null
-mkdir tar.tempdir && cd tar.tempdir || exit 1
-
 # testing "test name" "script" "expected result" "file input" "stdin"
 
 optional FEATURE_TAR_CREATE FEATURE_LS_SORTFILES
@@ -48,9 +45,9 @@
 "" ""
 SKIP=
 
+mkdir tar.tempdir && cd tar.tempdir || exit 1
 optional FEATURE_TAR_CREATE FEATURE_LS_SORTFILES
 testing "tar hardlinks mode" '\
-rm -rf input_* test.tar 2>/dev/null
 >input_hard1
 chmod 741 input_hard1
 ln input_hard1 input_hard2
@@ -81,9 +78,11 @@
 "" ""
 SKIP=
 
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
+
+mkdir tar.tempdir && cd tar.tempdir || exit 1
 optional FEATURE_TAR_CREATE FEATURE_LS_SORTFILES
 testing "tar symlinks mode" '\
-rm -rf input_* test.tar 2>/dev/null
 >input_file
 chmod 741 input_file
 ln -s input_file input_soft
@@ -112,9 +111,11 @@
 "" ""
 SKIP=
 
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
+
+mkdir tar.tempdir && cd tar.tempdir || exit 1
 optional FEATURE_TAR_CREATE FEATURE_TAR_LONG_OPTIONS
 testing "tar --overwrite" "\
-rm -rf input_* test.tar 2>/dev/null
 ln input input_hard
 tar cf test.tar input_hard
 echo WRONG >input
@@ -126,12 +127,13 @@
 " \
 "Ok\n" ""
 SKIP=
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
 
+mkdir tar.tempdir && cd tar.tempdir || exit 1
 test x"$SKIP_KNOWN_BUGS" = x"" && {
 # Needs to be run under non-root for meaningful test
 optional FEATURE_TAR_CREATE
 testing "tar writing into read-only dir" '\
-rm -rf input_* test.tar 2>/dev/null
 mkdir input_dir
 >input_dir/input_file
 chmod 550 input_dir
@@ -153,7 +155,9 @@
 "" ""
 SKIP=
 }
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
 
+mkdir tar.tempdir && cd tar.tempdir || exit 1
 # Had a bug where on extract autodetect first "switched off" -z
 # and then failed to recognize .tgz extension
 optional FEATURE_TAR_CREATE FEATURE_SEAMLESS_GZ
@@ -169,7 +173,9 @@
 " \
 "" ""
 SKIP=
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
 
+mkdir tar.tempdir && cd tar.tempdir || exit 1
 # Do we detect XZ-compressed data (even w/o .tar.xz or txz extension)?
 # (the uuencoded hello_world.txz contains one empty file named "hello_world")
 optional UUDECODE FEATURE_TAR_AUTODETECT FEATURE_SEAMLESS_XZ
@@ -188,7 +194,9 @@
 ====
 "
 SKIP=
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
 
+mkdir tar.tempdir && cd tar.tempdir || exit 1
 # On extract, everything up to and including last ".." component is stripped
 optional FEATURE_TAR_CREATE
 testing "tar strips /../ on extract" "\
@@ -207,8 +215,64 @@
 " \
 "" ""
 SKIP=
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
 
-
-cd .. && rm -rf tar.tempdir || exit 1
+mkdir tar.tempdir && cd tar.tempdir || exit 1
+# attack.tar.bz2 has symlink pointing to a system file
+# followed by a regular file with the same name
+# containing "root::0:0::/root:/bin/sh":
+#  lrwxrwxrwx root/root passwd -> /tmp/passwd
+#  -rw-r--r-- root/root passwd
+# naive tar implementation may end up creating the symlink
+# and then writing into it.
+# The correct implementation unlinks target before
+# creating the second file.
+# We test that /tmp/passwd remains empty:
+optional UUDECODE FEATURE_TAR_AUTODETECT FEATURE_SEAMLESS_BZ2
+testing "tar does not extract into symlinks" "\
+>>/tmp/passwd && uudecode -o input && tar xf input 2>&1 && rm passwd; cat /tmp/passwd; echo \$?
+" "\
+tar: can't create symlink 'passwd' to '/tmp/passwd'
+0
+" \
+"" "\
+begin-base64 644 attack.tar.bz2
+QlpoOTFBWSZTWRVn/bIAAKt7hMqwAEBAAP2QAhB0Y96AAACACCAAlISgpqe0
+po0DIaDynqAkpDRP1ANAhiYNSPR8VchKhAz0AK59+DA6FcMKBggOARIJdVHL
+DGllrjs20ATUgR1HmccBX3EhoMnpMJaNyggmxgLDMz54lBnBTJO/1L1lbMS4
+l4/V8LDoe90yiWJhOJvIypgEfxdyRThQkBVn/bI=
+====
+"
+SKIP=
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
+mkdir tar.tempdir && cd tar.tempdir || exit 1
+optional FEATURE_SEAMLESS_BZ2 FEATURE_TAR_AUTODETECT
+testing "Symlink attack: create symlink and then write through it" '\
+exec 2>&1
+uudecode -o input && tar xvf input; echo $?
+ls /tmp/bb_test_evilfile
+ls bb_test_evilfile
+ls symlink/bb_test_evilfile
+' "\
+anything.txt
+symlink
+symlink/bb_test_evilfile
+tar: can't create symlink 'symlink' to '/tmp'
+1
+ls: /tmp/bb_test_evilfile: No such file or directory
+ls: bb_test_evilfile: No such file or directory
+symlink/bb_test_evilfile
+" \
+"" "\
+begin-base64 644 tar_symlink_attack.tar.bz2
+QlpoOTFBWSZTWZgs7bQAALT/hMmQAFBAAf+AEMAGJPPv32AAAIAIMAC5thlR
+omAjAmCMADQT1BqNE0AEwAAjAEwElTKeo9NTR6h6gaeoA0DQNLVdwZZ5iNTk
+AQwCAV6S00QFJYhrlfFkVCEDEGtgNVqYrI0uK3ggnt30gqk4e1TTQm5QIAKa
+SJqzRGSFLMmOloHSAcvLiFxxRiQtQZF+qPxbo173ZDISOAoNoPN4PQPhBhKS
+n8fYaKlioCTzL2oXYczyUUIP4u5IpwoSEwWdtoA=
+====
+"
+SKIP=
+cd .. || exit 1; rm -rf tar.tempdir 2>/dev/null
 
 exit $FAILCOUNT
--- busybox_patch031/archival/libarchive/Kbuild.src	2020-04-30 17:30:08.819817882 +0800
+++ busybox/archival/libarchive/Kbuild.src	2020-05-05 17:25:13.227116362 +0800
@@ -12,6 +12,8 @@
 	data_extract_all.o \
 	data_extract_to_stdout.o \
 \
+	unsafe_symlink_target.o \
+\
 	filter_accept_all.o \
 	filter_accept_list.o \
 	filter_accept_reject_list.o \
